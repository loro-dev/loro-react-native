// This file was autogenerated by some hot garbage in the
// `uniffi-bindgen-react-native` crate. Trust me, you don't want to mess with
// it!
#include "loro.hpp"

#include "UniffiJsiTypes.h"
#include <iostream>
#include <map>
#include <stdexcept>
#include <thread>
#include <utility>

namespace react = facebook::react;
namespace jsi = facebook::jsi;

// Calling into Rust.
extern "C" {
typedef void (*UniffiRustFutureContinuationCallback)(uint64_t data,
                                                     int8_t poll_result);
typedef void (*UniffiForeignFutureFree)(uint64_t handle);
typedef void (*UniffiCallbackInterfaceFree)(uint64_t handle);
typedef struct UniffiForeignFuture {
  uint64_t handle;
  UniffiForeignFutureFree free;
} UniffiForeignFuture;
typedef struct UniffiForeignFutureStructU8 {
  uint8_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructU8;
typedef void (*UniffiForeignFutureCompleteU8)(
    uint64_t callback_data, UniffiForeignFutureStructU8 result);
typedef struct UniffiForeignFutureStructI8 {
  int8_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructI8;
typedef void (*UniffiForeignFutureCompleteI8)(
    uint64_t callback_data, UniffiForeignFutureStructI8 result);
typedef struct UniffiForeignFutureStructU16 {
  uint16_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructU16;
typedef void (*UniffiForeignFutureCompleteU16)(
    uint64_t callback_data, UniffiForeignFutureStructU16 result);
typedef struct UniffiForeignFutureStructI16 {
  int16_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructI16;
typedef void (*UniffiForeignFutureCompleteI16)(
    uint64_t callback_data, UniffiForeignFutureStructI16 result);
typedef struct UniffiForeignFutureStructU32 {
  uint32_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructU32;
typedef void (*UniffiForeignFutureCompleteU32)(
    uint64_t callback_data, UniffiForeignFutureStructU32 result);
typedef struct UniffiForeignFutureStructI32 {
  int32_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructI32;
typedef void (*UniffiForeignFutureCompleteI32)(
    uint64_t callback_data, UniffiForeignFutureStructI32 result);
typedef struct UniffiForeignFutureStructU64 {
  uint64_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructU64;
typedef void (*UniffiForeignFutureCompleteU64)(
    uint64_t callback_data, UniffiForeignFutureStructU64 result);
typedef struct UniffiForeignFutureStructI64 {
  int64_t return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructI64;
typedef void (*UniffiForeignFutureCompleteI64)(
    uint64_t callback_data, UniffiForeignFutureStructI64 result);
typedef struct UniffiForeignFutureStructF32 {
  float return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructF32;
typedef void (*UniffiForeignFutureCompleteF32)(
    uint64_t callback_data, UniffiForeignFutureStructF32 result);
typedef struct UniffiForeignFutureStructF64 {
  double return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructF64;
typedef void (*UniffiForeignFutureCompleteF64)(
    uint64_t callback_data, UniffiForeignFutureStructF64 result);
typedef struct UniffiForeignFutureStructPointer {
  void *return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructPointer;
typedef void (*UniffiForeignFutureCompletePointer)(
    uint64_t callback_data, UniffiForeignFutureStructPointer result);
typedef struct UniffiForeignFutureStructRustBuffer {
  RustBuffer return_value;
  RustCallStatus call_status;
} UniffiForeignFutureStructRustBuffer;
typedef void (*UniffiForeignFutureCompleteRustBuffer)(
    uint64_t callback_data, UniffiForeignFutureStructRustBuffer result);
typedef struct UniffiForeignFutureStructVoid {
  RustCallStatus call_status;
} UniffiForeignFutureStructVoid;
typedef void (*UniffiForeignFutureCompleteVoid)(
    uint64_t callback_data, UniffiForeignFutureStructVoid result);
typedef void (*UniffiCallbackInterfaceChangeAncestorsTravelerMethod0)(
    uint64_t uniffi_handle, RustBuffer change, int8_t *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceContainerIdLikeMethod0)(
    uint64_t uniffi_handle, RustBuffer ty, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceEphemeralSubscriberMethod0)(
    uint64_t uniffi_handle, RustBuffer event, void *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceFirstCommitFromPeerCallbackMethod0)(
    uint64_t uniffi_handle, RustBuffer payload, void *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceLocalEphemeralListenerMethod0)(
    uint64_t uniffi_handle, RustBuffer update, void *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceLocalUpdateCallbackMethod0)(
    uint64_t uniffi_handle, RustBuffer update, void *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceLoroValueLikeMethod0)(
    uint64_t uniffi_handle, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceOnPopMethod0)(
    uint64_t uniffi_handle, RustBuffer undo_or_redo, RustBuffer span,
    RustBuffer undo_meta, void *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceOnPushMethod0)(
    uint64_t uniffi_handle, RustBuffer undo_or_redo, RustBuffer span,
    RustBuffer diff_event, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfacePreCommitCallbackMethod0)(
    uint64_t uniffi_handle, RustBuffer payload, void *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceSubscriberMethod0)(
    uint64_t uniffi_handle, RustBuffer diff, void *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceUnsubscriberMethod0)(
    uint64_t uniffi_handle, void *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceValueOrContainerMethod0)(
    uint64_t uniffi_handle, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceValueOrContainerMethod1)(
    uint64_t uniffi_handle, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceValueOrContainerMethod2)(
    uint64_t uniffi_handle, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceValueOrContainerMethod3)(
    uint64_t uniffi_handle, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceValueOrContainerMethod4)(
    uint64_t uniffi_handle, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceValueOrContainerMethod5)(
    uint64_t uniffi_handle, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceValueOrContainerMethod6)(
    uint64_t uniffi_handle, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceValueOrContainerMethod7)(
    uint64_t uniffi_handle, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceValueOrContainerMethod8)(
    uint64_t uniffi_handle, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceValueOrContainerMethod9)(
    uint64_t uniffi_handle, RustBuffer *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceValueOrContainerMethod10)(
    uint64_t uniffi_handle, int8_t *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef void (*UniffiCallbackInterfaceValueOrContainerMethod11)(
    uint64_t uniffi_handle, int8_t *uniffi_out_return,
    RustCallStatus *rust_call_status);
typedef struct UniffiVTableCallbackInterfaceChangeAncestorsTraveler {
  UniffiCallbackInterfaceChangeAncestorsTravelerMethod0 travel;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceChangeAncestorsTraveler;
typedef struct UniffiVTableCallbackInterfaceContainerIdLike {
  UniffiCallbackInterfaceContainerIdLikeMethod0 as_container_id;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceContainerIdLike;
typedef struct UniffiVTableCallbackInterfaceEphemeralSubscriber {
  UniffiCallbackInterfaceEphemeralSubscriberMethod0 on_ephemeral_event;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceEphemeralSubscriber;
typedef struct UniffiVTableCallbackInterfaceFirstCommitFromPeerCallback {
  UniffiCallbackInterfaceFirstCommitFromPeerCallbackMethod0
      on_first_commit_from_peer;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceFirstCommitFromPeerCallback;
typedef struct UniffiVTableCallbackInterfaceLocalEphemeralListener {
  UniffiCallbackInterfaceLocalEphemeralListenerMethod0 on_ephemeral_update;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceLocalEphemeralListener;
typedef struct UniffiVTableCallbackInterfaceLocalUpdateCallback {
  UniffiCallbackInterfaceLocalUpdateCallbackMethod0 on_local_update;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceLocalUpdateCallback;
typedef struct UniffiVTableCallbackInterfaceLoroValueLike {
  UniffiCallbackInterfaceLoroValueLikeMethod0 as_loro_value;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceLoroValueLike;
typedef struct UniffiVTableCallbackInterfaceOnPop {
  UniffiCallbackInterfaceOnPopMethod0 on_pop;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceOnPop;
typedef struct UniffiVTableCallbackInterfaceOnPush {
  UniffiCallbackInterfaceOnPushMethod0 on_push;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceOnPush;
typedef struct UniffiVTableCallbackInterfacePreCommitCallback {
  UniffiCallbackInterfacePreCommitCallbackMethod0 on_pre_commit;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfacePreCommitCallback;
typedef struct UniffiVTableCallbackInterfaceSubscriber {
  UniffiCallbackInterfaceSubscriberMethod0 on_diff;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceSubscriber;
typedef struct UniffiVTableCallbackInterfaceUnsubscriber {
  UniffiCallbackInterfaceUnsubscriberMethod0 on_unsubscribe;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceUnsubscriber;
typedef struct UniffiVTableCallbackInterfaceValueOrContainer {
  UniffiCallbackInterfaceValueOrContainerMethod0 as_container;
  UniffiCallbackInterfaceValueOrContainerMethod1 as_loro_counter;
  UniffiCallbackInterfaceValueOrContainerMethod2 as_loro_list;
  UniffiCallbackInterfaceValueOrContainerMethod3 as_loro_map;
  UniffiCallbackInterfaceValueOrContainerMethod4 as_loro_movable_list;
  UniffiCallbackInterfaceValueOrContainerMethod5 as_loro_text;
  UniffiCallbackInterfaceValueOrContainerMethod6 as_loro_tree;
  UniffiCallbackInterfaceValueOrContainerMethod7 as_loro_unknown;
  UniffiCallbackInterfaceValueOrContainerMethod8 as_value;
  UniffiCallbackInterfaceValueOrContainerMethod9 container_type;
  UniffiCallbackInterfaceValueOrContainerMethod10 is_container;
  UniffiCallbackInterfaceValueOrContainerMethod11 is_value;
  UniffiCallbackInterfaceFree uniffi_free;
} UniffiVTableCallbackInterfaceValueOrContainer;
void *uniffi_loro_rs_fn_clone_awareness(void *ptr,
                                        RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_awareness(void *ptr,
                                      RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_constructor_awareness_new(uint64_t peer, int64_t timeout,
                                            RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_awareness_apply(
    void *ptr, RustBuffer encoded_peers_info, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_awareness_encode(void *ptr, RustBuffer peers,
                                          RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_awareness_encode_all(void *ptr,
                                              RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_awareness_get_all_states(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_awareness_get_local_state(
    void *ptr, RustCallStatus *uniffi_out_err);
uint64_t
uniffi_loro_rs_fn_method_awareness_peer(void *ptr,
                                        RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_awareness_remove_outdated(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_awareness_set_local_state(
    void *ptr, void *value, RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_clone_changeancestorstraveler(void *ptr,
                                                RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_changeancestorstraveler(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_init_callback_vtable_changeancestorstraveler(
    UniffiVTableCallbackInterfaceChangeAncestorsTraveler *vtable);
int8_t uniffi_loro_rs_fn_method_changeancestorstraveler_travel(
    void *ptr, RustBuffer change, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_changemodifier(void *ptr,
                                             RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_changemodifier(void *ptr,
                                           RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_changemodifier_set_message(
    void *ptr, RustBuffer msg, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_changemodifier_set_timestamp(
    void *ptr, int64_t timestamp, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_configure(void *ptr,
                                        RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_configure(void *ptr,
                                      RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_configure_fork(void *ptr,
                                              RustCallStatus *uniffi_out_err);
int64_t uniffi_loro_rs_fn_method_configure_merge_interval(
    void *ptr, RustCallStatus *uniffi_out_err);
int8_t uniffi_loro_rs_fn_method_configure_record_timestamp(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_configure_set_merge_interval(
    void *ptr, int64_t interval, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_configure_set_record_timestamp(
    void *ptr, int8_t record, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_configure_text_style_config(
    void *ptr, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_containeridlike(void *ptr,
                                              RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_containeridlike(void *ptr,
                                            RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_init_callback_vtable_containeridlike(
    UniffiVTableCallbackInterfaceContainerIdLike *vtable);
RustBuffer uniffi_loro_rs_fn_method_containeridlike_as_container_id(
    void *ptr, RustBuffer ty, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_cursor(void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_cursor(void *ptr, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_constructor_cursor_new(RustBuffer id,
                                               RustBuffer container,
                                               RustBuffer side,
                                               uint32_t origin_pos,
                                               RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_diffbatch(void *ptr,
                                        RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_diffbatch(void *ptr,
                                      RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_constructor_diffbatch_new(RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_diffbatch_get_diff(void *ptr,
                                            RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_diffbatch_push(
    void *ptr, RustBuffer cid, RustBuffer diff, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_ephemeralstore(void *ptr,
                                             RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_ephemeralstore(void *ptr,
                                           RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_constructor_ephemeralstore_new(
    int64_t timeout, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_ephemeralstore_apply(
    void *ptr, RustBuffer data, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_ephemeralstore_delete(
    void *ptr, RustBuffer key, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_ephemeralstore_encode(void *ptr, RustBuffer key,
                                               RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_ephemeralstore_encode_all(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_ephemeralstore_get(void *ptr, RustBuffer key,
                                            RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_ephemeralstore_get_all_states(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_ephemeralstore_keys(void *ptr,
                                             RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_ephemeralstore_remove_outdated(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_ephemeralstore_set(
    void *ptr, RustBuffer key, void *value, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_ephemeralstore_subscribe(
    void *ptr, void *listener, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_ephemeralstore_subscribe_local_update(
    void *ptr, void *listener, RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_clone_ephemeralsubscriber(void *ptr,
                                            RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_ephemeralsubscriber(void *ptr,
                                                RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_init_callback_vtable_ephemeralsubscriber(
    UniffiVTableCallbackInterfaceEphemeralSubscriber *vtable);
void uniffi_loro_rs_fn_method_ephemeralsubscriber_on_ephemeral_event(
    void *ptr, RustBuffer event, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_firstcommitfrompeercallback(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_firstcommitfrompeercallback(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_init_callback_vtable_firstcommitfrompeercallback(
    UniffiVTableCallbackInterfaceFirstCommitFromPeerCallback *vtable);
void uniffi_loro_rs_fn_method_firstcommitfrompeercallback_on_first_commit_from_peer(
    void *ptr, RustBuffer payload, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_fractionalindex(void *ptr,
                                              RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_fractionalindex(void *ptr,
                                            RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_constructor_fractionalindex_from_bytes(
    RustBuffer bytes, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_constructor_fractionalindex_from_hex_string(
    RustBuffer str, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_fractionalindex_to_string(
    void *ptr, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_frontiers(void *ptr,
                                        RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_frontiers(void *ptr,
                                      RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_constructor_frontiers_decode(RustBuffer bytes,
                                               RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_constructor_frontiers_from_id(RustBuffer id,
                                                RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_constructor_frontiers_from_ids(
    RustBuffer ids, RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_constructor_frontiers_new(RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_frontiers_encode(void *ptr,
                                          RustCallStatus *uniffi_out_err);
int8_t uniffi_loro_rs_fn_method_frontiers_eq(void *ptr, void *other,
                                             RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_clone_localephemerallistener(void *ptr,
                                               RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_localephemerallistener(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_init_callback_vtable_localephemerallistener(
    UniffiVTableCallbackInterfaceLocalEphemeralListener *vtable);
void uniffi_loro_rs_fn_method_localephemerallistener_on_ephemeral_update(
    void *ptr, RustBuffer update, RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_clone_localupdatecallback(void *ptr,
                                            RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_localupdatecallback(void *ptr,
                                                RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_init_callback_vtable_localupdatecallback(
    UniffiVTableCallbackInterfaceLocalUpdateCallback *vtable);
void uniffi_loro_rs_fn_method_localupdatecallback_on_local_update(
    void *ptr, RustBuffer update, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_lorocounter(void *ptr,
                                          RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_lorocounter(void *ptr,
                                        RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_constructor_lorocounter_new(RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorocounter_decrement(
    void *ptr, double value, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorocounter_doc(void *ptr,
                                         RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorocounter_get_attached(
    void *ptr, RustCallStatus *uniffi_out_err);
double
uniffi_loro_rs_fn_method_lorocounter_get_value(void *ptr,
                                               RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorocounter_id(void *ptr,
                                        RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorocounter_increment(
    void *ptr, double value, RustCallStatus *uniffi_out_err);
int8_t uniffi_loro_rs_fn_method_lorocounter_is_attached(
    void *ptr, RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_lorocounter_is_deleted(void *ptr,
                                                RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_lorodoc(void *ptr,
                                      RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_lorodoc(void *ptr, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_constructor_lorodoc_new(RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_apply_diff(
    void *ptr, void *diff, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_attach(void *ptr,
                                             RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_check_state_correctness_slow(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_checkout(void *ptr, void *frontiers,
                                               RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_checkout_to_latest(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_clear_next_commit_options(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorodoc_cmp_with_frontiers(
    void *ptr, void *other, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_commit(void *ptr,
                                             RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_commit_with(
    void *ptr, RustBuffer options, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_compact_change_store(
    void *ptr, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_config(void *ptr,
                                              RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_config_default_text_style(
    void *ptr, RustBuffer text_style, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_config_text_style(
    void *ptr, void *text_style, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_detach(void *ptr,
                                             RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_diff(void *ptr, void *a, void *b,
                                            RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorodoc_export_json_in_id_span(
    void *ptr, RustBuffer id_span, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorodoc_export_json_updates(
    void *ptr, void *start_vv, void *end_vv, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorodoc_export_json_updates_without_peer_compression(
    void *ptr, void *start_vv, void *end_vv, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorodoc_export_shallow_snapshot(
    void *ptr, void *frontiers, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorodoc_export_snapshot(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorodoc_export_snapshot_at(
    void *ptr, void *frontiers, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorodoc_export_state_only(
    void *ptr, RustBuffer frontiers, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorodoc_export_updates(void *ptr, void *vv,
                                                RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorodoc_export_updates_in_range(
    void *ptr, RustBuffer spans, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorodoc_find_id_spans_between(
    void *ptr, void *from, void *to, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_fork(void *ptr,
                                            RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_fork_at(void *ptr, void *frontiers,
                                               RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_free_diff_calculator(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_free_history_cache(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorodoc_frontiers_to_vv(
    void *ptr, void *frontiers, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorodoc_get_by_path(void *ptr, RustBuffer path,
                                             RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorodoc_get_by_str_path(
    void *ptr, RustBuffer path, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorodoc_get_change(void *ptr, RustBuffer id,
                                            RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorodoc_get_changed_containers_in(
    void *ptr, RustBuffer id, uint32_t len, RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_method_lorodoc_get_counter(void *ptr, void *id,
                                             RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorodoc_get_cursor_pos(void *ptr, void *cursor,
                                                RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorodoc_get_deep_value(void *ptr,
                                                RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorodoc_get_deep_value_with_id(
    void *ptr, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_get_list(void *ptr, void *id,
                                                RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_get_map(void *ptr, void *id,
                                               RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_get_movable_list(
    void *ptr, void *id, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorodoc_get_path_to_container(
    void *ptr, RustBuffer id, RustCallStatus *uniffi_out_err);
uint32_t uniffi_loro_rs_fn_method_lorodoc_get_pending_txn_len(
    void *ptr, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_get_text(void *ptr, void *id,
                                                RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_get_tree(void *ptr, void *id,
                                                RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorodoc_get_value(void *ptr,
                                           RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_lorodoc_has_container(void *ptr, RustBuffer id,
                                               RustCallStatus *uniffi_out_err);
int8_t uniffi_loro_rs_fn_method_lorodoc_has_history_cache(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorodoc_import(void *ptr, RustBuffer bytes,
                                        RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorodoc_import_batch(void *ptr, RustBuffer bytes,
                                              RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorodoc_import_json_updates(
    void *ptr, RustBuffer json, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorodoc_import_with(void *ptr, RustBuffer bytes,
                                             RustBuffer origin,
                                             RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_lorodoc_is_detached(void *ptr,
                                             RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_lorodoc_is_shallow(void *ptr,
                                            RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorodoc_jsonpath(void *ptr, RustBuffer path,
                                          RustCallStatus *uniffi_out_err);
uint64_t
uniffi_loro_rs_fn_method_lorodoc_len_changes(void *ptr,
                                             RustCallStatus *uniffi_out_err);
uint64_t
uniffi_loro_rs_fn_method_lorodoc_len_ops(void *ptr,
                                         RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_log_estimate_size(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorodoc_minimize_frontiers(
    void *ptr, void *frontiers, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_oplog_frontiers(
    void *ptr, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_oplog_vv(void *ptr,
                                                RustCallStatus *uniffi_out_err);
uint64_t
uniffi_loro_rs_fn_method_lorodoc_peer_id(void *ptr,
                                         RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_revert_to(void *ptr, void *version,
                                                RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_set_change_merge_interval(
    void *ptr, int64_t interval, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_set_next_commit_message(
    void *ptr, RustBuffer msg, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_set_next_commit_options(
    void *ptr, RustBuffer options, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_set_next_commit_origin(
    void *ptr, RustBuffer origin, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_set_next_commit_timestamp(
    void *ptr, int64_t timestamp, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_set_peer_id(
    void *ptr, uint64_t peer, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_set_record_timestamp(
    void *ptr, int8_t record, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_shallow_since_vv(
    void *ptr, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_state_frontiers(
    void *ptr, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_state_vv(void *ptr,
                                                RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_method_lorodoc_subscribe(void *ptr, RustBuffer container_id,
                                           void *subscriber,
                                           RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_subscribe_first_commit_from_peer(
    void *ptr, void *callback, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_subscribe_local_update(
    void *ptr, void *callback, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_subscribe_pre_commit(
    void *ptr, void *callback, RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_method_lorodoc_subscribe_root(void *ptr, void *subscriber,
                                                RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorodoc_travel_change_ancestors(
    void *ptr, RustBuffer ids, void *f, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorodoc_vv_to_frontiers(
    void *ptr, void *vv, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_lorolist(void *ptr,
                                       RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_lorolist(void *ptr, RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_constructor_lorolist_new(RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorolist_clear(void *ptr,
                                             RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorolist_delete(void *ptr, uint32_t pos,
                                              uint32_t len,
                                              RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorolist_doc(void *ptr,
                                      RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorolist_get(void *ptr, uint32_t index,
                                      RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorolist_get_attached(void *ptr,
                                               RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorolist_get_cursor(
    void *ptr, uint32_t pos, RustBuffer side, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorolist_get_deep_value(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorolist_get_id_at(void *ptr, uint32_t pos,
                                            RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorolist_get_value(void *ptr,
                                            RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorolist_id(void *ptr,
                                                RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorolist_insert(void *ptr, uint32_t pos, void *v,
                                              RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorolist_insert_counter_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorolist_insert_list_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorolist_insert_map_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorolist_insert_movable_list_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorolist_insert_text_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_lorolist_insert_tree_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_lorolist_is_attached(void *ptr,
                                              RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_lorolist_is_deleted(void *ptr,
                                             RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_lorolist_is_empty(void *ptr,
                                           RustCallStatus *uniffi_out_err);
uint32_t uniffi_loro_rs_fn_method_lorolist_len(void *ptr,
                                               RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorolist_pop(void *ptr,
                                      RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorolist_push(void *ptr, void *v,
                                            RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorolist_to_vec(void *ptr,
                                         RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_loromap(void *ptr,
                                      RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_loromap(void *ptr, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_constructor_loromap_new(RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_loromap_clear(void *ptr,
                                            RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_loromap_delete(void *ptr, RustBuffer key,
                                             RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_loromap_doc(void *ptr,
                                                RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_loromap_get(void *ptr, RustBuffer key,
                                                RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_loromap_get_attached(void *ptr,
                                              RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_loromap_get_deep_value(void *ptr,
                                                RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_loromap_get_last_editor(
    void *ptr, RustBuffer key, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromap_get_or_create_counter_container(
    void *ptr, RustBuffer key, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromap_get_or_create_list_container(
    void *ptr, RustBuffer key, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromap_get_or_create_map_container(
    void *ptr, RustBuffer key, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromap_get_or_create_movable_list_container(
    void *ptr, RustBuffer key, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromap_get_or_create_text_container(
    void *ptr, RustBuffer key, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromap_get_or_create_tree_container(
    void *ptr, RustBuffer key, void *child, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_loromap_get_value(void *ptr,
                                           RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_loromap_id(void *ptr,
                                               RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_loromap_insert(void *ptr, RustBuffer key, void *v,
                                             RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromap_insert_counter_container(
    void *ptr, RustBuffer key, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromap_insert_list_container(
    void *ptr, RustBuffer key, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromap_insert_map_container(
    void *ptr, RustBuffer key, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromap_insert_movable_list_container(
    void *ptr, RustBuffer key, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromap_insert_text_container(
    void *ptr, RustBuffer key, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromap_insert_tree_container(
    void *ptr, RustBuffer key, void *child, RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_loromap_is_attached(void *ptr,
                                             RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_loromap_is_deleted(void *ptr,
                                            RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_loromap_is_empty(void *ptr,
                                          RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_loromap_keys(void *ptr,
                                      RustCallStatus *uniffi_out_err);
uint32_t uniffi_loro_rs_fn_method_loromap_len(void *ptr,
                                              RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_loromap_values(void *ptr,
                                        RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_loromovablelist(void *ptr,
                                              RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_loromovablelist(void *ptr,
                                            RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_constructor_loromovablelist_new(
    RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_loromovablelist_clear(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_loromovablelist_delete(
    void *ptr, uint32_t pos, uint32_t len, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_loromovablelist_doc(void *ptr,
                                             RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_loromovablelist_get(void *ptr, uint32_t index,
                                             RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_loromovablelist_get_attached(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_loromovablelist_get_creator_at(
    void *ptr, uint32_t pos, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_loromovablelist_get_cursor(
    void *ptr, uint32_t pos, RustBuffer side, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_loromovablelist_get_deep_value(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_loromovablelist_get_last_editor_at(
    void *ptr, uint32_t pos, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_loromovablelist_get_last_mover_at(
    void *ptr, uint32_t pos, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_loromovablelist_get_value(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_loromovablelist_id(void *ptr,
                                            RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_loromovablelist_insert(
    void *ptr, uint32_t pos, void *v, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromovablelist_insert_counter_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromovablelist_insert_list_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromovablelist_insert_map_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromovablelist_insert_movable_list_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromovablelist_insert_text_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromovablelist_insert_tree_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
int8_t uniffi_loro_rs_fn_method_loromovablelist_is_attached(
    void *ptr, RustCallStatus *uniffi_out_err);
int8_t uniffi_loro_rs_fn_method_loromovablelist_is_deleted(
    void *ptr, RustCallStatus *uniffi_out_err);
int8_t uniffi_loro_rs_fn_method_loromovablelist_is_empty(
    void *ptr, RustCallStatus *uniffi_out_err);
uint32_t
uniffi_loro_rs_fn_method_loromovablelist_len(void *ptr,
                                             RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_loromovablelist_mov(
    void *ptr, uint32_t from, uint32_t to, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_loromovablelist_pop(void *ptr,
                                             RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_loromovablelist_push(
    void *ptr, void *v, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_loromovablelist_set(
    void *ptr, uint32_t pos, void *value, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromovablelist_set_counter_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromovablelist_set_list_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromovablelist_set_map_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromovablelist_set_movable_list_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromovablelist_set_text_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_method_loromovablelist_set_tree_container(
    void *ptr, uint32_t pos, void *child, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_loromovablelist_to_vec(void *ptr,
                                                RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_lorotext(void *ptr,
                                       RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_lorotext(void *ptr, RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_constructor_lorotext_new(RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotext_apply_delta(
    void *ptr, RustBuffer delta, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotext_delete(void *ptr, uint32_t pos,
                                              uint32_t len,
                                              RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotext_delete_utf8(
    void *ptr, uint32_t pos, uint32_t len, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorotext_doc(void *ptr,
                                      RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorotext_get_attached(void *ptr,
                                               RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorotext_get_cursor(
    void *ptr, uint32_t pos, RustBuffer side, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorotext_get_editor_at_unicode_pos(
    void *ptr, uint32_t pos, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorotext_get_richtext_value(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorotext_id(void *ptr,
                                                RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotext_insert(void *ptr, uint32_t pos,
                                              RustBuffer s,
                                              RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotext_insert_utf8(
    void *ptr, uint32_t pos, RustBuffer s, RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_lorotext_is_attached(void *ptr,
                                              RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_lorotext_is_deleted(void *ptr,
                                             RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_lorotext_is_empty(void *ptr,
                                           RustCallStatus *uniffi_out_err);
uint32_t
uniffi_loro_rs_fn_method_lorotext_len_unicode(void *ptr,
                                              RustCallStatus *uniffi_out_err);
uint32_t
uniffi_loro_rs_fn_method_lorotext_len_utf16(void *ptr,
                                            RustCallStatus *uniffi_out_err);
uint32_t
uniffi_loro_rs_fn_method_lorotext_len_utf8(void *ptr,
                                           RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotext_mark(void *ptr, uint32_t from,
                                            uint32_t to, RustBuffer key,
                                            void *value,
                                            RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotext_push_str(void *ptr, RustBuffer s,
                                                RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorotext_slice(void *ptr, uint32_t start_index,
                                        uint32_t end_index,
                                        RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorotext_splice(void *ptr, uint32_t pos, uint32_t len,
                                         RustBuffer s,
                                         RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorotext_to_delta(void *ptr,
                                           RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorotext_to_string(void *ptr,
                                            RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotext_unmark(void *ptr, uint32_t from,
                                              uint32_t to, RustBuffer key,
                                              RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotext_update(void *ptr, RustBuffer s,
                                              RustBuffer options,
                                              RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotext_update_by_line(
    void *ptr, RustBuffer s, RustBuffer options,
    RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_lorotree(void *ptr,
                                       RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_lorotree(void *ptr, RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_constructor_lorotree_new(RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorotree_children(void *ptr, RustBuffer parent,
                                           RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorotree_children_num(void *ptr, RustBuffer parent,
                                               RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_lorotree_contains(void *ptr, RustBuffer target,
                                           RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorotree_create(void *ptr, RustBuffer parent,
                                         RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorotree_create_at(void *ptr, RustBuffer parent,
                                            uint32_t index,
                                            RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotree_delete(void *ptr, RustBuffer target,
                                              RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotree_disable_fractional_index(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorotree_doc(void *ptr,
                                      RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotree_enable_fractional_index(
    void *ptr, uint8_t jitter, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorotree_fractional_index(
    void *ptr, RustBuffer target, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorotree_get_attached(void *ptr,
                                               RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorotree_get_last_move_id(
    void *ptr, RustBuffer target, RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_method_lorotree_get_meta(void *ptr, RustBuffer target,
                                           RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorotree_get_value(void *ptr,
                                            RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorotree_get_value_with_meta(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_lorotree_id(void *ptr,
                                                RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_lorotree_is_attached(void *ptr,
                                              RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_lorotree_is_deleted(void *ptr,
                                             RustCallStatus *uniffi_out_err);
int8_t uniffi_loro_rs_fn_method_lorotree_is_fractional_index_enabled(
    void *ptr, RustCallStatus *uniffi_out_err);
int8_t uniffi_loro_rs_fn_method_lorotree_is_node_deleted(
    void *ptr, RustBuffer target, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotree_mov(void *ptr, RustBuffer target,
                                           RustBuffer parent,
                                           RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotree_mov_after(
    void *ptr, RustBuffer target, RustBuffer after,
    RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotree_mov_before(
    void *ptr, RustBuffer target, RustBuffer before,
    RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_lorotree_mov_to(void *ptr, RustBuffer target,
                                              RustBuffer parent, uint32_t to,
                                              RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorotree_nodes(void *ptr,
                                        RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorotree_parent(void *ptr, RustBuffer target,
                                         RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorotree_roots(void *ptr,
                                        RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_lorounknown(void *ptr,
                                          RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_lorounknown(void *ptr,
                                        RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_lorounknown_id(void *ptr,
                                        RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_lorovaluelike(void *ptr,
                                            RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_lorovaluelike(void *ptr,
                                          RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_init_callback_vtable_lorovaluelike(
    UniffiVTableCallbackInterfaceLoroValueLike *vtable);
RustBuffer uniffi_loro_rs_fn_method_lorovaluelike_as_loro_value(
    void *ptr, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_onpop(void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_onpop(void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_init_callback_vtable_onpop(
    UniffiVTableCallbackInterfaceOnPop *vtable);
void uniffi_loro_rs_fn_method_onpop_on_pop(void *ptr, RustBuffer undo_or_redo,
                                           RustBuffer span,
                                           RustBuffer undo_meta,
                                           RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_onpush(void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_onpush(void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_init_callback_vtable_onpush(
    UniffiVTableCallbackInterfaceOnPush *vtable);
RustBuffer
uniffi_loro_rs_fn_method_onpush_on_push(void *ptr, RustBuffer undo_or_redo,
                                        RustBuffer span, RustBuffer diff_event,
                                        RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_precommitcallback(void *ptr,
                                                RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_precommitcallback(void *ptr,
                                              RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_init_callback_vtable_precommitcallback(
    UniffiVTableCallbackInterfacePreCommitCallback *vtable);
void uniffi_loro_rs_fn_method_precommitcallback_on_pre_commit(
    void *ptr, RustBuffer payload, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_styleconfigmap(void *ptr,
                                             RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_styleconfigmap(void *ptr,
                                           RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_constructor_styleconfigmap_default_rich_text_config(
    RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_constructor_styleconfigmap_new(
    RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_styleconfigmap_get(void *ptr, RustBuffer key,
                                            RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_styleconfigmap_insert(
    void *ptr, RustBuffer key, RustBuffer value,
    RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_subscriber(void *ptr,
                                         RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_subscriber(void *ptr,
                                       RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_init_callback_vtable_subscriber(
    UniffiVTableCallbackInterfaceSubscriber *vtable);
void uniffi_loro_rs_fn_method_subscriber_on_diff(
    void *ptr, RustBuffer diff, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_subscription(void *ptr,
                                           RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_subscription(void *ptr,
                                         RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_subscription_detach(
    void *ptr, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_subscription_unsubscribe(
    void *ptr, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_undomanager(void *ptr,
                                          RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_undomanager(void *ptr,
                                        RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_constructor_undomanager_new(void *doc,
                                              RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_undomanager_add_exclude_origin_prefix(
    void *ptr, RustBuffer prefix, RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_undomanager_can_redo(void *ptr,
                                              RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_undomanager_can_undo(void *ptr,
                                              RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_undomanager_record_new_checkpoint(
    void *ptr, RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_undomanager_redo(void *ptr,
                                          RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_undomanager_set_max_undo_steps(
    void *ptr, uint32_t size, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_undomanager_set_merge_interval(
    void *ptr, int64_t interval, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_undomanager_set_on_pop(
    void *ptr, RustBuffer on_pop, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_undomanager_set_on_push(
    void *ptr, RustBuffer on_push, RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_undomanager_undo(void *ptr,
                                          RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_unsubscriber(void *ptr,
                                           RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_unsubscriber(void *ptr,
                                         RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_init_callback_vtable_unsubscriber(
    UniffiVTableCallbackInterfaceUnsubscriber *vtable);
void uniffi_loro_rs_fn_method_unsubscriber_on_unsubscribe(
    void *ptr, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_valueorcontainer(void *ptr,
                                               RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_valueorcontainer(void *ptr,
                                             RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_valueorcontainer_as_container(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_valueorcontainer_as_loro_counter(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_valueorcontainer_as_loro_list(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_valueorcontainer_as_loro_map(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_valueorcontainer_as_loro_movable_list(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_valueorcontainer_as_loro_text(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_valueorcontainer_as_loro_tree(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_valueorcontainer_as_loro_unknown(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_valueorcontainer_as_value(
    void *ptr, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_valueorcontainer_container_type(
    void *ptr, RustCallStatus *uniffi_out_err);
int8_t uniffi_loro_rs_fn_method_valueorcontainer_is_container(
    void *ptr, RustCallStatus *uniffi_out_err);
int8_t uniffi_loro_rs_fn_method_valueorcontainer_is_value(
    void *ptr, RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_clone_versionvector(void *ptr,
                                            RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_free_versionvector(void *ptr,
                                          RustCallStatus *uniffi_out_err);
void *uniffi_loro_rs_fn_constructor_versionvector_decode(
    RustBuffer bytes, RustCallStatus *uniffi_out_err);
void *
uniffi_loro_rs_fn_constructor_versionvector_new(RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_versionvector_diff(void *ptr, void *rhs,
                                            RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_versionvector_encode(void *ptr,
                                              RustCallStatus *uniffi_out_err);
int8_t
uniffi_loro_rs_fn_method_versionvector_eq(void *ptr, void *other,
                                          RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_versionvector_extend_to_include_vv(
    void *ptr, void *other, RustCallStatus *uniffi_out_err);
RustBuffer
uniffi_loro_rs_fn_method_versionvector_get_last(void *ptr, uint64_t peer,
                                                RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_versionvector_get_missing_span(
    void *ptr, void *target, RustCallStatus *uniffi_out_err);
int8_t uniffi_loro_rs_fn_method_versionvector_includes_id(
    void *ptr, RustBuffer id, RustCallStatus *uniffi_out_err);
int8_t uniffi_loro_rs_fn_method_versionvector_includes_vv(
    void *ptr, void *other, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_versionvector_intersect_span(
    void *ptr, RustBuffer target, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_versionvector_merge(
    void *ptr, void *other, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_method_versionvector_partial_cmp(
    void *ptr, void *other, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_versionvector_set_end(
    void *ptr, RustBuffer id, RustCallStatus *uniffi_out_err);
void uniffi_loro_rs_fn_method_versionvector_set_last(
    void *ptr, RustBuffer id, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_func_decode_import_blob_meta(
    RustBuffer bytes, int8_t check_checksum, RustCallStatus *uniffi_out_err);
RustBuffer uniffi_loro_rs_fn_func_get_version(RustCallStatus *uniffi_out_err);
RustBuffer ffi_loro_rs_rustbuffer_alloc(uint64_t size,
                                        RustCallStatus *uniffi_out_err);
RustBuffer ffi_loro_rs_rustbuffer_from_bytes(ForeignBytes bytes,
                                             RustCallStatus *uniffi_out_err);
void ffi_loro_rs_rustbuffer_free(RustBuffer buf,
                                 RustCallStatus *uniffi_out_err);
RustBuffer ffi_loro_rs_rustbuffer_reserve(RustBuffer buf, uint64_t additional,
                                          RustCallStatus *uniffi_out_err);
void ffi_loro_rs_rust_future_poll_u8(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_loro_rs_rust_future_cancel_u8(
    /*handle*/ uint64_t handle);
void ffi_loro_rs_rust_future_free_u8(
    /*handle*/ uint64_t handle);
uint8_t ffi_loro_rs_rust_future_complete_u8(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_loro_rs_rust_future_poll_i8(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_loro_rs_rust_future_cancel_i8(
    /*handle*/ uint64_t handle);
void ffi_loro_rs_rust_future_free_i8(
    /*handle*/ uint64_t handle);
int8_t ffi_loro_rs_rust_future_complete_i8(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_loro_rs_rust_future_poll_u16(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_loro_rs_rust_future_cancel_u16(
    /*handle*/ uint64_t handle);
void ffi_loro_rs_rust_future_free_u16(
    /*handle*/ uint64_t handle);
uint16_t ffi_loro_rs_rust_future_complete_u16(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_loro_rs_rust_future_poll_i16(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_loro_rs_rust_future_cancel_i16(
    /*handle*/ uint64_t handle);
void ffi_loro_rs_rust_future_free_i16(
    /*handle*/ uint64_t handle);
int16_t ffi_loro_rs_rust_future_complete_i16(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_loro_rs_rust_future_poll_u32(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_loro_rs_rust_future_cancel_u32(
    /*handle*/ uint64_t handle);
void ffi_loro_rs_rust_future_free_u32(
    /*handle*/ uint64_t handle);
uint32_t ffi_loro_rs_rust_future_complete_u32(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_loro_rs_rust_future_poll_i32(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_loro_rs_rust_future_cancel_i32(
    /*handle*/ uint64_t handle);
void ffi_loro_rs_rust_future_free_i32(
    /*handle*/ uint64_t handle);
int32_t ffi_loro_rs_rust_future_complete_i32(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_loro_rs_rust_future_poll_u64(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_loro_rs_rust_future_cancel_u64(
    /*handle*/ uint64_t handle);
void ffi_loro_rs_rust_future_free_u64(
    /*handle*/ uint64_t handle);
uint64_t ffi_loro_rs_rust_future_complete_u64(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_loro_rs_rust_future_poll_i64(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_loro_rs_rust_future_cancel_i64(
    /*handle*/ uint64_t handle);
void ffi_loro_rs_rust_future_free_i64(
    /*handle*/ uint64_t handle);
int64_t ffi_loro_rs_rust_future_complete_i64(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_loro_rs_rust_future_poll_f32(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_loro_rs_rust_future_cancel_f32(
    /*handle*/ uint64_t handle);
void ffi_loro_rs_rust_future_free_f32(
    /*handle*/ uint64_t handle);
float ffi_loro_rs_rust_future_complete_f32(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_loro_rs_rust_future_poll_f64(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_loro_rs_rust_future_cancel_f64(
    /*handle*/ uint64_t handle);
void ffi_loro_rs_rust_future_free_f64(
    /*handle*/ uint64_t handle);
double ffi_loro_rs_rust_future_complete_f64(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_loro_rs_rust_future_poll_pointer(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_loro_rs_rust_future_cancel_pointer(
    /*handle*/ uint64_t handle);
void ffi_loro_rs_rust_future_free_pointer(
    /*handle*/ uint64_t handle);
void *ffi_loro_rs_rust_future_complete_pointer(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_loro_rs_rust_future_poll_rust_buffer(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_loro_rs_rust_future_cancel_rust_buffer(
    /*handle*/ uint64_t handle);
void ffi_loro_rs_rust_future_free_rust_buffer(
    /*handle*/ uint64_t handle);
RustBuffer ffi_loro_rs_rust_future_complete_rust_buffer(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
void ffi_loro_rs_rust_future_poll_void(
    /*handle*/ uint64_t handle, UniffiRustFutureContinuationCallback callback,
    /*handle*/ uint64_t callback_data);
void ffi_loro_rs_rust_future_cancel_void(
    /*handle*/ uint64_t handle);
void ffi_loro_rs_rust_future_free_void(
    /*handle*/ uint64_t handle);
void ffi_loro_rs_rust_future_complete_void(
    /*handle*/ uint64_t handle, RustCallStatus *uniffi_out_err);
uint16_t uniffi_loro_rs_checksum_func_decode_import_blob_meta();
uint16_t uniffi_loro_rs_checksum_func_get_version();
uint16_t uniffi_loro_rs_checksum_method_awareness_apply();
uint16_t uniffi_loro_rs_checksum_method_awareness_encode();
uint16_t uniffi_loro_rs_checksum_method_awareness_encode_all();
uint16_t uniffi_loro_rs_checksum_method_awareness_get_all_states();
uint16_t uniffi_loro_rs_checksum_method_awareness_get_local_state();
uint16_t uniffi_loro_rs_checksum_method_awareness_peer();
uint16_t uniffi_loro_rs_checksum_method_awareness_remove_outdated();
uint16_t uniffi_loro_rs_checksum_method_awareness_set_local_state();
uint16_t uniffi_loro_rs_checksum_method_changeancestorstraveler_travel();
uint16_t uniffi_loro_rs_checksum_method_changemodifier_set_message();
uint16_t uniffi_loro_rs_checksum_method_changemodifier_set_timestamp();
uint16_t uniffi_loro_rs_checksum_method_configure_fork();
uint16_t uniffi_loro_rs_checksum_method_configure_merge_interval();
uint16_t uniffi_loro_rs_checksum_method_configure_record_timestamp();
uint16_t uniffi_loro_rs_checksum_method_configure_set_merge_interval();
uint16_t uniffi_loro_rs_checksum_method_configure_set_record_timestamp();
uint16_t uniffi_loro_rs_checksum_method_configure_text_style_config();
uint16_t uniffi_loro_rs_checksum_method_containeridlike_as_container_id();
uint16_t uniffi_loro_rs_checksum_method_diffbatch_get_diff();
uint16_t uniffi_loro_rs_checksum_method_diffbatch_push();
uint16_t uniffi_loro_rs_checksum_method_ephemeralstore_apply();
uint16_t uniffi_loro_rs_checksum_method_ephemeralstore_delete();
uint16_t uniffi_loro_rs_checksum_method_ephemeralstore_encode();
uint16_t uniffi_loro_rs_checksum_method_ephemeralstore_encode_all();
uint16_t uniffi_loro_rs_checksum_method_ephemeralstore_get();
uint16_t uniffi_loro_rs_checksum_method_ephemeralstore_get_all_states();
uint16_t uniffi_loro_rs_checksum_method_ephemeralstore_keys();
uint16_t uniffi_loro_rs_checksum_method_ephemeralstore_remove_outdated();
uint16_t uniffi_loro_rs_checksum_method_ephemeralstore_set();
uint16_t uniffi_loro_rs_checksum_method_ephemeralstore_subscribe();
uint16_t uniffi_loro_rs_checksum_method_ephemeralstore_subscribe_local_update();
uint16_t
uniffi_loro_rs_checksum_method_ephemeralsubscriber_on_ephemeral_event();
uint16_t
uniffi_loro_rs_checksum_method_firstcommitfrompeercallback_on_first_commit_from_peer();
uint16_t uniffi_loro_rs_checksum_method_fractionalindex_to_string();
uint16_t uniffi_loro_rs_checksum_method_frontiers_encode();
uint16_t uniffi_loro_rs_checksum_method_frontiers_eq();
uint16_t
uniffi_loro_rs_checksum_method_localephemerallistener_on_ephemeral_update();
uint16_t uniffi_loro_rs_checksum_method_localupdatecallback_on_local_update();
uint16_t uniffi_loro_rs_checksum_method_lorocounter_decrement();
uint16_t uniffi_loro_rs_checksum_method_lorocounter_doc();
uint16_t uniffi_loro_rs_checksum_method_lorocounter_get_attached();
uint16_t uniffi_loro_rs_checksum_method_lorocounter_get_value();
uint16_t uniffi_loro_rs_checksum_method_lorocounter_id();
uint16_t uniffi_loro_rs_checksum_method_lorocounter_increment();
uint16_t uniffi_loro_rs_checksum_method_lorocounter_is_attached();
uint16_t uniffi_loro_rs_checksum_method_lorocounter_is_deleted();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_apply_diff();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_attach();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_check_state_correctness_slow();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_checkout();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_checkout_to_latest();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_clear_next_commit_options();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_cmp_with_frontiers();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_commit();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_commit_with();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_compact_change_store();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_config();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_config_default_text_style();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_config_text_style();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_detach();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_diff();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_export_json_in_id_span();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_export_json_updates();
uint16_t
uniffi_loro_rs_checksum_method_lorodoc_export_json_updates_without_peer_compression();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_export_shallow_snapshot();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_export_snapshot();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_export_snapshot_at();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_export_state_only();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_export_updates();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_export_updates_in_range();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_find_id_spans_between();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_fork();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_fork_at();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_free_diff_calculator();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_free_history_cache();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_frontiers_to_vv();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_get_by_path();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_get_by_str_path();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_get_change();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_get_changed_containers_in();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_get_counter();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_get_cursor_pos();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_get_deep_value();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_get_deep_value_with_id();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_get_list();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_get_map();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_get_movable_list();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_get_path_to_container();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_get_pending_txn_len();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_get_text();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_get_tree();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_get_value();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_has_container();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_has_history_cache();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_import();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_import_batch();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_import_json_updates();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_import_with();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_is_detached();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_is_shallow();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_jsonpath();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_len_changes();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_len_ops();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_log_estimate_size();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_minimize_frontiers();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_oplog_frontiers();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_oplog_vv();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_peer_id();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_revert_to();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_set_change_merge_interval();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_message();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_options();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_origin();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_timestamp();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_set_peer_id();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_set_record_timestamp();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_shallow_since_vv();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_state_frontiers();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_state_vv();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_subscribe();
uint16_t
uniffi_loro_rs_checksum_method_lorodoc_subscribe_first_commit_from_peer();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_subscribe_local_update();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_subscribe_pre_commit();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_subscribe_root();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_travel_change_ancestors();
uint16_t uniffi_loro_rs_checksum_method_lorodoc_vv_to_frontiers();
uint16_t uniffi_loro_rs_checksum_method_lorolist_clear();
uint16_t uniffi_loro_rs_checksum_method_lorolist_delete();
uint16_t uniffi_loro_rs_checksum_method_lorolist_doc();
uint16_t uniffi_loro_rs_checksum_method_lorolist_get();
uint16_t uniffi_loro_rs_checksum_method_lorolist_get_attached();
uint16_t uniffi_loro_rs_checksum_method_lorolist_get_cursor();
uint16_t uniffi_loro_rs_checksum_method_lorolist_get_deep_value();
uint16_t uniffi_loro_rs_checksum_method_lorolist_get_id_at();
uint16_t uniffi_loro_rs_checksum_method_lorolist_get_value();
uint16_t uniffi_loro_rs_checksum_method_lorolist_id();
uint16_t uniffi_loro_rs_checksum_method_lorolist_insert();
uint16_t uniffi_loro_rs_checksum_method_lorolist_insert_counter_container();
uint16_t uniffi_loro_rs_checksum_method_lorolist_insert_list_container();
uint16_t uniffi_loro_rs_checksum_method_lorolist_insert_map_container();
uint16_t
uniffi_loro_rs_checksum_method_lorolist_insert_movable_list_container();
uint16_t uniffi_loro_rs_checksum_method_lorolist_insert_text_container();
uint16_t uniffi_loro_rs_checksum_method_lorolist_insert_tree_container();
uint16_t uniffi_loro_rs_checksum_method_lorolist_is_attached();
uint16_t uniffi_loro_rs_checksum_method_lorolist_is_deleted();
uint16_t uniffi_loro_rs_checksum_method_lorolist_is_empty();
uint16_t uniffi_loro_rs_checksum_method_lorolist_len();
uint16_t uniffi_loro_rs_checksum_method_lorolist_pop();
uint16_t uniffi_loro_rs_checksum_method_lorolist_push();
uint16_t uniffi_loro_rs_checksum_method_lorolist_to_vec();
uint16_t uniffi_loro_rs_checksum_method_loromap_clear();
uint16_t uniffi_loro_rs_checksum_method_loromap_delete();
uint16_t uniffi_loro_rs_checksum_method_loromap_doc();
uint16_t uniffi_loro_rs_checksum_method_loromap_get();
uint16_t uniffi_loro_rs_checksum_method_loromap_get_attached();
uint16_t uniffi_loro_rs_checksum_method_loromap_get_deep_value();
uint16_t uniffi_loro_rs_checksum_method_loromap_get_last_editor();
uint16_t
uniffi_loro_rs_checksum_method_loromap_get_or_create_counter_container();
uint16_t uniffi_loro_rs_checksum_method_loromap_get_or_create_list_container();
uint16_t uniffi_loro_rs_checksum_method_loromap_get_or_create_map_container();
uint16_t
uniffi_loro_rs_checksum_method_loromap_get_or_create_movable_list_container();
uint16_t uniffi_loro_rs_checksum_method_loromap_get_or_create_text_container();
uint16_t uniffi_loro_rs_checksum_method_loromap_get_or_create_tree_container();
uint16_t uniffi_loro_rs_checksum_method_loromap_get_value();
uint16_t uniffi_loro_rs_checksum_method_loromap_id();
uint16_t uniffi_loro_rs_checksum_method_loromap_insert();
uint16_t uniffi_loro_rs_checksum_method_loromap_insert_counter_container();
uint16_t uniffi_loro_rs_checksum_method_loromap_insert_list_container();
uint16_t uniffi_loro_rs_checksum_method_loromap_insert_map_container();
uint16_t uniffi_loro_rs_checksum_method_loromap_insert_movable_list_container();
uint16_t uniffi_loro_rs_checksum_method_loromap_insert_text_container();
uint16_t uniffi_loro_rs_checksum_method_loromap_insert_tree_container();
uint16_t uniffi_loro_rs_checksum_method_loromap_is_attached();
uint16_t uniffi_loro_rs_checksum_method_loromap_is_deleted();
uint16_t uniffi_loro_rs_checksum_method_loromap_is_empty();
uint16_t uniffi_loro_rs_checksum_method_loromap_keys();
uint16_t uniffi_loro_rs_checksum_method_loromap_len();
uint16_t uniffi_loro_rs_checksum_method_loromap_values();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_clear();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_delete();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_doc();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_get();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_get_attached();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_get_creator_at();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_get_cursor();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_get_deep_value();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_get_last_editor_at();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_get_last_mover_at();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_get_value();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_id();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_insert();
uint16_t
uniffi_loro_rs_checksum_method_loromovablelist_insert_counter_container();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_insert_list_container();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_insert_map_container();
uint16_t
uniffi_loro_rs_checksum_method_loromovablelist_insert_movable_list_container();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_insert_text_container();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_insert_tree_container();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_is_attached();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_is_deleted();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_is_empty();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_len();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_mov();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_pop();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_push();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_set();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_set_counter_container();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_set_list_container();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_set_map_container();
uint16_t
uniffi_loro_rs_checksum_method_loromovablelist_set_movable_list_container();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_set_text_container();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_set_tree_container();
uint16_t uniffi_loro_rs_checksum_method_loromovablelist_to_vec();
uint16_t uniffi_loro_rs_checksum_method_lorotext_apply_delta();
uint16_t uniffi_loro_rs_checksum_method_lorotext_delete();
uint16_t uniffi_loro_rs_checksum_method_lorotext_delete_utf8();
uint16_t uniffi_loro_rs_checksum_method_lorotext_doc();
uint16_t uniffi_loro_rs_checksum_method_lorotext_get_attached();
uint16_t uniffi_loro_rs_checksum_method_lorotext_get_cursor();
uint16_t uniffi_loro_rs_checksum_method_lorotext_get_editor_at_unicode_pos();
uint16_t uniffi_loro_rs_checksum_method_lorotext_get_richtext_value();
uint16_t uniffi_loro_rs_checksum_method_lorotext_id();
uint16_t uniffi_loro_rs_checksum_method_lorotext_insert();
uint16_t uniffi_loro_rs_checksum_method_lorotext_insert_utf8();
uint16_t uniffi_loro_rs_checksum_method_lorotext_is_attached();
uint16_t uniffi_loro_rs_checksum_method_lorotext_is_deleted();
uint16_t uniffi_loro_rs_checksum_method_lorotext_is_empty();
uint16_t uniffi_loro_rs_checksum_method_lorotext_len_unicode();
uint16_t uniffi_loro_rs_checksum_method_lorotext_len_utf16();
uint16_t uniffi_loro_rs_checksum_method_lorotext_len_utf8();
uint16_t uniffi_loro_rs_checksum_method_lorotext_mark();
uint16_t uniffi_loro_rs_checksum_method_lorotext_push_str();
uint16_t uniffi_loro_rs_checksum_method_lorotext_slice();
uint16_t uniffi_loro_rs_checksum_method_lorotext_splice();
uint16_t uniffi_loro_rs_checksum_method_lorotext_to_delta();
uint16_t uniffi_loro_rs_checksum_method_lorotext_to_string();
uint16_t uniffi_loro_rs_checksum_method_lorotext_unmark();
uint16_t uniffi_loro_rs_checksum_method_lorotext_update();
uint16_t uniffi_loro_rs_checksum_method_lorotext_update_by_line();
uint16_t uniffi_loro_rs_checksum_method_lorotree_children();
uint16_t uniffi_loro_rs_checksum_method_lorotree_children_num();
uint16_t uniffi_loro_rs_checksum_method_lorotree_contains();
uint16_t uniffi_loro_rs_checksum_method_lorotree_create();
uint16_t uniffi_loro_rs_checksum_method_lorotree_create_at();
uint16_t uniffi_loro_rs_checksum_method_lorotree_delete();
uint16_t uniffi_loro_rs_checksum_method_lorotree_disable_fractional_index();
uint16_t uniffi_loro_rs_checksum_method_lorotree_doc();
uint16_t uniffi_loro_rs_checksum_method_lorotree_enable_fractional_index();
uint16_t uniffi_loro_rs_checksum_method_lorotree_fractional_index();
uint16_t uniffi_loro_rs_checksum_method_lorotree_get_attached();
uint16_t uniffi_loro_rs_checksum_method_lorotree_get_last_move_id();
uint16_t uniffi_loro_rs_checksum_method_lorotree_get_meta();
uint16_t uniffi_loro_rs_checksum_method_lorotree_get_value();
uint16_t uniffi_loro_rs_checksum_method_lorotree_get_value_with_meta();
uint16_t uniffi_loro_rs_checksum_method_lorotree_id();
uint16_t uniffi_loro_rs_checksum_method_lorotree_is_attached();
uint16_t uniffi_loro_rs_checksum_method_lorotree_is_deleted();
uint16_t uniffi_loro_rs_checksum_method_lorotree_is_fractional_index_enabled();
uint16_t uniffi_loro_rs_checksum_method_lorotree_is_node_deleted();
uint16_t uniffi_loro_rs_checksum_method_lorotree_mov();
uint16_t uniffi_loro_rs_checksum_method_lorotree_mov_after();
uint16_t uniffi_loro_rs_checksum_method_lorotree_mov_before();
uint16_t uniffi_loro_rs_checksum_method_lorotree_mov_to();
uint16_t uniffi_loro_rs_checksum_method_lorotree_nodes();
uint16_t uniffi_loro_rs_checksum_method_lorotree_parent();
uint16_t uniffi_loro_rs_checksum_method_lorotree_roots();
uint16_t uniffi_loro_rs_checksum_method_lorounknown_id();
uint16_t uniffi_loro_rs_checksum_method_lorovaluelike_as_loro_value();
uint16_t uniffi_loro_rs_checksum_method_onpop_on_pop();
uint16_t uniffi_loro_rs_checksum_method_onpush_on_push();
uint16_t uniffi_loro_rs_checksum_method_precommitcallback_on_pre_commit();
uint16_t uniffi_loro_rs_checksum_method_styleconfigmap_get();
uint16_t uniffi_loro_rs_checksum_method_styleconfigmap_insert();
uint16_t uniffi_loro_rs_checksum_method_subscriber_on_diff();
uint16_t uniffi_loro_rs_checksum_method_subscription_detach();
uint16_t uniffi_loro_rs_checksum_method_subscription_unsubscribe();
uint16_t uniffi_loro_rs_checksum_method_undomanager_add_exclude_origin_prefix();
uint16_t uniffi_loro_rs_checksum_method_undomanager_can_redo();
uint16_t uniffi_loro_rs_checksum_method_undomanager_can_undo();
uint16_t uniffi_loro_rs_checksum_method_undomanager_record_new_checkpoint();
uint16_t uniffi_loro_rs_checksum_method_undomanager_redo();
uint16_t uniffi_loro_rs_checksum_method_undomanager_set_max_undo_steps();
uint16_t uniffi_loro_rs_checksum_method_undomanager_set_merge_interval();
uint16_t uniffi_loro_rs_checksum_method_undomanager_set_on_pop();
uint16_t uniffi_loro_rs_checksum_method_undomanager_set_on_push();
uint16_t uniffi_loro_rs_checksum_method_undomanager_undo();
uint16_t uniffi_loro_rs_checksum_method_unsubscriber_on_unsubscribe();
uint16_t uniffi_loro_rs_checksum_method_valueorcontainer_as_container();
uint16_t uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_counter();
uint16_t uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_list();
uint16_t uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_map();
uint16_t uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_movable_list();
uint16_t uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_text();
uint16_t uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_tree();
uint16_t uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_unknown();
uint16_t uniffi_loro_rs_checksum_method_valueorcontainer_as_value();
uint16_t uniffi_loro_rs_checksum_method_valueorcontainer_container_type();
uint16_t uniffi_loro_rs_checksum_method_valueorcontainer_is_container();
uint16_t uniffi_loro_rs_checksum_method_valueorcontainer_is_value();
uint16_t uniffi_loro_rs_checksum_method_versionvector_diff();
uint16_t uniffi_loro_rs_checksum_method_versionvector_encode();
uint16_t uniffi_loro_rs_checksum_method_versionvector_eq();
uint16_t uniffi_loro_rs_checksum_method_versionvector_extend_to_include_vv();
uint16_t uniffi_loro_rs_checksum_method_versionvector_get_last();
uint16_t uniffi_loro_rs_checksum_method_versionvector_get_missing_span();
uint16_t uniffi_loro_rs_checksum_method_versionvector_includes_id();
uint16_t uniffi_loro_rs_checksum_method_versionvector_includes_vv();
uint16_t uniffi_loro_rs_checksum_method_versionvector_intersect_span();
uint16_t uniffi_loro_rs_checksum_method_versionvector_merge();
uint16_t uniffi_loro_rs_checksum_method_versionvector_partial_cmp();
uint16_t uniffi_loro_rs_checksum_method_versionvector_set_end();
uint16_t uniffi_loro_rs_checksum_method_versionvector_set_last();
uint16_t uniffi_loro_rs_checksum_constructor_awareness_new();
uint16_t uniffi_loro_rs_checksum_constructor_cursor_new();
uint16_t uniffi_loro_rs_checksum_constructor_diffbatch_new();
uint16_t uniffi_loro_rs_checksum_constructor_ephemeralstore_new();
uint16_t uniffi_loro_rs_checksum_constructor_fractionalindex_from_bytes();
uint16_t uniffi_loro_rs_checksum_constructor_fractionalindex_from_hex_string();
uint16_t uniffi_loro_rs_checksum_constructor_frontiers_decode();
uint16_t uniffi_loro_rs_checksum_constructor_frontiers_from_id();
uint16_t uniffi_loro_rs_checksum_constructor_frontiers_from_ids();
uint16_t uniffi_loro_rs_checksum_constructor_frontiers_new();
uint16_t uniffi_loro_rs_checksum_constructor_lorocounter_new();
uint16_t uniffi_loro_rs_checksum_constructor_lorodoc_new();
uint16_t uniffi_loro_rs_checksum_constructor_lorolist_new();
uint16_t uniffi_loro_rs_checksum_constructor_loromap_new();
uint16_t uniffi_loro_rs_checksum_constructor_loromovablelist_new();
uint16_t uniffi_loro_rs_checksum_constructor_lorotext_new();
uint16_t uniffi_loro_rs_checksum_constructor_lorotree_new();
uint16_t
uniffi_loro_rs_checksum_constructor_styleconfigmap_default_rich_text_config();
uint16_t uniffi_loro_rs_checksum_constructor_styleconfigmap_new();
uint16_t uniffi_loro_rs_checksum_constructor_undomanager_new();
uint16_t uniffi_loro_rs_checksum_constructor_versionvector_decode();
uint16_t uniffi_loro_rs_checksum_constructor_versionvector_new();
uint32_t ffi_loro_rs_uniffi_contract_version();
}

namespace uniffi::loro {
template <typename T> struct Bridging;

using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <typename T> struct Bridging<ReferenceHolder<T>> {
  static jsi::Value jsNew(jsi::Runtime &rt) {
    auto holder = jsi::Object(rt);
    return holder;
  }
  static T fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
                  const jsi::Value &value) {
    auto obj = value.asObject(rt);
    if (obj.hasProperty(rt, "pointee")) {
      auto pointee = obj.getProperty(rt, "pointee");
      return uniffi::loro::Bridging<T>::fromJs(rt, callInvoker, pointee);
    }
    throw jsi::JSError(rt,
                       "Expected ReferenceHolder to have a pointee property. "
                       "This is likely a bug in uniffi-bindgen-react-native");
  }
};
} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<RustBuffer> {
  static RustBuffer rustbuffer_alloc(int32_t size) {
    RustCallStatus status = {UNIFFI_CALL_STATUS_OK};
    return ffi_loro_rs_rustbuffer_alloc(size, &status);
  }

  static void rustbuffer_free(RustBuffer buf) {
    RustCallStatus status = {UNIFFI_CALL_STATUS_OK};
    ffi_loro_rs_rustbuffer_free(buf, &status);
  }

  static RustBuffer rustbuffer_from_bytes(ForeignBytes bytes) {
    RustCallStatus status = {UNIFFI_CALL_STATUS_OK};
    return ffi_loro_rs_rustbuffer_from_bytes(bytes, &status);
  }

  static RustBuffer fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker>,
                           const jsi::Value &value) {
    try {
      auto buffer =
          uniffi_jsi::Bridging<jsi::ArrayBuffer>::value_to_arraybuffer(rt,
                                                                       value);
      auto bytes = ForeignBytes{
          .len = static_cast<int32_t>(buffer.length(rt)),
          .data = buffer.data(rt),
      };

      // This buffer is constructed from foreign bytes. Rust scaffolding copies
      // the bytes, to make the RustBuffer.
      auto buf = rustbuffer_from_bytes(bytes);
      // Once it leaves this function, the buffer is immediately passed back
      // into Rust, where it's used to deserialize into the Rust versions of the
      // arguments. At that point, the copy is destroyed.
      return buf;
    } catch (const std::logic_error &e) {
      throw jsi::JSError(rt, e.what());
    }
  }

  static jsi::Value toJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker>,
                         RustBuffer buf) {
    // We need to make a copy of the bytes from Rust's memory space into
    // Javascripts memory space. We need to do this because the two languages
    // manages memory very differently: a garbage collector needs to track all
    // the memory at runtime, Rust is doing it all closer to compile time.
    uint8_t *bytes = new uint8_t[buf.len];
    std::memcpy(bytes, buf.data, buf.len);

    // Construct an ArrayBuffer with copy of the bytes from the RustBuffer.
    auto payload = std::make_shared<uniffi_jsi::CMutableBuffer>(
        uniffi_jsi::CMutableBuffer((uint8_t *)bytes, buf.len));
    auto arrayBuffer = jsi::ArrayBuffer(rt, payload);

    // Once we have a Javascript version, we no longer need the Rust version, so
    // we can call into Rust to tell it it's okay to free that memory.
    rustbuffer_free(buf);

    // Finally, return the ArrayBuffer.
    return uniffi_jsi::Bridging<jsi::ArrayBuffer>::arraybuffer_to_value(
        rt, arrayBuffer);
    ;
  }
};

} // namespace uniffi::loro

namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<RustCallStatus> {
  static jsi::Value jsSuccess(jsi::Runtime &rt) {
    auto statusObject = jsi::Object(rt);
    statusObject.setProperty(rt, "code", jsi::Value(rt, UNIFFI_CALL_STATUS_OK));
    return statusObject;
  }
  static RustCallStatus rustSuccess(jsi::Runtime &rt) {
    return {UNIFFI_CALL_STATUS_OK};
  }
  static void copyIntoJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         const RustCallStatus status,
                         const jsi::Value &jsStatus) {
    auto statusObject = jsStatus.asObject(rt);
    if (status.error_buf.data != nullptr) {
      auto rbuf = Bridging<RustBuffer>::toJs(rt, callInvoker, status.error_buf);
      statusObject.setProperty(rt, "errorBuf", rbuf);
    }
    if (status.code != UNIFFI_CALL_STATUS_OK) {
      auto code =
          uniffi_jsi::Bridging<uint8_t>::toJs(rt, callInvoker, status.code);
      statusObject.setProperty(rt, "code", code);
    }
  }

  static RustCallStatus fromJs(jsi::Runtime &rt,
                               std::shared_ptr<CallInvoker> invoker,
                               const jsi::Value &jsStatus) {
    RustCallStatus status;
    auto statusObject = jsStatus.asObject(rt);
    if (statusObject.hasProperty(rt, "errorBuf")) {
      auto rbuf = statusObject.getProperty(rt, "errorBuf");
      status.error_buf = Bridging<RustBuffer>::fromJs(rt, invoker, rbuf);
    }
    if (statusObject.hasProperty(rt, "code")) {
      auto code = statusObject.getProperty(rt, "code");
      status.code = uniffi_jsi::Bridging<uint8_t>::fromJs(rt, invoker, code);
    }
    return status;
  }

  static void copyFromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> invoker,
                         const jsi::Value &jsStatus, RustCallStatus *status) {
    auto statusObject = jsStatus.asObject(rt);
    if (statusObject.hasProperty(rt, "errorBuf")) {
      auto rbuf = statusObject.getProperty(rt, "errorBuf");
      status->error_buf = Bridging<RustBuffer>::fromJs(rt, invoker, rbuf);
    }
    if (statusObject.hasProperty(rt, "code")) {
      auto code = statusObject.getProperty(rt, "code");
      status->code = uniffi_jsi::Bridging<uint8_t>::fromJs(rt, invoker, code);
    }
  }
};

} // namespace uniffi::loro
// In other uniffi bindings, it is assumed that the foreign language holds on
// to the vtable, which the Rust just gets a pointer to.
// Here, we need to hold on to them, but also be able to clear them at just the
// right time so we can support hot-reloading.
namespace uniffi::loro::registry {
template <typename T> class VTableHolder {
public:
  T vtable;
  VTableHolder(T v) : vtable(v) {}
};

// Mutex to bind the storage and setting of vtable together.
// We declare it here, but the lock is taken by callers of the putTable
// method who are also sending a pointer to Rust.
static std::mutex vtableMutex;

// Registry to hold all vtables so they persist even when JS objects are GC'd.
// The only reason this exists is to prevent a dangling pointer in the
// Rust machinery: i.e. we don't need to access or write to this registry
// after startup.
// Registry to hold all vtables so they persist even when JS objects are GC'd.
// Maps string identifiers to vtable holders using type erasure
static std::unordered_map<std::string, std::shared_ptr<void>> vtableRegistry;

// Add a vtable to the registry with an identifier
template <typename T>
static T *putTable(std::string_view identifier, T vtable) {
  auto holder = std::make_shared<VTableHolder<T>>(vtable);
  // Store the raw pointer to the vtable before type erasure
  T *rawPtr = &(holder->vtable);
  // Store the holder using type erasure with the string identifier
  vtableRegistry[std::string(identifier)] = std::shared_ptr<void>(holder);
  return rawPtr;
}

// Clear the registry.
//
// Conceptually, this is called after teardown of the module (i.e. after
// teardown of the jsi::Runtime). However, because Rust is dropping callbacks
// because the Runtime is being torn down, we must keep the registry intact
// until after the runtime goes away.
//
// Therefore, in practice we should call this when the next runtime is
// being stood up.
static void clearRegistry() {
  std::lock_guard<std::mutex> lock(vtableMutex);
  vtableRegistry.clear();
}
} // namespace uniffi::loro::registry

// This calls into Rust.
// Implementation of callback function calling from Rust to JS
// RustFutureContinuationCallback

// Callback function:
// uniffi::loro::cb::rustfuturecontinuationcallback::UniffiRustFutureContinuationCallback
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::rustfuturecontinuationcallback {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, int8_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue, uint64_t rs_data,
                 int8_t rs_pollResult) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_data = uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_data);
  auto js_pollResult =
      uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, rs_pollResult);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_data, js_pollResult);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiRustFutureContinuationCallback: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_data, int8_t rs_pollResult) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_data, rs_pollResult);
}

static UniffiRustFutureContinuationCallback
makeCallbackFunction( // uniffi::loro::cb::rustfuturecontinuationcallback
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_data,
                                               int8_t rs_pollResult) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_data,
         rs_pollResult](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_data, rs_pollResult);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::rustfuturecontinuationcallback
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureFree, passed from Rust to JS as part of async callbacks.
namespace uniffi::loro {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureFree> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureFree rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureFree"), 1,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureFree func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::loro
  // Implementation of free callback function CallbackInterfaceFree

// Callback function:
// uniffi::loro::st::foreignfuture::foreignfuture::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::st::foreignfuture::foreignfuture::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::loro::st::foreignfuture::foreignfuture::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::st::foreignfuture::foreignfuture::free

// Callback function:
// uniffi::loro::st::vtablecallbackinterfacechangeancestorstraveler::vtablecallbackinterfacechangeancestorstraveler::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::st::vtablecallbackinterfacechangeancestorstraveler::
    vtablecallbackinterfacechangeancestorstraveler::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::loro::st::vtablecallbackinterfacechangeancestorstraveler::vtablecallbackinterfacechangeancestorstraveler::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::loro::st::vtablecallbackinterfacechangeancestorstraveler::vtablecallbackinterfacechangeancestorstraveler::free

// Callback function:
// uniffi::loro::st::vtablecallbackinterfacecontaineridlike::vtablecallbackinterfacecontaineridlike::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::st::vtablecallbackinterfacecontaineridlike::
    vtablecallbackinterfacecontaineridlike::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::loro::st::vtablecallbackinterfacecontaineridlike::vtablecallbackinterfacecontaineridlike::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::loro::st::vtablecallbackinterfacecontaineridlike::vtablecallbackinterfacecontaineridlike::free

// Callback function:
// uniffi::loro::st::vtablecallbackinterfaceephemeralsubscriber::vtablecallbackinterfaceephemeralsubscriber::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::st::vtablecallbackinterfaceephemeralsubscriber::
    vtablecallbackinterfaceephemeralsubscriber::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::loro::st::vtablecallbackinterfaceephemeralsubscriber::vtablecallbackinterfaceephemeralsubscriber::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::loro::st::vtablecallbackinterfaceephemeralsubscriber::vtablecallbackinterfaceephemeralsubscriber::free

// Callback function:
// uniffi::loro::st::vtablecallbackinterfacefirstcommitfrompeercallback::vtablecallbackinterfacefirstcommitfrompeercallback::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::st::vtablecallbackinterfacefirstcommitfrompeercallback::
    vtablecallbackinterfacefirstcommitfrompeercallback::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::loro::st::vtablecallbackinterfacefirstcommitfrompeercallback::vtablecallbackinterfacefirstcommitfrompeercallback::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::loro::st::vtablecallbackinterfacefirstcommitfrompeercallback::vtablecallbackinterfacefirstcommitfrompeercallback::free

// Callback function:
// uniffi::loro::st::vtablecallbackinterfacelocalephemerallistener::vtablecallbackinterfacelocalephemerallistener::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::st::vtablecallbackinterfacelocalephemerallistener::
    vtablecallbackinterfacelocalephemerallistener::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::loro::st::vtablecallbackinterfacelocalephemerallistener::vtablecallbackinterfacelocalephemerallistener::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::loro::st::vtablecallbackinterfacelocalephemerallistener::vtablecallbackinterfacelocalephemerallistener::free

// Callback function:
// uniffi::loro::st::vtablecallbackinterfacelocalupdatecallback::vtablecallbackinterfacelocalupdatecallback::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::st::vtablecallbackinterfacelocalupdatecallback::
    vtablecallbackinterfacelocalupdatecallback::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::loro::st::vtablecallbackinterfacelocalupdatecallback::vtablecallbackinterfacelocalupdatecallback::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::loro::st::vtablecallbackinterfacelocalupdatecallback::vtablecallbackinterfacelocalupdatecallback::free

// Callback function:
// uniffi::loro::st::vtablecallbackinterfacelorovaluelike::vtablecallbackinterfacelorovaluelike::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::st::vtablecallbackinterfacelorovaluelike::
    vtablecallbackinterfacelorovaluelike::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::loro::st::vtablecallbackinterfacelorovaluelike::vtablecallbackinterfacelorovaluelike::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::loro::st::vtablecallbackinterfacelorovaluelike::vtablecallbackinterfacelorovaluelike::free

// Callback function:
// uniffi::loro::st::vtablecallbackinterfaceonpop::vtablecallbackinterfaceonpop::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::st::vtablecallbackinterfaceonpop::
    vtablecallbackinterfaceonpop::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::loro::st::vtablecallbackinterfaceonpop::vtablecallbackinterfaceonpop::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::loro::st::vtablecallbackinterfaceonpop::vtablecallbackinterfaceonpop::free

// Callback function:
// uniffi::loro::st::vtablecallbackinterfaceonpush::vtablecallbackinterfaceonpush::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::st::vtablecallbackinterfaceonpush::
    vtablecallbackinterfaceonpush::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::loro::st::vtablecallbackinterfaceonpush::vtablecallbackinterfaceonpush::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::loro::st::vtablecallbackinterfaceonpush::vtablecallbackinterfaceonpush::free

// Callback function:
// uniffi::loro::st::vtablecallbackinterfaceprecommitcallback::vtablecallbackinterfaceprecommitcallback::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::st::vtablecallbackinterfaceprecommitcallback::
    vtablecallbackinterfaceprecommitcallback::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::loro::st::vtablecallbackinterfaceprecommitcallback::vtablecallbackinterfaceprecommitcallback::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::loro::st::vtablecallbackinterfaceprecommitcallback::vtablecallbackinterfaceprecommitcallback::free

// Callback function:
// uniffi::loro::st::vtablecallbackinterfacesubscriber::vtablecallbackinterfacesubscriber::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::st::vtablecallbackinterfacesubscriber::
    vtablecallbackinterfacesubscriber::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::loro::st::vtablecallbackinterfacesubscriber::vtablecallbackinterfacesubscriber::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::loro::st::vtablecallbackinterfacesubscriber::vtablecallbackinterfacesubscriber::free

// Callback function:
// uniffi::loro::st::vtablecallbackinterfaceunsubscriber::vtablecallbackinterfaceunsubscriber::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::st::vtablecallbackinterfaceunsubscriber::
    vtablecallbackinterfaceunsubscriber::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::loro::st::vtablecallbackinterfaceunsubscriber::vtablecallbackinterfaceunsubscriber::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::loro::st::vtablecallbackinterfaceunsubscriber::vtablecallbackinterfaceunsubscriber::free

// Callback function:
// uniffi::loro::st::vtablecallbackinterfacevalueorcontainer::vtablecallbackinterfacevalueorcontainer::free::UniffiCallbackInterfaceFree
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::st::vtablecallbackinterfacevalueorcontainer::
    vtablecallbackinterfacevalueorcontainer::free {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t)> rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_handle) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_handle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_handle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_handle);

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceFree: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_handle) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_handle);
}

static UniffiCallbackInterfaceFree
makeCallbackFunction( // uniffi::loro::st::vtablecallbackinterfacevalueorcontainer::vtablecallbackinterfacevalueorcontainer::free
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](uint64_t rs_handle) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_handle](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_handle);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.

    callInvoker->invokeNonBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::loro::st::vtablecallbackinterfacevalueorcontainer::vtablecallbackinterfacevalueorcontainer::free
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFuture> {
  static UniffiForeignFuture fromJs(jsi::Runtime &rt,
                                    std::shared_ptr<CallInvoker> callInvoker,
                                    const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for UniffiForeignFuture");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFuture rsObject;

    // Create the vtable from the js callbacks.
    rsObject.handle = uniffi_jsi::Bridging<uint64_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "handle"));
    rsObject.free = uniffi::loro::st::foreignfuture::foreignfuture::free::
        makeCallbackFunction(rt, callInvoker, jsObject.getProperty(rt, "free"));

    return rsObject;
  }
};

} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructU8> {
  static UniffiForeignFutureStructU8
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructU8");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructU8 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<uint8_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status = uniffi::loro::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::loro
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteU8, passed from Rust to JS as part of async callbacks.
namespace uniffi::loro {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteU8> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteU8 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteU8"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteU8 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::loro::Bridging<UniffiForeignFutureStructU8>::fromJs(
             rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructI8> {
  static UniffiForeignFutureStructI8
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructI8");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructI8 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<int8_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status = uniffi::loro::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::loro
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteI8, passed from Rust to JS as part of async callbacks.
namespace uniffi::loro {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteI8> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteI8 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteI8"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteI8 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::loro::Bridging<UniffiForeignFutureStructI8>::fromJs(
             rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructU16> {
  static UniffiForeignFutureStructU16
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructU16");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructU16 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<uint16_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status = uniffi::loro::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::loro
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteU16, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::loro {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteU16> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteU16 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteU16"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteU16 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::loro::Bridging<UniffiForeignFutureStructU16>::fromJs(
             rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructI16> {
  static UniffiForeignFutureStructI16
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructI16");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructI16 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<int16_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status = uniffi::loro::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::loro
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteI16, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::loro {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteI16> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteI16 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteI16"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteI16 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::loro::Bridging<UniffiForeignFutureStructI16>::fromJs(
             rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructU32> {
  static UniffiForeignFutureStructU32
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructU32");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructU32 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<uint32_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status = uniffi::loro::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::loro
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteU32, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::loro {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteU32> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteU32 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteU32"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteU32 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::loro::Bridging<UniffiForeignFutureStructU32>::fromJs(
             rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructI32> {
  static UniffiForeignFutureStructI32
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructI32");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructI32 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<int32_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status = uniffi::loro::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::loro
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteI32, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::loro {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteI32> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteI32 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteI32"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteI32 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::loro::Bridging<UniffiForeignFutureStructI32>::fromJs(
             rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructU64> {
  static UniffiForeignFutureStructU64
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructU64");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructU64 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<uint64_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status = uniffi::loro::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::loro
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteU64, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::loro {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteU64> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteU64 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteU64"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteU64 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::loro::Bridging<UniffiForeignFutureStructU64>::fromJs(
             rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructI64> {
  static UniffiForeignFutureStructI64
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructI64");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructI64 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<int64_t>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status = uniffi::loro::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::loro
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteI64, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::loro {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteI64> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteI64 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteI64"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteI64 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::loro::Bridging<UniffiForeignFutureStructI64>::fromJs(
             rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructF32> {
  static UniffiForeignFutureStructF32
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructF32");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructF32 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<float>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status = uniffi::loro::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::loro
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteF32, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::loro {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteF32> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteF32 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteF32"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteF32 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::loro::Bridging<UniffiForeignFutureStructF32>::fromJs(
             rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructF64> {
  static UniffiForeignFutureStructF64
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for UniffiForeignFutureStructF64");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructF64 rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<double>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status = uniffi::loro::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::loro
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteF64, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::loro {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteF64> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteF64 rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteF64"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteF64 func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::loro::Bridging<UniffiForeignFutureStructF64>::fromJs(
             rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructPointer> {
  static UniffiForeignFutureStructPointer
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiForeignFutureStructPointer");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructPointer rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi_jsi::Bridging<void *>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status = uniffi::loro::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::loro
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompletePointer, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::loro {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompletePointer> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompletePointer rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompletePointer"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompletePointer func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::loro::Bridging<UniffiForeignFutureStructPointer>::fromJs(
             rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructRustBuffer> {
  static UniffiForeignFutureStructRustBuffer
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiForeignFutureStructRustBuffer");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructRustBuffer rsObject;

    // Create the vtable from the js callbacks.
    rsObject.return_value = uniffi::loro::Bridging<RustBuffer>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "returnValue"));
    rsObject.call_status = uniffi::loro::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::loro
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteRustBuffer, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::loro {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteRustBuffer> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteRustBuffer rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteRustBuffer"),
        2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteRustBuffer func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::loro::Bridging<UniffiForeignFutureStructRustBuffer>::fromJs(
             rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureStructVoid> {
  static UniffiForeignFutureStructVoid
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiForeignFutureStructVoid");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiForeignFutureStructVoid rsObject;

    // Create the vtable from the js callbacks.
    rsObject.call_status = uniffi::loro::Bridging<RustCallStatus>::fromJs(
        rt, callInvoker, jsObject.getProperty(rt, "callStatus"));

    return rsObject;
  }
};

} // namespace uniffi::loro
  // Implementation of callback function calling from JS to Rust
  // ForeignFutureCompleteVoid, passed from Rust to JS as part of async
  // callbacks.
namespace uniffi::loro {
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiForeignFutureCompleteVoid> {
  static jsi::Value toJs(jsi::Runtime &rt,
                         std::shared_ptr<CallInvoker> callInvoker,
                         UniffiForeignFutureCompleteVoid rsCallback) {
    return jsi::Function::createFromHostFunction(
        rt, jsi::PropNameID::forAscii(rt, "--ForeignFutureCompleteVoid"), 2,
        [rsCallback, callInvoker](jsi::Runtime &rt, const jsi::Value &thisValue,
                                  const jsi::Value *arguments,
                                  size_t count) -> jsi::Value {
          return intoRust(rt, callInvoker, thisValue, arguments, count,
                          rsCallback);
        });
  }

  static jsi::Value intoRust(jsi::Runtime &rt,
                             std::shared_ptr<CallInvoker> callInvoker,
                             const jsi::Value &thisValue,
                             const jsi::Value *args, size_t count,
                             UniffiForeignFutureCompleteVoid func) {
    // Convert the arguments into the Rust, with Bridging<T>::fromJs,
    // then call the rs_callback with those arguments.
    func(uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
         uniffi::loro::Bridging<UniffiForeignFutureStructVoid>::fromJs(
             rt, callInvoker, args[1]));

    return jsi::Value::undefined();
  }
};
} // namespace uniffi::loro
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceChangeAncestorsTravelerMethod0

// Callback function:
// uniffi::loro::cb::callbackinterfacechangeancestorstravelermethod0::UniffiCallbackInterfaceChangeAncestorsTravelerMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacechangeancestorstravelermethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, int8_t *, RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_change,
                 int8_t *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_change =
      uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, rs_change);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_change);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi_jsi::Bridging<ReferenceHolder<int8_t>>::fromJs(
        rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback "
                 "UniffiCallbackInterfaceChangeAncestorsTravelerMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_change,
                     int8_t *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_change, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceChangeAncestorsTravelerMethod0
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacechangeancestorstravelermethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker,
              callbackValue](uint64_t rs_uniffiHandle, RustBuffer rs_change,
                             int8_t *rs_uniffiOutReturn,
                             RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_change,
         rs_uniffiOutReturn, uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_change,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacechangeancestorstravelermethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceContainerIdLikeMethod0

// Callback function:
// uniffi::loro::cb::callbackinterfacecontaineridlikemethod0::UniffiCallbackInterfaceContainerIdLikeMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacecontaineridlikemethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer *, RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_ty,
                 RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_ty = uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, rs_ty);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_ty);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::loro::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceContainerIdLikeMethod0: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_ty,
                     RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_ty, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceContainerIdLikeMethod0
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacecontaineridlikemethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker,
              callbackValue](uint64_t rs_uniffiHandle, RustBuffer rs_ty,
                             RustBuffer *rs_uniffiOutReturn,
                             RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_ty, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_ty,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacecontaineridlikemethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceEphemeralSubscriberMethod0

// Callback function:
// uniffi::loro::cb::callbackinterfaceephemeralsubscribermethod0::UniffiCallbackInterfaceEphemeralSubscriberMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfaceephemeralsubscribermethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, void *, RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_event,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_event =
      uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, rs_event);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_event);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback "
                 "UniffiCallbackInterfaceEphemeralSubscriberMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_event,
                     void *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_event, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceEphemeralSubscriberMethod0
makeCallbackFunction( // uniffi::loro::cb::callbackinterfaceephemeralsubscribermethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_event,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_event,
         rs_uniffiOutReturn, uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_event,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfaceephemeralsubscribermethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceFirstCommitFromPeerCallbackMethod0

// Callback function:
// uniffi::loro::cb::callbackinterfacefirstcommitfrompeercallbackmethod0::UniffiCallbackInterfaceFirstCommitFromPeerCallbackMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::
    callbackinterfacefirstcommitfrompeercallbackmethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, void *, RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_payload,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_payload =
      uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, rs_payload);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_payload);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback "
                 "UniffiCallbackInterfaceFirstCommitFromPeerCallbackMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_payload,
                     void *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_payload, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceFirstCommitFromPeerCallbackMethod0
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacefirstcommitfrompeercallbackmethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_payload,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_payload,
         rs_uniffiOutReturn, uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_payload,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace
  // uniffi::loro::cb::callbackinterfacefirstcommitfrompeercallbackmethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceLocalEphemeralListenerMethod0

// Callback function:
// uniffi::loro::cb::callbackinterfacelocalephemerallistenermethod0::UniffiCallbackInterfaceLocalEphemeralListenerMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacelocalephemerallistenermethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, void *, RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_update,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_update =
      uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, rs_update);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_update);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback "
                 "UniffiCallbackInterfaceLocalEphemeralListenerMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_update,
                     void *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_update, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceLocalEphemeralListenerMethod0
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacelocalephemerallistenermethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_update,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_update,
         rs_uniffiOutReturn, uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_update,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacelocalephemerallistenermethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceLocalUpdateCallbackMethod0

// Callback function:
// uniffi::loro::cb::callbackinterfacelocalupdatecallbackmethod0::UniffiCallbackInterfaceLocalUpdateCallbackMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacelocalupdatecallbackmethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, void *, RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_update,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_update =
      uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, rs_update);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_update);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback "
                 "UniffiCallbackInterfaceLocalUpdateCallbackMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_update,
                     void *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_update, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceLocalUpdateCallbackMethod0
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacelocalupdatecallbackmethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_update,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_update,
         rs_uniffiOutReturn, uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_update,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacelocalupdatecallbackmethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceLoroValueLikeMethod0

// Callback function:
// uniffi::loro::cb::callbackinterfacelorovaluelikemethod0::UniffiCallbackInterfaceLoroValueLikeMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacelorovaluelikemethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::loro::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceLoroValueLikeMethod0: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceLoroValueLikeMethod0
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacelorovaluelikemethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacelorovaluelikemethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceOnPopMethod0

// Callback function:
// uniffi::loro::cb::callbackinterfaceonpopmethod0::UniffiCallbackInterfaceOnPopMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfaceonpopmethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer, RustBuffer, void *,
                          RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_undoOrRedo,
                 RustBuffer rs_span, RustBuffer rs_undoMeta,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_undoOrRedo =
      uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, rs_undoOrRedo);
  auto js_span =
      uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, rs_span);
  auto js_undoMeta =
      uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, rs_undoMeta);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult =
        cb.call(rt, js_uniffiHandle, js_undoOrRedo, js_span, js_undoMeta);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceOnPopMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_undoOrRedo,
                     RustBuffer rs_span, RustBuffer rs_undoMeta,
                     void *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_undoOrRedo, rs_span, rs_undoMeta,
           rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceOnPopMethod0
makeCallbackFunction( // uniffi::loro::cb::callbackinterfaceonpopmethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_undoOrRedo,
                 RustBuffer rs_span, RustBuffer rs_undoMeta,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_undoOrRedo, rs_span,
         rs_undoMeta, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_undoOrRedo,
               rs_span, rs_undoMeta, rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfaceonpopmethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceOnPushMethod0

// Callback function:
// uniffi::loro::cb::callbackinterfaceonpushmethod0::UniffiCallbackInterfaceOnPushMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfaceonpushmethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, RustBuffer, RustBuffer,
                          RustBuffer *, RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_undoOrRedo,
                 RustBuffer rs_span, RustBuffer rs_diffEvent,
                 RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_undoOrRedo =
      uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, rs_undoOrRedo);
  auto js_span =
      uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, rs_span);
  auto js_diffEvent =
      uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, rs_diffEvent);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult =
        cb.call(rt, js_uniffiHandle, js_undoOrRedo, js_span, js_diffEvent);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::loro::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceOnPushMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_undoOrRedo,
                     RustBuffer rs_span, RustBuffer rs_diffEvent,
                     RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_undoOrRedo, rs_span, rs_diffEvent,
           rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceOnPushMethod0
makeCallbackFunction( // uniffi::loro::cb::callbackinterfaceonpushmethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker,
              callbackValue](uint64_t rs_uniffiHandle, RustBuffer rs_undoOrRedo,
                             RustBuffer rs_span, RustBuffer rs_diffEvent,
                             RustBuffer *rs_uniffiOutReturn,
                             RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_undoOrRedo, rs_span,
         rs_diffEvent, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_undoOrRedo,
               rs_span, rs_diffEvent, rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfaceonpushmethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfacePreCommitCallbackMethod0

// Callback function:
// uniffi::loro::cb::callbackinterfaceprecommitcallbackmethod0::UniffiCallbackInterfacePreCommitCallbackMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfaceprecommitcallbackmethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, void *, RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_payload,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_payload =
      uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, rs_payload);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_payload);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfacePreCommitCallbackMethod0: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_payload,
                     void *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_payload, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfacePreCommitCallbackMethod0
makeCallbackFunction( // uniffi::loro::cb::callbackinterfaceprecommitcallbackmethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_payload,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_payload,
         rs_uniffiOutReturn, uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_payload,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfaceprecommitcallbackmethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceSubscriberMethod0

// Callback function:
// uniffi::loro::cb::callbackinterfacesubscribermethod0::UniffiCallbackInterfaceSubscriberMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacesubscribermethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer, void *, RustCallStatus *)>
    rsLambda = nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer rs_diff,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);
  auto js_diff =
      uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, rs_diff);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle, js_diff);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

  } catch (const jsi::JSError &error) {
    std::cout << "Error in callback UniffiCallbackInterfaceSubscriberMethod0: "
              << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer rs_diff,
                     void *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_diff, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceSubscriberMethod0
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacesubscribermethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer rs_diff,
                 void *rs_uniffiOutReturn, RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_diff,
         rs_uniffiOutReturn, uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle, rs_diff,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacesubscribermethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceUnsubscriberMethod0

// Callback function:
// uniffi::loro::cb::callbackinterfaceunsubscribermethod0::UniffiCallbackInterfaceUnsubscriberMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfaceunsubscribermethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, void *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, void *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceUnsubscriberMethod0: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, void *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceUnsubscriberMethod0
makeCallbackFunction( // uniffi::loro::cb::callbackinterfaceunsubscribermethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker,
              callbackValue](uint64_t rs_uniffiHandle, void *rs_uniffiOutReturn,
                             RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfaceunsubscribermethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceValueOrContainerMethod0

// Callback function:
// uniffi::loro::cb::callbackinterfacevalueorcontainermethod0::UniffiCallbackInterfaceValueOrContainerMethod0
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod0 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::loro::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceValueOrContainerMethod0: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceValueOrContainerMethod0
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacevalueorcontainermethod0
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod0
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceValueOrContainerMethod1

// Callback function:
// uniffi::loro::cb::callbackinterfacevalueorcontainermethod1::UniffiCallbackInterfaceValueOrContainerMethod1
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod1 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::loro::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceValueOrContainerMethod1: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceValueOrContainerMethod1
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacevalueorcontainermethod1
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod1
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceValueOrContainerMethod2

// Callback function:
// uniffi::loro::cb::callbackinterfacevalueorcontainermethod2::UniffiCallbackInterfaceValueOrContainerMethod2
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod2 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::loro::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceValueOrContainerMethod2: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceValueOrContainerMethod2
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacevalueorcontainermethod2
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod2
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceValueOrContainerMethod3

// Callback function:
// uniffi::loro::cb::callbackinterfacevalueorcontainermethod3::UniffiCallbackInterfaceValueOrContainerMethod3
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod3 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::loro::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceValueOrContainerMethod3: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceValueOrContainerMethod3
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacevalueorcontainermethod3
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod3
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceValueOrContainerMethod4

// Callback function:
// uniffi::loro::cb::callbackinterfacevalueorcontainermethod4::UniffiCallbackInterfaceValueOrContainerMethod4
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod4 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::loro::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceValueOrContainerMethod4: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceValueOrContainerMethod4
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacevalueorcontainermethod4
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod4
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceValueOrContainerMethod5

// Callback function:
// uniffi::loro::cb::callbackinterfacevalueorcontainermethod5::UniffiCallbackInterfaceValueOrContainerMethod5
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod5 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::loro::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceValueOrContainerMethod5: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceValueOrContainerMethod5
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacevalueorcontainermethod5
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod5
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceValueOrContainerMethod6

// Callback function:
// uniffi::loro::cb::callbackinterfacevalueorcontainermethod6::UniffiCallbackInterfaceValueOrContainerMethod6
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod6 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::loro::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceValueOrContainerMethod6: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceValueOrContainerMethod6
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacevalueorcontainermethod6
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod6
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceValueOrContainerMethod7

// Callback function:
// uniffi::loro::cb::callbackinterfacevalueorcontainermethod7::UniffiCallbackInterfaceValueOrContainerMethod7
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod7 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::loro::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceValueOrContainerMethod7: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceValueOrContainerMethod7
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacevalueorcontainermethod7
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod7
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceValueOrContainerMethod8

// Callback function:
// uniffi::loro::cb::callbackinterfacevalueorcontainermethod8::UniffiCallbackInterfaceValueOrContainerMethod8
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod8 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::loro::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceValueOrContainerMethod8: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceValueOrContainerMethod8
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacevalueorcontainermethod8
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod8
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceValueOrContainerMethod9

// Callback function:
// uniffi::loro::cb::callbackinterfacevalueorcontainermethod9::UniffiCallbackInterfaceValueOrContainerMethod9
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod9 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, RustBuffer *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn =
        uniffi::loro::Bridging<ReferenceHolder<RustBuffer>>::fromJs(
            rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceValueOrContainerMethod9: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceValueOrContainerMethod9
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacevalueorcontainermethod9
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, RustBuffer *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod9
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceValueOrContainerMethod10

// Callback function:
// uniffi::loro::cb::callbackinterfacevalueorcontainermethod10::UniffiCallbackInterfaceValueOrContainerMethod10
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod10 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, int8_t *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, int8_t *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi_jsi::Bridging<ReferenceHolder<int8_t>>::fromJs(
        rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceValueOrContainerMethod10: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, int8_t *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceValueOrContainerMethod10
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacevalueorcontainermethod10
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, int8_t *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod10
  // Implementation of callback function calling from Rust to JS
  // CallbackInterfaceValueOrContainerMethod11

// Callback function:
// uniffi::loro::cb::callbackinterfacevalueorcontainermethod11::UniffiCallbackInterfaceValueOrContainerMethod11
//
// We have the following constraints:
// - we need to pass a function pointer to Rust.
// - we need a jsi::Runtime and jsi::Function to call into JS.
// - function pointers can't store state, so we can't use a lamda.
//
// For this, we store a lambda as a global, as `rsLambda`. The `callback`
// function calls the lambda, which itself calls the `body` which then calls
// into JS.
//
// We then give the `callback` function pointer to Rust which will call the
// lambda sometime in the future.
namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod11 {
using namespace facebook;

// We need to store a lambda in a global so we can call it from
// a function pointer. The function pointer is passed to Rust.
static std::function<void(uint64_t, int8_t *, RustCallStatus *)> rsLambda =
    nullptr;

// This is the main body of the callback. It's called from the lambda,
// which itself is called from the callback function which is passed to Rust.
static void body(jsi::Runtime &rt,
                 std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
                 std::shared_ptr<jsi::Value> callbackValue,
                 uint64_t rs_uniffiHandle, int8_t *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {

  // Convert the arguments from Rust, into jsi::Values.
  // We'll use the Bridging class to do this
  auto js_uniffiHandle =
      uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, rs_uniffiHandle);

  // Now we are ready to call the callback.
  // We are already on the JS thread, because this `body` function was
  // invoked from the CallInvoker.
  try {
    // Getting the callback function
    auto cb = callbackValue->asObject(rt).asFunction(rt);
    auto uniffiResult = cb.call(rt, js_uniffiHandle);

    // Now copy the result back from JS into the RustCallStatus object.
    uniffi::loro::Bridging<RustCallStatus>::copyFromJs(
        rt, callInvoker, uniffiResult, uniffi_call_status);

    if (uniffi_call_status->code != UNIFFI_CALL_STATUS_OK) {
      // The JS callback finished abnormally, so we cannot retrieve the return
      // value.
      return;
    }

    // Finally, we need to copy the return value back into the Rust pointer.
    *rs_uniffiOutReturn = uniffi_jsi::Bridging<ReferenceHolder<int8_t>>::fromJs(
        rt, callInvoker, uniffiResult);
  } catch (const jsi::JSError &error) {
    std::cout
        << "Error in callback UniffiCallbackInterfaceValueOrContainerMethod11: "
        << error.what() << std::endl;
    throw error;
  }
}

static void callback(uint64_t rs_uniffiHandle, int8_t *rs_uniffiOutReturn,
                     RustCallStatus *uniffi_call_status) {
  // If the runtime has shutdown, then there is no point in trying to
  // call into Javascript. BUT how do we tell if the runtime has shutdown?
  //
  // Answer: the module destructor calls into callback `cleanup` method,
  // which nulls out the rsLamda.
  //
  // If rsLamda is null, then there is no runtime to call into.
  if (rsLambda == nullptr) {
    // This only occurs when destructors are calling into Rust free/drop,
    // which causes the JS callback to be dropped.
    return;
  }

  // The runtime, the actual callback jsi::funtion, and the callInvoker
  // are all in the lambda.
  rsLambda(rs_uniffiHandle, rs_uniffiOutReturn, uniffi_call_status);
}

static UniffiCallbackInterfaceValueOrContainerMethod11
makeCallbackFunction( // uniffi::loro::cb::callbackinterfacevalueorcontainermethod11
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> callInvoker,
    const jsi::Value &value) {
  if (rsLambda != nullptr) {
    // `makeCallbackFunction` is called in two circumstances:
    //
    // 1. at startup, when initializing callback interface vtables.
    // 2. when polling futures. This happens at least once per future that is
    //    exposed to Javascript. We know that this is always the same function,
    //    `uniffiFutureContinuationCallback` in `async-rust-calls.ts`.
    //
    // We can therefore return the callback function without making anything
    // new if we've been initialized already.
    return callback;
  }
  auto callbackFunction = value.asObject(rt).asFunction(rt);
  auto callbackValue = std::make_shared<jsi::Value>(rt, callbackFunction);
  rsLambda = [&rt, callInvoker, callbackValue](
                 uint64_t rs_uniffiHandle, int8_t *rs_uniffiOutReturn,
                 RustCallStatus *uniffi_call_status) {
    // We immediately make a lambda which will do the work of transforming the
    // arguments into JSI values and calling the callback.
    uniffi_runtime::UniffiCallFunc jsLambda =
        [callInvoker, callbackValue, rs_uniffiHandle, rs_uniffiOutReturn,
         uniffi_call_status](jsi::Runtime &rt) mutable {
          body(rt, callInvoker, callbackValue, rs_uniffiHandle,
               rs_uniffiOutReturn, uniffi_call_status);
        };
    // We'll then call that lambda from the callInvoker which will
    // look after calling it on the correct thread.
    callInvoker->invokeBlocking(rt, jsLambda);
  };
  return callback;
}

// This method is called from the destructor of NativeLoro, which only happens
// when the jsi::Runtime is being destroyed.
static void cleanup() {
  // The lambda holds a reference to the the Runtime, so when this is nulled
  // out, then the pointer will no longer be left dangling.
  rsLambda = nullptr;
}
} // namespace uniffi::loro::cb::callbackinterfacevalueorcontainermethod11
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <>
struct Bridging<UniffiVTableCallbackInterfaceChangeAncestorsTraveler> {
  static UniffiVTableCallbackInterfaceChangeAncestorsTraveler
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for "
              "UniffiVTableCallbackInterfaceChangeAncestorsTraveler");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceChangeAncestorsTraveler rsObject;

    // Create the vtable from the js callbacks.
    rsObject.travel = uniffi::loro::cb::
        callbackinterfacechangeancestorstravelermethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "travel"));
    rsObject.uniffi_free =
        uniffi::loro::st::vtablecallbackinterfacechangeancestorstraveler::
            vtablecallbackinterfacechangeancestorstraveler::free::
                makeCallbackFunction(rt, callInvoker,
                                     jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceContainerIdLike> {
  static UniffiVTableCallbackInterfaceContainerIdLike
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for "
                             "UniffiVTableCallbackInterfaceContainerIdLike");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceContainerIdLike rsObject;

    // Create the vtable from the js callbacks.
    rsObject.as_container_id = uniffi::loro::cb::
        callbackinterfacecontaineridlikemethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "asContainerId"));
    rsObject.uniffi_free =
        uniffi::loro::st::vtablecallbackinterfacecontaineridlike::
            vtablecallbackinterfacecontaineridlike::free::makeCallbackFunction(
                rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceEphemeralSubscriber> {
  static UniffiVTableCallbackInterfaceEphemeralSubscriber
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for "
                         "UniffiVTableCallbackInterfaceEphemeralSubscriber");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceEphemeralSubscriber rsObject;

    // Create the vtable from the js callbacks.
    rsObject.on_ephemeral_event = uniffi::loro::cb::
        callbackinterfaceephemeralsubscribermethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "onEphemeralEvent"));
    rsObject.uniffi_free =
        uniffi::loro::st::vtablecallbackinterfaceephemeralsubscriber::
            vtablecallbackinterfaceephemeralsubscriber::free::
                makeCallbackFunction(rt, callInvoker,
                                     jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <>
struct Bridging<UniffiVTableCallbackInterfaceFirstCommitFromPeerCallback> {
  static UniffiVTableCallbackInterfaceFirstCommitFromPeerCallback
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for "
              "UniffiVTableCallbackInterfaceFirstCommitFromPeerCallback");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceFirstCommitFromPeerCallback rsObject;

    // Create the vtable from the js callbacks.
    rsObject.on_first_commit_from_peer =
        uniffi::loro::cb::callbackinterfacefirstcommitfrompeercallbackmethod0::
            makeCallbackFunction(
                rt, callInvoker,
                jsObject.getProperty(rt, "onFirstCommitFromPeer"));
    rsObject.uniffi_free =
        uniffi::loro::st::vtablecallbackinterfacefirstcommitfrompeercallback::
            vtablecallbackinterfacefirstcommitfrompeercallback::free::
                makeCallbackFunction(rt, callInvoker,
                                     jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <>
struct Bridging<UniffiVTableCallbackInterfaceLocalEphemeralListener> {
  static UniffiVTableCallbackInterfaceLocalEphemeralListener
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for "
                         "UniffiVTableCallbackInterfaceLocalEphemeralListener");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceLocalEphemeralListener rsObject;

    // Create the vtable from the js callbacks.
    rsObject.on_ephemeral_update = uniffi::loro::cb::
        callbackinterfacelocalephemerallistenermethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "onEphemeralUpdate"));
    rsObject.uniffi_free =
        uniffi::loro::st::vtablecallbackinterfacelocalephemerallistener::
            vtablecallbackinterfacelocalephemerallistener::free::
                makeCallbackFunction(rt, callInvoker,
                                     jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceLocalUpdateCallback> {
  static UniffiVTableCallbackInterfaceLocalUpdateCallback
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt,
                         "Expected an object for "
                         "UniffiVTableCallbackInterfaceLocalUpdateCallback");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceLocalUpdateCallback rsObject;

    // Create the vtable from the js callbacks.
    rsObject.on_local_update = uniffi::loro::cb::
        callbackinterfacelocalupdatecallbackmethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "onLocalUpdate"));
    rsObject.uniffi_free =
        uniffi::loro::st::vtablecallbackinterfacelocalupdatecallback::
            vtablecallbackinterfacelocalupdatecallback::free::
                makeCallbackFunction(rt, callInvoker,
                                     jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceLoroValueLike> {
  static UniffiVTableCallbackInterfaceLoroValueLike
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt,
          "Expected an object for UniffiVTableCallbackInterfaceLoroValueLike");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceLoroValueLike rsObject;

    // Create the vtable from the js callbacks.
    rsObject.as_loro_value = uniffi::loro::cb::
        callbackinterfacelorovaluelikemethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "asLoroValue"));
    rsObject.uniffi_free =
        uniffi::loro::st::vtablecallbackinterfacelorovaluelike::
            vtablecallbackinterfacelorovaluelike::free::makeCallbackFunction(
                rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceOnPop> {
  static UniffiVTableCallbackInterfaceOnPop
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiVTableCallbackInterfaceOnPop");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceOnPop rsObject;

    // Create the vtable from the js callbacks.
    rsObject.on_pop =
        uniffi::loro::cb::callbackinterfaceonpopmethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "onPop"));
    rsObject.uniffi_free = uniffi::loro::st::vtablecallbackinterfaceonpop::
        vtablecallbackinterfaceonpop::free::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceOnPush> {
  static UniffiVTableCallbackInterfaceOnPush
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiVTableCallbackInterfaceOnPush");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceOnPush rsObject;

    // Create the vtable from the js callbacks.
    rsObject.on_push =
        uniffi::loro::cb::callbackinterfaceonpushmethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "onPush"));
    rsObject.uniffi_free = uniffi::loro::st::vtablecallbackinterfaceonpush::
        vtablecallbackinterfaceonpush::free::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfacePreCommitCallback> {
  static UniffiVTableCallbackInterfacePreCommitCallback
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for "
                             "UniffiVTableCallbackInterfacePreCommitCallback");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfacePreCommitCallback rsObject;

    // Create the vtable from the js callbacks.
    rsObject.on_pre_commit = uniffi::loro::cb::
        callbackinterfaceprecommitcallbackmethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "onPreCommit"));
    rsObject.uniffi_free =
        uniffi::loro::st::vtablecallbackinterfaceprecommitcallback::
            vtablecallbackinterfaceprecommitcallback::free::
                makeCallbackFunction(rt, callInvoker,
                                     jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceSubscriber> {
  static UniffiVTableCallbackInterfaceSubscriber
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt, "Expected an object for UniffiVTableCallbackInterfaceSubscriber");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceSubscriber rsObject;

    // Create the vtable from the js callbacks.
    rsObject.on_diff = uniffi::loro::cb::callbackinterfacesubscribermethod0::
        makeCallbackFunction(rt, callInvoker,
                             jsObject.getProperty(rt, "onDiff"));
    rsObject.uniffi_free = uniffi::loro::st::vtablecallbackinterfacesubscriber::
        vtablecallbackinterfacesubscriber::free::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceUnsubscriber> {
  static UniffiVTableCallbackInterfaceUnsubscriber
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(
          rt,
          "Expected an object for UniffiVTableCallbackInterfaceUnsubscriber");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceUnsubscriber rsObject;

    // Create the vtable from the js callbacks.
    rsObject.on_unsubscribe = uniffi::loro::cb::
        callbackinterfaceunsubscribermethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "onUnsubscribe"));
    rsObject.uniffi_free =
        uniffi::loro::st::vtablecallbackinterfaceunsubscriber::
            vtablecallbackinterfaceunsubscriber::free::makeCallbackFunction(
                rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::loro
namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiVTableCallbackInterfaceValueOrContainer> {
  static UniffiVTableCallbackInterfaceValueOrContainer
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &jsValue) {
    // Check if the input is an object
    if (!jsValue.isObject()) {
      throw jsi::JSError(rt, "Expected an object for "
                             "UniffiVTableCallbackInterfaceValueOrContainer");
    }

    // Get the object from the jsi::Value
    auto jsObject = jsValue.getObject(rt);

    // Create the vtable struct
    UniffiVTableCallbackInterfaceValueOrContainer rsObject;

    // Create the vtable from the js callbacks.
    rsObject.as_container = uniffi::loro::cb::
        callbackinterfacevalueorcontainermethod0::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "asContainer"));
    rsObject.as_loro_counter = uniffi::loro::cb::
        callbackinterfacevalueorcontainermethod1::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "asLoroCounter"));
    rsObject.as_loro_list = uniffi::loro::cb::
        callbackinterfacevalueorcontainermethod2::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "asLoroList"));
    rsObject.as_loro_map = uniffi::loro::cb::
        callbackinterfacevalueorcontainermethod3::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "asLoroMap"));
    rsObject.as_loro_movable_list = uniffi::loro::cb::
        callbackinterfacevalueorcontainermethod4::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "asLoroMovableList"));
    rsObject.as_loro_text = uniffi::loro::cb::
        callbackinterfacevalueorcontainermethod5::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "asLoroText"));
    rsObject.as_loro_tree = uniffi::loro::cb::
        callbackinterfacevalueorcontainermethod6::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "asLoroTree"));
    rsObject.as_loro_unknown = uniffi::loro::cb::
        callbackinterfacevalueorcontainermethod7::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "asLoroUnknown"));
    rsObject.as_value = uniffi::loro::cb::
        callbackinterfacevalueorcontainermethod8::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "asValue"));
    rsObject.container_type = uniffi::loro::cb::
        callbackinterfacevalueorcontainermethod9::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "containerType"));
    rsObject.is_container = uniffi::loro::cb::
        callbackinterfacevalueorcontainermethod10::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "isContainer"));
    rsObject.is_value = uniffi::loro::cb::
        callbackinterfacevalueorcontainermethod11::makeCallbackFunction(
            rt, callInvoker, jsObject.getProperty(rt, "isValue"));
    rsObject.uniffi_free =
        uniffi::loro::st::vtablecallbackinterfacevalueorcontainer::
            vtablecallbackinterfacevalueorcontainer::free::makeCallbackFunction(
                rt, callInvoker, jsObject.getProperty(rt, "uniffiFree"));

    return rsObject;
  }
};

} // namespace uniffi::loro

namespace uniffi::loro {
using namespace facebook;
using CallInvoker = uniffi_runtime::UniffiCallInvoker;

template <> struct Bridging<UniffiRustFutureContinuationCallback> {
  static UniffiRustFutureContinuationCallback
  fromJs(jsi::Runtime &rt, std::shared_ptr<CallInvoker> callInvoker,
         const jsi::Value &value) {
    try {
      return uniffi::loro::cb::rustfuturecontinuationcallback::
          makeCallbackFunction(rt, callInvoker, value);
    } catch (const std::logic_error &e) {
      throw jsi::JSError(rt, e.what());
    }
  }
};

} // namespace uniffi::loro

NativeLoro::NativeLoro(
    jsi::Runtime &rt,
    std::shared_ptr<uniffi_runtime::UniffiCallInvoker> invoker)
    : callInvoker(invoker), props() {
  // Map from Javascript names to the cpp names
  props["ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_internal_fn_func_ffi__string_to_byte_length(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_awareness"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_clone_awareness"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_awareness(rt, thisVal,
                                                               args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_awareness"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_free_awareness"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_awareness(rt, thisVal, args,
                                                              count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_awareness_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_awareness_new"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_awareness_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_awareness_apply"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_awareness_apply"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_awareness_apply(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_awareness_encode"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_awareness_encode"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_awareness_encode(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_awareness_encode_all"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_awareness_encode_all"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_awareness_encode_all(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_awareness_get_all_states"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_awareness_get_all_states"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_awareness_get_all_states(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_awareness_get_local_state"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_awareness_get_local_state"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_awareness_get_local_state(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_awareness_peer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_awareness_peer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_awareness_peer(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_awareness_remove_outdated"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_awareness_remove_outdated"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_awareness_remove_outdated(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_awareness_set_local_state"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_awareness_set_local_state"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_awareness_set_local_state(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_changeancestorstraveler"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_changeancestorstraveler"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_changeancestorstraveler(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_changeancestorstraveler"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_free_changeancestorstraveler"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_changeancestorstraveler(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_changeancestorstraveler_travel"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_changeancestorstraveler_travel"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_changeancestorstraveler_travel(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_changemodifier"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_changemodifier"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_changemodifier(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_changemodifier"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_free_changemodifier"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_changemodifier(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_changemodifier_set_message"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_changemodifier_set_message"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_changemodifier_set_message(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_changemodifier_set_timestamp"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_changemodifier_set_timestamp"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_changemodifier_set_timestamp(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_configure"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_clone_configure"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_configure(rt, thisVal,
                                                               args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_configure"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_free_configure"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_configure(rt, thisVal, args,
                                                              count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_configure_fork"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_configure_fork"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_configure_fork(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_configure_merge_interval"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_configure_merge_interval"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_configure_merge_interval(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_configure_record_timestamp"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_configure_record_timestamp"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_configure_record_timestamp(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_configure_set_merge_interval"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_configure_set_merge_interval"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_configure_set_merge_interval(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_configure_set_record_timestamp"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_configure_set_record_timestamp"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_configure_set_record_timestamp(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_configure_text_style_config"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_configure_text_style_config"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_configure_text_style_config(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_containeridlike"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_containeridlike"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_containeridlike(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_containeridlike"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_free_containeridlike"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_containeridlike(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_containeridlike_as_container_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_containeridlike_as_container_id"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_containeridlike_as_container_id(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_cursor"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_clone_cursor"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_cursor(rt, thisVal, args,
                                                            count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_cursor"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_free_cursor"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_cursor(rt, thisVal, args,
                                                           count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_cursor_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_cursor_new"),
          4,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_cursor_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_diffbatch"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_clone_diffbatch"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_diffbatch(rt, thisVal,
                                                               args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_diffbatch"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_free_diffbatch"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_diffbatch(rt, thisVal, args,
                                                              count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_diffbatch_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_diffbatch_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_diffbatch_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_diffbatch_get_diff"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_diffbatch_get_diff"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_diffbatch_get_diff(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_diffbatch_push"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_diffbatch_push"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_diffbatch_push(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_ephemeralstore"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_ephemeralstore"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_ephemeralstore(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_ephemeralstore"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_free_ephemeralstore"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_ephemeralstore(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_ephemeralstore_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_ephemeralstore_new"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_ephemeralstore_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_ephemeralstore_apply"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_ephemeralstore_apply"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_ephemeralstore_apply(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_ephemeralstore_delete"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_ephemeralstore_delete"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_ephemeralstore_delete(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_ephemeralstore_encode"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_ephemeralstore_encode"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_ephemeralstore_encode(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_ephemeralstore_encode_all"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_ephemeralstore_encode_all"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_ephemeralstore_encode_all(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_ephemeralstore_get"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_ephemeralstore_get"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_ephemeralstore_get(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_ephemeralstore_get_all_states"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_ephemeralstore_get_all_states"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_ephemeralstore_get_all_states(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_ephemeralstore_keys"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_ephemeralstore_keys"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_ephemeralstore_keys(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_ephemeralstore_remove_outdated"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_ephemeralstore_remove_outdated"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_ephemeralstore_remove_outdated(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_ephemeralstore_set"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_ephemeralstore_set"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_ephemeralstore_set(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_ephemeralstore_subscribe"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_ephemeralstore_subscribe"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_ephemeralstore_subscribe(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_ephemeralstore_subscribe_local_update"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_method_"
                                    "ephemeralstore_subscribe_local_update"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_ephemeralstore_subscribe_local_update(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_ephemeralsubscriber"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_ephemeralsubscriber"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_ephemeralsubscriber(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_ephemeralsubscriber"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_free_ephemeralsubscriber"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_ephemeralsubscriber(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_ephemeralsubscriber_on_ephemeral_"
        "event"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_"
                                    "ephemeralsubscriber_on_ephemeral_event"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_fn_method_ephemeralsubscriber_on_ephemeral_event(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_fn_clone_firstcommitfrompeercallback"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_firstcommitfrompeercallback"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_clone_firstcommitfrompeercallback(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_firstcommitfrompeercallback"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_free_firstcommitfrompeercallback"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_firstcommitfrompeercallback(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_firstcommitfrompeercallback_on_first_"
        "commit_from_peer"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_loro_rs_fn_method_firstcommitfrompeercallback_on_"
              "first_commit_from_peer"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_fn_method_firstcommitfrompeercallback_on_first_commit_from_peer(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_fn_clone_fractionalindex"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_fractionalindex"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_fractionalindex(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_fractionalindex"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_free_fractionalindex"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_fractionalindex(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_fractionalindex_from_bytes"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_constructor_fractionalindex_from_bytes"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_constructor_fractionalindex_from_bytes(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_fractionalindex_from_hex_string"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_constructor_"
                                        "fractionalindex_from_hex_string"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_constructor_fractionalindex_from_hex_string(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_fractionalindex_to_string"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_fractionalindex_to_string"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_fractionalindex_to_string(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_frontiers"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_clone_frontiers"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_frontiers(rt, thisVal,
                                                               args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_frontiers"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_free_frontiers"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_frontiers(rt, thisVal, args,
                                                              count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_frontiers_decode"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_frontiers_decode"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_frontiers_decode(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_frontiers_from_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_frontiers_from_id"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_frontiers_from_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_frontiers_from_ids"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_frontiers_from_ids"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_frontiers_from_ids(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_frontiers_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_frontiers_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_frontiers_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_frontiers_encode"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_frontiers_encode"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_frontiers_encode(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_frontiers_eq"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_frontiers_eq"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_frontiers_eq(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_localephemerallistener"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_localephemerallistener"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_localephemerallistener(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_localephemerallistener"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_free_localephemerallistener"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_localephemerallistener(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_localephemerallistener_on_ephemeral_"
        "update"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_loro_rs_fn_method_"
                                "localephemerallistener_on_ephemeral_update"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_fn_method_localephemerallistener_on_ephemeral_update(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_fn_clone_localupdatecallback"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_localupdatecallback"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_localupdatecallback(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_localupdatecallback"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_free_localupdatecallback"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_localupdatecallback(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_localupdatecallback_on_local_update"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_"
                                        "localupdatecallback_on_local_update"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_localupdatecallback_on_local_update(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_lorocounter"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_clone_lorocounter"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_lorocounter(rt, thisVal,
                                                                 args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_lorocounter"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_free_lorocounter"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_lorocounter(rt, thisVal,
                                                                args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_lorocounter_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_lorocounter_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_lorocounter_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorocounter_decrement"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorocounter_decrement"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorocounter_decrement(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorocounter_doc"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorocounter_doc"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorocounter_doc(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorocounter_get_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorocounter_get_attached"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorocounter_get_attached(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorocounter_get_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorocounter_get_value"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorocounter_get_value(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorocounter_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorocounter_id"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorocounter_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorocounter_increment"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorocounter_increment"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorocounter_increment(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorocounter_is_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorocounter_is_attached"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorocounter_is_attached(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorocounter_is_deleted"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorocounter_is_deleted"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorocounter_is_deleted(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_lorodoc"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_clone_lorodoc"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_lorodoc(rt, thisVal, args,
                                                             count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_lorodoc"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_free_lorodoc"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_lorodoc(rt, thisVal, args,
                                                            count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_lorodoc_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_lorodoc_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_lorodoc_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_apply_diff"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_apply_diff"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_apply_diff(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_attach"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_attach"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_attach(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_check_state_correctness_slow"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_"
                                        "check_state_correctness_slow"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_check_state_correctness_slow(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_checkout"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_checkout"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_checkout(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_checkout_to_latest"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_checkout_to_latest"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_checkout_to_latest(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_clear_next_commit_options"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_"
                                        "clear_next_commit_options"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_clear_next_commit_options(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_cmp_with_frontiers"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_cmp_with_frontiers"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_cmp_with_frontiers(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_commit"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_commit"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_commit(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_commit_with"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_commit_with"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_commit_with(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_compact_change_store"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_compact_change_store"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_compact_change_store(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_config"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_config"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_config(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_config_default_text_style"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_"
                                        "config_default_text_style"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_config_default_text_style(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_config_text_style"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_config_text_style"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_config_text_style(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_detach"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_detach"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_detach(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_diff"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_diff"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_diff(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_export_json_in_id_span"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_lorodoc_export_json_in_id_span"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_export_json_in_id_span(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_export_json_updates"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_export_json_updates"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_export_json_updates(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_export_json_updates_without_"
        "peer_compression"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_loro_rs_fn_method_lorodoc_export_"
                                "json_updates_without_peer_compression"),
      3,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_fn_method_lorodoc_export_json_updates_without_peer_compression(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_export_shallow_snapshot"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_lorodoc_export_shallow_snapshot"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_export_shallow_snapshot(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_export_snapshot"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_export_snapshot"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_export_snapshot(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_export_snapshot_at"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_export_snapshot_at"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_export_snapshot_at(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_export_state_only"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_export_state_only"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_export_state_only(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_export_updates"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_export_updates"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_export_updates(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_export_updates_in_range"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_lorodoc_export_updates_in_range"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_export_updates_in_range(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_find_id_spans_between"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_lorodoc_find_id_spans_between"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_find_id_spans_between(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_fork"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_fork"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_fork(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_fork_at"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_fork_at"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_fork_at(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_free_diff_calculator"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_free_diff_calculator"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_free_diff_calculator(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_free_history_cache"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_free_history_cache"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_free_history_cache(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_frontiers_to_vv"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_frontiers_to_vv"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_frontiers_to_vv(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_get_by_path"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_get_by_path"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_get_by_path(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_get_by_str_path"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_get_by_str_path"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_get_by_str_path(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_get_change"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_get_change"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_get_change(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_get_changed_containers_in"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_"
                                        "get_changed_containers_in"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_get_changed_containers_in(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_get_counter"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_get_counter"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_get_counter(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_get_cursor_pos"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_get_cursor_pos"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_get_cursor_pos(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_get_deep_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_get_deep_value"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_get_deep_value(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_get_deep_value_with_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_lorodoc_get_deep_value_with_id"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_get_deep_value_with_id(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_get_list"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_get_list"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_get_list(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_get_map"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_get_map"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_get_map(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_get_movable_list"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_get_movable_list"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_get_movable_list(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_get_path_to_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_lorodoc_get_path_to_container"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_get_path_to_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_get_pending_txn_len"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_get_pending_txn_len"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_get_pending_txn_len(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_get_text"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_get_text"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_get_text(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_get_tree"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_get_tree"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_get_tree(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_get_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_get_value"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_get_value(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_has_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_has_container"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_has_container(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_has_history_cache"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_has_history_cache"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_has_history_cache(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_import"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_import"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_import(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_import_batch"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_import_batch"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_import_batch(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_import_json_updates"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_import_json_updates"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_import_json_updates(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_import_with"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_import_with"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_import_with(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_is_detached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_is_detached"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_is_detached(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_is_shallow"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_is_shallow"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_is_shallow(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_jsonpath"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_jsonpath"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_jsonpath(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_len_changes"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_len_changes"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_len_changes(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_len_ops"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_len_ops"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_len_ops(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_log_estimate_size"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_log_estimate_size"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_log_estimate_size(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_minimize_frontiers"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_minimize_frontiers"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_minimize_frontiers(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_oplog_frontiers"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_oplog_frontiers"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_oplog_frontiers(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_oplog_vv"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_oplog_vv"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_oplog_vv(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_peer_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_peer_id"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_peer_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_revert_to"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_revert_to"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_revert_to(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_set_change_merge_interval"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_"
                                        "set_change_merge_interval"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_set_change_merge_interval(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_set_next_commit_message"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_lorodoc_set_next_commit_message"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_set_next_commit_message(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_set_next_commit_options"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_lorodoc_set_next_commit_options"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_set_next_commit_options(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_set_next_commit_origin"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_lorodoc_set_next_commit_origin"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_set_next_commit_origin(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_set_next_commit_timestamp"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_"
                                        "set_next_commit_timestamp"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_set_next_commit_timestamp(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_set_peer_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_set_peer_id"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_set_peer_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_set_record_timestamp"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_set_record_timestamp"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_set_record_timestamp(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_shallow_since_vv"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_shallow_since_vv"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_shallow_since_vv(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_state_frontiers"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_state_frontiers"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_state_frontiers(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_state_vv"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_state_vv"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_state_vv(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_subscribe"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_subscribe"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_subscribe(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_subscribe_first_commit_from_"
        "peer"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_"
                                    "subscribe_first_commit_from_peer"),
      2,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_fn_method_lorodoc_subscribe_first_commit_from_peer(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_subscribe_local_update"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_lorodoc_subscribe_local_update"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_subscribe_local_update(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_subscribe_pre_commit"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_subscribe_pre_commit"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_subscribe_pre_commit(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_subscribe_root"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_subscribe_root"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_subscribe_root(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_travel_change_ancestors"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_lorodoc_travel_change_ancestors"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorodoc_travel_change_ancestors(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorodoc_vv_to_frontiers"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorodoc_vv_to_frontiers"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorodoc_vv_to_frontiers(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_lorolist"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_clone_lorolist"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_lorolist(rt, thisVal, args,
                                                              count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_lorolist"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_free_lorolist"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_lorolist(rt, thisVal, args,
                                                             count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_lorolist_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_lorolist_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_lorolist_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_clear"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_clear"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_clear(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_delete"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_delete"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_delete(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_doc"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_doc"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_doc(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_get"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_get"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_get(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_get_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_get_attached"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_get_attached(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_get_cursor"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_get_cursor"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_get_cursor(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_get_deep_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_get_deep_value"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_get_deep_value(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_get_id_at"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_get_id_at"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_get_id_at(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_get_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_get_value"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_get_value(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_id"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_id(rt, thisVal,
                                                                  args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_insert"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_insert"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_insert(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_insert_counter_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_"
                                        "lorolist_insert_counter_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorolist_insert_counter_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_insert_list_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_lorolist_insert_list_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorolist_insert_list_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_insert_map_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_lorolist_insert_map_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorolist_insert_map_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_insert_movable_list_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_"
                                    "insert_movable_list_container"),
      3,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_fn_method_lorolist_insert_movable_list_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_insert_text_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_lorolist_insert_text_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorolist_insert_text_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_insert_tree_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_lorolist_insert_tree_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorolist_insert_tree_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_is_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_is_attached"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_is_attached(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_is_deleted"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_is_deleted"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_is_deleted(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_is_empty"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_is_empty"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_is_empty(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_len"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_len"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_len(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_pop"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_pop"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_pop(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_push"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_push"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_push(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorolist_to_vec"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorolist_to_vec"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorolist_to_vec(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_loromap"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_clone_loromap"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_loromap(rt, thisVal, args,
                                                             count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_loromap"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_free_loromap"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_loromap(rt, thisVal, args,
                                                            count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_loromap_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_loromap_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_loromap_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_clear"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromap_clear"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromap_clear(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_delete"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromap_delete"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromap_delete(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_doc"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromap_doc"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromap_doc(rt, thisVal,
                                                                  args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_get"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromap_get"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromap_get(rt, thisVal,
                                                                  args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_get_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromap_get_attached"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromap_get_attached(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_get_deep_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromap_get_deep_value"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromap_get_deep_value(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_get_last_editor"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromap_get_last_editor"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromap_get_last_editor(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_get_or_create_counter_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_loromap_get_"
                                    "or_create_counter_container"),
      3,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_fn_method_loromap_get_or_create_counter_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_get_or_create_list_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_loromap_"
                                        "get_or_create_list_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromap_get_or_create_list_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_get_or_create_map_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_loromap_"
                                        "get_or_create_map_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromap_get_or_create_map_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_get_or_create_movable_list_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_loromap_get_"
                                    "or_create_movable_list_container"),
      3,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_fn_method_loromap_get_or_create_movable_list_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_get_or_create_text_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_loromap_"
                                        "get_or_create_text_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromap_get_or_create_text_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_get_or_create_tree_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_loromap_"
                                        "get_or_create_tree_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromap_get_or_create_tree_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_get_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromap_get_value"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromap_get_value(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_method_loromap_id"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromap_id(rt, thisVal,
                                                                 args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_insert"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromap_insert"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromap_insert(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_insert_counter_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_loromap_insert_counter_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromap_insert_counter_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_insert_list_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_loromap_insert_list_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromap_insert_list_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_insert_map_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromap_insert_map_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromap_insert_map_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_insert_movable_list_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_loromap_"
                                        "insert_movable_list_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromap_insert_movable_list_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_insert_text_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_loromap_insert_text_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromap_insert_text_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_insert_tree_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_loromap_insert_tree_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromap_insert_tree_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_is_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromap_is_attached"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromap_is_attached(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_is_deleted"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromap_is_deleted"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromap_is_deleted(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_is_empty"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromap_is_empty"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromap_is_empty(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_keys"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromap_keys"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromap_keys(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_len"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromap_len"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromap_len(rt, thisVal,
                                                                  args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromap_values"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromap_values"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromap_values(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_loromovablelist"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_loromovablelist"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_loromovablelist(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_loromovablelist"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_free_loromovablelist"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_loromovablelist(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_loromovablelist_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_loromovablelist_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_loromovablelist_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_clear"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_clear"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromovablelist_clear(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_delete"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_delete"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromovablelist_delete(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_doc"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_doc"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromovablelist_doc(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_get"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_get"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromovablelist_get(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_get_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_get_attached"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_get_attached(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_get_creator_at"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_loromovablelist_get_creator_at"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_get_creator_at(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_get_cursor"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_get_cursor"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_get_cursor(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_get_deep_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_loromovablelist_get_deep_value"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_get_deep_value(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_get_last_editor_at"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_"
                                        "loromovablelist_get_last_editor_at"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_get_last_editor_at(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_get_last_mover_at"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_"
                                        "loromovablelist_get_last_mover_at"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_get_last_mover_at(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_get_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_get_value"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromovablelist_get_value(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_id"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromovablelist_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_insert"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_insert"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromovablelist_insert(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_insert_counter_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_"
                                    "loromovablelist_insert_counter_container"),
      3,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_fn_method_loromovablelist_insert_counter_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_insert_list_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_method_"
                                    "loromovablelist_insert_list_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_insert_list_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_insert_map_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_"
                                        "loromovablelist_insert_map_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_insert_map_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_insert_movable_list_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_loro_rs_fn_method_loromovablelist_"
                                "insert_movable_list_container"),
      3,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_fn_method_loromovablelist_insert_movable_list_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_insert_text_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_method_"
                                    "loromovablelist_insert_text_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_insert_text_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_insert_tree_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_method_"
                                    "loromovablelist_insert_tree_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_insert_tree_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_is_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_is_attached"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_is_attached(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_is_deleted"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_is_deleted"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_is_deleted(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_is_empty"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_is_empty"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromovablelist_is_empty(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_len"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_len"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromovablelist_len(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_mov"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_mov"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromovablelist_mov(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_pop"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_pop"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromovablelist_pop(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_push"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_push"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromovablelist_push(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_set"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_set"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromovablelist_set(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_set_counter_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_method_"
                                    "loromovablelist_set_counter_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_set_counter_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_set_list_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_"
                                        "loromovablelist_set_list_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_set_list_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_set_map_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_"
                                        "loromovablelist_set_map_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_set_map_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_set_movable_list_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_loro_rs_fn_method_loromovablelist_"
                                "set_movable_list_container"),
      3,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_fn_method_loromovablelist_set_movable_list_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_set_text_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_"
                                        "loromovablelist_set_text_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_set_text_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_set_tree_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_"
                                        "loromovablelist_set_tree_container"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_loromovablelist_set_tree_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_loromovablelist_to_vec"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_loromovablelist_to_vec"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_loromovablelist_to_vec(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_lorotext"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_clone_lorotext"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_lorotext(rt, thisVal, args,
                                                              count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_lorotext"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_free_lorotext"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_lorotext(rt, thisVal, args,
                                                             count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_lorotext_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_lorotext_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_lorotext_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_apply_delta"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_apply_delta"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_apply_delta(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_delete"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_delete"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_delete(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_delete_utf8"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_delete_utf8"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_delete_utf8(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_doc"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_doc"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_doc(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_get_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_get_attached"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_get_attached(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_get_cursor"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_get_cursor"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_get_cursor(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_get_editor_at_unicode_pos"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_"
                                        "lorotext_get_editor_at_unicode_pos"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorotext_get_editor_at_unicode_pos(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_get_richtext_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_get_richtext_value"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorotext_get_richtext_value(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_id"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_id(rt, thisVal,
                                                                  args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_insert"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_insert"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_insert(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_insert_utf8"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_insert_utf8"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_insert_utf8(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_is_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_is_attached"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_is_attached(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_is_deleted"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_is_deleted"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_is_deleted(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_is_empty"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_is_empty"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_is_empty(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_len_unicode"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_len_unicode"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_len_unicode(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_len_utf16"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_len_utf16"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_len_utf16(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_len_utf8"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_len_utf8"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_len_utf8(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_mark"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_mark"),
          5,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_mark(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_push_str"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_push_str"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_push_str(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_slice"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_slice"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_slice(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_splice"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_splice"),
          4,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_splice(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_to_delta"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_to_delta"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_to_delta(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_to_string"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_to_string"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_to_string(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_unmark"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_unmark"),
          4,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_unmark(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_update"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_update"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_update(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotext_update_by_line"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotext_update_by_line"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotext_update_by_line(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_lorotree"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_clone_lorotree"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_lorotree(rt, thisVal, args,
                                                              count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_lorotree"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_free_lorotree"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_lorotree(rt, thisVal, args,
                                                             count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_lorotree_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_lorotree_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_lorotree_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_children"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_children"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_children(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_children_num"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_children_num"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_children_num(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_contains"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_contains"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_contains(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_create"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_create"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_create(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_create_at"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_create_at"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_create_at(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_delete"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_delete"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_delete(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_disable_fractional_index"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_"
                                        "lorotree_disable_fractional_index"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorotree_disable_fractional_index(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_doc"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_doc"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_doc(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_enable_fractional_index"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_lorotree_enable_fractional_index"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorotree_enable_fractional_index(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_fractional_index"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_fractional_index"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_fractional_index(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_get_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_get_attached"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_get_attached(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_get_last_move_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_get_last_move_id"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_get_last_move_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_get_meta"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_get_meta"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_get_meta(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_get_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_get_value"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_get_value(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_get_value_with_meta"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_get_value_with_meta"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorotree_get_value_with_meta(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_id"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_id(rt, thisVal,
                                                                  args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_is_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_is_attached"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_is_attached(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_is_deleted"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_is_deleted"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_is_deleted(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_is_fractional_index_enabled"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_"
                                        "lorotree_is_fractional_index_enabled"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorotree_is_fractional_index_enabled(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_is_node_deleted"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_is_node_deleted"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_is_node_deleted(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_mov"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_mov"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_mov(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_mov_after"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_mov_after"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_mov_after(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_mov_before"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_mov_before"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_mov_before(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_mov_to"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_mov_to"),
          4,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_mov_to(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_nodes"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_nodes"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_nodes(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_parent"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_parent"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_parent(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorotree_roots"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorotree_roots"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorotree_roots(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_lorounknown"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_clone_lorounknown"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_lorounknown(rt, thisVal,
                                                                 args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_lorounknown"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_free_lorounknown"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_lorounknown(rt, thisVal,
                                                                args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorounknown_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorounknown_id"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_lorounknown_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_lorovaluelike"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_lorovaluelike"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_lorovaluelike(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_lorovaluelike"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_free_lorovaluelike"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_lorovaluelike(rt, thisVal,
                                                                  args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_lorovaluelike_as_loro_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_lorovaluelike_as_loro_value"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_lorovaluelike_as_loro_value(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_onpop"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_clone_onpop"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_onpop(rt, thisVal, args,
                                                           count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_onpop"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_free_onpop"), 1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_onpop(rt, thisVal, args,
                                                          count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_onpop_on_pop"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_onpop_on_pop"),
          4,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_onpop_on_pop(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_onpush"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_clone_onpush"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_onpush(rt, thisVal, args,
                                                            count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_onpush"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_free_onpush"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_onpush(rt, thisVal, args,
                                                           count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_onpush_on_push"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_onpush_on_push"),
          4,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_onpush_on_push(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_precommitcallback"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_precommitcallback"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_precommitcallback(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_precommitcallback"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_free_precommitcallback"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_precommitcallback(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_precommitcallback_on_pre_commit"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_precommitcallback_on_pre_commit"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_precommitcallback_on_pre_commit(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_styleconfigmap"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_styleconfigmap"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_styleconfigmap(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_styleconfigmap"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_free_styleconfigmap"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_styleconfigmap(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_styleconfigmap_default_rich_text_"
        "config"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_constructor_"
                                    "styleconfigmap_default_rich_text_config"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_fn_constructor_styleconfigmap_default_rich_text_config(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_fn_constructor_styleconfigmap_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_styleconfigmap_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_styleconfigmap_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_styleconfigmap_get"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_styleconfigmap_get"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_styleconfigmap_get(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_styleconfigmap_insert"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_styleconfigmap_insert"),
          3,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_styleconfigmap_insert(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_subscriber"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_clone_subscriber"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_subscriber(rt, thisVal,
                                                                args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_subscriber"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_free_subscriber"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_subscriber(rt, thisVal,
                                                               args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_subscriber_on_diff"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_subscriber_on_diff"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_subscriber_on_diff(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_subscription"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_subscription"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_subscription(rt, thisVal,
                                                                  args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_subscription"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_free_subscription"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_subscription(rt, thisVal,
                                                                 args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_subscription_detach"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_subscription_detach"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_subscription_detach(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_subscription_unsubscribe"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_subscription_unsubscribe"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_subscription_unsubscribe(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_undomanager"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_clone_undomanager"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_undomanager(rt, thisVal,
                                                                 args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_undomanager"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_free_undomanager"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_undomanager(rt, thisVal,
                                                                args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_undomanager_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_undomanager_new"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_undomanager_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_undomanager_add_exclude_origin_prefix"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_method_undomanager_"
                                    "add_exclude_origin_prefix"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_undomanager_add_exclude_origin_prefix(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_undomanager_can_redo"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_undomanager_can_redo"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_undomanager_can_redo(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_undomanager_can_undo"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_undomanager_can_undo"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_undomanager_can_undo(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_undomanager_record_new_checkpoint"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_"
                                        "undomanager_record_new_checkpoint"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_undomanager_record_new_checkpoint(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_undomanager_redo"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_undomanager_redo"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_undomanager_redo(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_undomanager_set_max_undo_steps"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_undomanager_set_max_undo_steps"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_undomanager_set_max_undo_steps(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_undomanager_set_merge_interval"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_undomanager_set_merge_interval"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_undomanager_set_merge_interval(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_undomanager_set_on_pop"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_undomanager_set_on_pop"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_undomanager_set_on_pop(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_undomanager_set_on_push"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_undomanager_set_on_push"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_undomanager_set_on_push(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_undomanager_undo"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_undomanager_undo"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_undomanager_undo(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_unsubscriber"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_unsubscriber"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_unsubscriber(rt, thisVal,
                                                                  args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_unsubscriber"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_free_unsubscriber"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_unsubscriber(rt, thisVal,
                                                                 args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_unsubscriber_on_unsubscribe"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_unsubscriber_on_unsubscribe"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_unsubscriber_on_unsubscribe(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_valueorcontainer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_valueorcontainer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_valueorcontainer(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_valueorcontainer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_free_valueorcontainer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_valueorcontainer(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_container"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_counter"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_counter"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_counter(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_list"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_list"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_list(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_map"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_map"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_map(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_movable_list"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_method_"
                                    "valueorcontainer_as_loro_movable_list"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_movable_list(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_text"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_text"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_text(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_tree"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_tree"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_tree(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_unknown"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_unknown"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_unknown(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_valueorcontainer_as_value"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_value(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_valueorcontainer_container_type"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_valueorcontainer_container_type"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_valueorcontainer_container_type(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_valueorcontainer_is_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_valueorcontainer_is_container"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_valueorcontainer_is_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_valueorcontainer_is_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_valueorcontainer_is_value"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_valueorcontainer_is_value(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_clone_versionvector"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_clone_versionvector"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_clone_versionvector(rt, thisVal,
                                                                   args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_free_versionvector"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_free_versionvector"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_free_versionvector(rt, thisVal,
                                                                  args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_versionvector_decode"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_versionvector_decode"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_versionvector_decode(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_constructor_versionvector_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_constructor_versionvector_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_constructor_versionvector_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_versionvector_diff"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_versionvector_diff"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_versionvector_diff(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_versionvector_encode"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_versionvector_encode"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_versionvector_encode(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_versionvector_eq"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_versionvector_eq"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_versionvector_eq(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_versionvector_extend_to_include_vv"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_method_"
                                        "versionvector_extend_to_include_vv"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_versionvector_extend_to_include_vv(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_versionvector_get_last"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_versionvector_get_last"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_versionvector_get_last(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_versionvector_get_missing_span"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_method_versionvector_get_missing_span"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_versionvector_get_missing_span(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_versionvector_includes_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_versionvector_includes_id"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_versionvector_includes_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_versionvector_includes_vv"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_versionvector_includes_vv"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_versionvector_includes_vv(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_versionvector_intersect_span"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_versionvector_intersect_span"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_method_versionvector_intersect_span(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_versionvector_merge"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_versionvector_merge"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_versionvector_merge(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_versionvector_partial_cmp"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_versionvector_partial_cmp"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_versionvector_partial_cmp(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_versionvector_set_end"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_versionvector_set_end"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_versionvector_set_end(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_method_versionvector_set_last"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_method_versionvector_set_last"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_method_versionvector_set_last(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_func_decode_import_blob_meta"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_func_decode_import_blob_meta"),
          2,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_func_decode_import_blob_meta(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_func_get_version"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_fn_func_get_version"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_func_get_version(rt, thisVal,
                                                                args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_func_decode_import_blob_meta"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_func_decode_import_blob_meta"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_func_decode_import_blob_meta(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_func_get_version"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_func_get_version"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_func_get_version(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_awareness_apply"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_awareness_apply"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_awareness_apply(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_awareness_encode"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_awareness_encode"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_awareness_encode(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_awareness_encode_all"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_awareness_encode_all"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_awareness_encode_all(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_awareness_get_all_states"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_awareness_get_all_states"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_awareness_get_all_states(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_awareness_get_local_state"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_awareness_get_local_state"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_awareness_get_local_state(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_awareness_peer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_awareness_peer"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_awareness_peer(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_awareness_remove_outdated"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_awareness_remove_outdated"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_awareness_remove_outdated(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_awareness_set_local_state"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_awareness_set_local_state"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_awareness_set_local_state(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_changeancestorstraveler_travel"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "changeancestorstraveler_travel"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_changeancestorstraveler_travel(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_changemodifier_set_message"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_changemodifier_set_message"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_changemodifier_set_message(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_changemodifier_set_timestamp"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "changemodifier_set_timestamp"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_changemodifier_set_timestamp(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_configure_fork"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_configure_fork"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_configure_fork(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_configure_merge_interval"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_configure_merge_interval"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_configure_merge_interval(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_configure_record_timestamp"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_configure_record_timestamp"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_configure_record_timestamp(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_configure_set_merge_interval"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "configure_set_merge_interval"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_configure_set_merge_interval(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_configure_set_record_timestamp"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "configure_set_record_timestamp"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_configure_set_record_timestamp(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_configure_text_style_config"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "configure_text_style_config"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_configure_text_style_config(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_containeridlike_as_container_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "containeridlike_as_container_id"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_containeridlike_as_container_id(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_diffbatch_get_diff"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_diffbatch_get_diff"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_diffbatch_get_diff(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_diffbatch_push"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_diffbatch_push"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_diffbatch_push(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_apply"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_apply"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_ephemeralstore_apply(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_delete"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_delete"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_ephemeralstore_delete(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_encode"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_encode"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_ephemeralstore_encode(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_encode_all"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_encode_all"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_ephemeralstore_encode_all(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_get"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_get"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_ephemeralstore_get(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_get_all_states"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "ephemeralstore_get_all_states"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_ephemeralstore_get_all_states(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_keys"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_keys"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_ephemeralstore_keys(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_remove_outdated"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "ephemeralstore_remove_outdated"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_ephemeralstore_remove_outdated(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_set"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_set"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_ephemeralstore_set(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_subscribe"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_subscribe"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_ephemeralstore_subscribe(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_ephemeralstore_subscribe_local_"
        "update"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "ephemeralstore_subscribe_local_update"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_ephemeralstore_subscribe_local_update(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_ephemeralsubscriber_on_ephemeral_"
        "event"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "ephemeralsubscriber_on_ephemeral_event"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_ephemeralsubscriber_on_ephemeral_event(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_firstcommitfrompeercallback_on_"
        "first_commit_from_peer"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_loro_rs_checksum_method_firstcommitfrompeercallback_"
              "on_first_commit_from_peer"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_firstcommitfrompeercallback_on_first_commit_from_peer(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_fractionalindex_to_string"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_fractionalindex_to_string"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_fractionalindex_to_string(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_frontiers_encode"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_frontiers_encode"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_frontiers_encode(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_frontiers_eq"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_frontiers_eq"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_frontiers_eq(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_localephemerallistener_on_"
        "ephemeral_update"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_loro_rs_checksum_method_"
                                "localephemerallistener_on_ephemeral_update"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_localephemerallistener_on_ephemeral_update(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_localupdatecallback_on_local_"
        "update"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "localupdatecallback_on_local_update"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_localupdatecallback_on_local_update(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_lorocounter_decrement"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorocounter_decrement"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorocounter_decrement(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorocounter_doc"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorocounter_doc"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorocounter_doc(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorocounter_get_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorocounter_get_attached"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorocounter_get_attached(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorocounter_get_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorocounter_get_value"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorocounter_get_value(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorocounter_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorocounter_id"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorocounter_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorocounter_increment"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorocounter_increment"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorocounter_increment(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorocounter_is_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorocounter_is_attached"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorocounter_is_attached(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorocounter_is_deleted"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorocounter_is_deleted"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorocounter_is_deleted(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_apply_diff"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_apply_diff"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_apply_diff(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_attach"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_attach"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_attach(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_check_state_correctness_"
        "slow"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "lorodoc_check_state_correctness_slow"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_lorodoc_check_state_correctness_slow(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_checkout"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_checkout"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_checkout(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_checkout_to_latest"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_checkout_to_latest"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_checkout_to_latest(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_clear_next_commit_"
        "options"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "lorodoc_clear_next_commit_options"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_lorodoc_clear_next_commit_options(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_cmp_with_frontiers"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_cmp_with_frontiers"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_cmp_with_frontiers(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_commit"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_commit"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_commit(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_commit_with"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_commit_with"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_commit_with(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_compact_change_store"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_compact_change_store"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_compact_change_store(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_config"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_config"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_config(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_config_default_text_"
        "style"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "lorodoc_config_default_text_style"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_lorodoc_config_default_text_style(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_config_text_style"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_config_text_style"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_config_text_style(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_detach"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_detach"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_detach(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_diff"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_diff"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_diff(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_export_json_in_id_span"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_export_json_in_id_span"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_export_json_in_id_span(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_export_json_updates"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_export_json_updates"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_export_json_updates(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_export_json_updates_"
        "without_peer_compression"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_loro_rs_checksum_method_lorodoc_"
                                "export_json_updates_without_peer_compression"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_lorodoc_export_json_updates_without_peer_compression(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_export_shallow_snapshot"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_export_shallow_snapshot"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_export_shallow_snapshot(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_export_snapshot"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_export_snapshot"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_export_snapshot(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_export_snapshot_at"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_export_snapshot_at"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_export_snapshot_at(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_export_state_only"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_export_state_only"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_export_state_only(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_export_updates"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_export_updates"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_export_updates(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_export_updates_in_range"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_export_updates_in_range"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_export_updates_in_range(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_find_id_spans_between"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_find_id_spans_between"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_find_id_spans_between(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_fork"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_fork"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_fork(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_fork_at"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_fork_at"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_fork_at(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_free_diff_calculator"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_free_diff_calculator"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_free_diff_calculator(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_free_history_cache"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_free_history_cache"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_free_history_cache(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_frontiers_to_vv"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_frontiers_to_vv"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_frontiers_to_vv(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_by_path"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_by_path"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_get_by_path(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_by_str_path"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_by_str_path"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_get_by_str_path(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_change"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_change"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_get_change(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_changed_containers_"
        "in"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "lorodoc_get_changed_containers_in"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_lorodoc_get_changed_containers_in(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_counter"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_counter"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_get_counter(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_cursor_pos"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_cursor_pos"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_get_cursor_pos(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_deep_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_deep_value"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_get_deep_value(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_deep_value_with_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_get_deep_value_with_id"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_get_deep_value_with_id(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_list"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_list"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_get_list(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_map"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_map"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_get_map(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_movable_list"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_movable_list"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_get_movable_list(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_path_to_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_get_path_to_container"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_get_path_to_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_pending_txn_len"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_get_pending_txn_len"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_get_pending_txn_len(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_text"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_text"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_get_text(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_tree"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_tree"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_get_tree(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_get_value"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_get_value(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_has_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_has_container"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_has_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_has_history_cache"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_has_history_cache"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_has_history_cache(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_import"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_import"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_import(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_import_batch"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_import_batch"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_import_batch(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_import_json_updates"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_import_json_updates"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_import_json_updates(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_import_with"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_import_with"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_import_with(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_is_detached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_is_detached"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_is_detached(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_is_shallow"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_is_shallow"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_is_shallow(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_jsonpath"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_jsonpath"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_jsonpath(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_len_changes"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_len_changes"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_len_changes(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_len_ops"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_len_ops"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_len_ops(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_log_estimate_size"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_log_estimate_size"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_log_estimate_size(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_minimize_frontiers"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_minimize_frontiers"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_minimize_frontiers(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_oplog_frontiers"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_oplog_frontiers"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_oplog_frontiers(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_oplog_vv"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_oplog_vv"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_oplog_vv(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_peer_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_peer_id"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_peer_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_revert_to"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_revert_to"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_revert_to(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_set_change_merge_"
        "interval"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "lorodoc_set_change_merge_interval"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_lorodoc_set_change_merge_interval(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_message"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_set_next_commit_message"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_message(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_options"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_set_next_commit_options"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_options(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_origin"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_set_next_commit_origin"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_origin(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_"
        "timestamp"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "lorodoc_set_next_commit_timestamp"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_timestamp(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_set_peer_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_set_peer_id"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_set_peer_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_set_record_timestamp"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_set_record_timestamp"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_set_record_timestamp(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_shallow_since_vv"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_shallow_since_vv"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_shallow_since_vv(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_state_frontiers"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_state_frontiers"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_state_frontiers(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_state_vv"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_state_vv"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_state_vv(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_subscribe"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_subscribe"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorodoc_subscribe(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_subscribe_first_commit_"
        "from_peer"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "lorodoc_subscribe_first_commit_from_peer"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_lorodoc_subscribe_first_commit_from_peer(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_subscribe_local_update"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_subscribe_local_update"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_subscribe_local_update(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_subscribe_pre_commit"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_subscribe_pre_commit"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_subscribe_pre_commit(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_subscribe_root"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorodoc_subscribe_root"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_subscribe_root(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_travel_change_ancestors"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorodoc_travel_change_ancestors"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_travel_change_ancestors(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorodoc_vv_to_frontiers"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorodoc_vv_to_frontiers"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorodoc_vv_to_frontiers(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_clear"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_clear"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorolist_clear(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_delete"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_delete"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorolist_delete(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_doc"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_doc"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorolist_doc(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_get"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_get"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorolist_get(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_get_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_get_attached"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorolist_get_attached(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_get_cursor"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_get_cursor"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorolist_get_cursor(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_get_deep_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorolist_get_deep_value"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorolist_get_deep_value(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_get_id_at"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_get_id_at"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorolist_get_id_at(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_get_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_get_value"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorolist_get_value(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_id"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorolist_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_insert"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_insert"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorolist_insert(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_insert_counter_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "lorolist_insert_counter_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_lorolist_insert_counter_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_insert_list_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorolist_insert_list_container"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorolist_insert_list_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_insert_map_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorolist_insert_map_container"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorolist_insert_map_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_insert_movable_list_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "lorolist_insert_movable_list_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_lorolist_insert_movable_list_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_insert_text_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorolist_insert_text_container"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorolist_insert_text_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_insert_tree_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorolist_insert_tree_container"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorolist_insert_tree_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_is_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_is_attached"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorolist_is_attached(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_is_deleted"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_is_deleted"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorolist_is_deleted(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_is_empty"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_is_empty"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorolist_is_empty(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_len"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_len"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorolist_len(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_pop"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_pop"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorolist_pop(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_push"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_push"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorolist_push(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorolist_to_vec"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorolist_to_vec"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorolist_to_vec(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_clear"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromap_clear"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromap_clear(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_delete"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromap_delete"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromap_delete(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_doc"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromap_doc"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromap_doc(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_get"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromap_get"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromap_get(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_get_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromap_get_attached"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromap_get_attached(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_get_deep_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromap_get_deep_value"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromap_get_deep_value(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_get_last_editor"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_loromap_get_last_editor"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromap_get_last_editor(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_get_or_create_counter_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromap_get_or_create_counter_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromap_get_or_create_counter_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_get_or_create_list_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromap_get_or_create_list_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromap_get_or_create_list_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_get_or_create_map_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromap_get_or_create_map_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromap_get_or_create_map_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_get_or_create_movable_"
        "list_container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_loro_rs_checksum_method_loromap_"
                                "get_or_create_movable_list_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromap_get_or_create_movable_list_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_get_or_create_text_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromap_get_or_create_text_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromap_get_or_create_text_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_get_or_create_tree_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromap_get_or_create_tree_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromap_get_or_create_tree_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_get_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromap_get_value"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromap_get_value(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromap_id"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromap_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_insert"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromap_insert"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromap_insert(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_insert_counter_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromap_insert_counter_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromap_insert_counter_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_insert_list_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "loromap_insert_list_container"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromap_insert_list_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_insert_map_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "loromap_insert_map_container"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromap_insert_map_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_insert_movable_list_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromap_insert_movable_list_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromap_insert_movable_list_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_insert_text_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "loromap_insert_text_container"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromap_insert_text_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_insert_tree_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "loromap_insert_tree_container"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromap_insert_tree_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_is_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromap_is_attached"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromap_is_attached(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_is_deleted"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromap_is_deleted"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromap_is_deleted(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_is_empty"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromap_is_empty"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromap_is_empty(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_keys"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromap_keys"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromap_keys(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_len"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromap_len"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromap_len(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromap_values"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromap_values"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromap_values(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_clear"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_clear"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_clear(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_delete"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_delete"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_delete(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_doc"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_doc"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromovablelist_doc(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_get"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_get"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromovablelist_get(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_get_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "loromovablelist_get_attached"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_get_attached(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_get_creator_at"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "loromovablelist_get_creator_at"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_get_creator_at(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_get_cursor"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_get_cursor"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_get_cursor(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_get_deep_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "loromovablelist_get_deep_value"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_get_deep_value(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_get_last_editor_"
        "at"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromovablelist_get_last_editor_at"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_get_last_editor_at(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_get_last_mover_"
        "at"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromovablelist_get_last_mover_at"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_get_last_mover_at(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_get_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_get_value"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_get_value(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_id"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromovablelist_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_insert"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_insert"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_insert(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_insert_counter_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromovablelist_insert_counter_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_insert_counter_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_insert_list_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromovablelist_insert_list_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_insert_list_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_insert_map_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromovablelist_insert_map_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_insert_map_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_insert_movable_"
        "list_container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_insert_"
              "movable_list_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_insert_movable_list_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_insert_text_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromovablelist_insert_text_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_insert_text_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_insert_tree_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromovablelist_insert_tree_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_insert_tree_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_is_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "loromovablelist_is_attached"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_is_attached(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_is_deleted"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_is_deleted"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_is_deleted(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_is_empty"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_is_empty"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_is_empty(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_len"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_len"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromovablelist_len(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_mov"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_mov"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromovablelist_mov(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_pop"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_pop"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromovablelist_pop(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_push"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_push"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_push(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_set"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_set"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_loromovablelist_set(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_set_counter_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromovablelist_set_counter_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_set_counter_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_set_list_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromovablelist_set_list_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_set_list_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_set_map_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromovablelist_set_map_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_set_map_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_set_movable_list_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_loro_rs_checksum_method_"
                                "loromovablelist_set_movable_list_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_set_movable_list_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_set_text_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromovablelist_set_text_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_set_text_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_set_tree_"
        "container"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "loromovablelist_set_tree_container"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_set_tree_container(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_loromovablelist_to_vec"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_loromovablelist_to_vec"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_loromovablelist_to_vec(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_apply_delta"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_apply_delta"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorotext_apply_delta(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_delete"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_delete"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_delete(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_delete_utf8"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_delete_utf8"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorotext_delete_utf8(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_doc"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_doc"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_doc(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_get_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_get_attached"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorotext_get_attached(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_get_cursor"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_get_cursor"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_get_cursor(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_get_editor_at_unicode_"
        "pos"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "lorotext_get_editor_at_unicode_pos"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_lorotext_get_editor_at_unicode_pos(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_get_richtext_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorotext_get_richtext_value"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorotext_get_richtext_value(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_id"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_insert"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_insert"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_insert(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_insert_utf8"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_insert_utf8"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorotext_insert_utf8(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_is_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_is_attached"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorotext_is_attached(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_is_deleted"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_is_deleted"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_is_deleted(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_is_empty"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_is_empty"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_is_empty(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_len_unicode"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_len_unicode"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorotext_len_unicode(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_len_utf16"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_len_utf16"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_len_utf16(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_len_utf8"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_len_utf8"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_len_utf8(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_mark"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_mark"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_mark(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_push_str"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_push_str"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_push_str(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_slice"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_slice"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_slice(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_splice"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_splice"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_splice(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_to_delta"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_to_delta"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_to_delta(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_to_string"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_to_string"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_to_string(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_unmark"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_unmark"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_unmark(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_update"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotext_update"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotext_update(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotext_update_by_line"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorotext_update_by_line"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorotext_update_by_line(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_children"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_children"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_children(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_children_num"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_children_num"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorotree_children_num(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_contains"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_contains"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_contains(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_create"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_create"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_create(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_create_at"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_create_at"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_create_at(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_delete"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_delete"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_delete(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_disable_fractional_"
        "index"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "lorotree_disable_fractional_index"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_lorotree_disable_fractional_index(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_doc"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_doc"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_doc(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_enable_fractional_"
        "index"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "lorotree_enable_fractional_index"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_lorotree_enable_fractional_index(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_fractional_index"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorotree_fractional_index"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorotree_fractional_index(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_get_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_get_attached"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorotree_get_attached(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_get_last_move_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorotree_get_last_move_id"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorotree_get_last_move_id(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_get_meta"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_get_meta"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_get_meta(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_get_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_get_value"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_get_value(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_get_value_with_meta"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorotree_get_value_with_meta"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorotree_get_value_with_meta(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_id"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_is_attached"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_is_attached"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorotree_is_attached(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_is_deleted"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_is_deleted"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_is_deleted(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_is_fractional_index_"
        "enabled"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "lorotree_is_fractional_index_enabled"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_lorotree_is_fractional_index_enabled(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_is_node_deleted"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_lorotree_is_node_deleted"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorotree_is_node_deleted(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_mov"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_mov"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_mov(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_mov_after"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_mov_after"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_mov_after(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_mov_before"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_mov_before"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_mov_before(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_mov_to"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_mov_to"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_mov_to(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_nodes"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_nodes"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_nodes(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_parent"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_parent"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_parent(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorotree_roots"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorotree_roots"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorotree_roots(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorounknown_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_lorounknown_id"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_lorounknown_id(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_lorovaluelike_as_loro_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "lorovaluelike_as_loro_value"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_lorovaluelike_as_loro_value(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_onpop_on_pop"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_onpop_on_pop"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_onpop_on_pop(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_onpush_on_push"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_onpush_on_push"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_onpush_on_push(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_precommitcallback_on_pre_commit"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "precommitcallback_on_pre_commit"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_precommitcallback_on_pre_commit(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_styleconfigmap_get"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_styleconfigmap_get"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_styleconfigmap_get(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_styleconfigmap_insert"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_styleconfigmap_insert"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_styleconfigmap_insert(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_subscriber_on_diff"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_subscriber_on_diff"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_subscriber_on_diff(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_subscription_detach"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_subscription_detach"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_subscription_detach(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_subscription_unsubscribe"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_subscription_unsubscribe"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_subscription_unsubscribe(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_undomanager_add_exclude_origin_"
        "prefix"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "undomanager_add_exclude_origin_prefix"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_undomanager_add_exclude_origin_prefix(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_undomanager_can_redo"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_undomanager_can_redo"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_undomanager_can_redo(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_undomanager_can_undo"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_undomanager_can_undo"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_undomanager_can_undo(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_undomanager_record_new_"
        "checkpoint"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "undomanager_record_new_checkpoint"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_undomanager_record_new_checkpoint(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_undomanager_redo"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_undomanager_redo"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_undomanager_redo(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_undomanager_set_max_undo_steps"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "undomanager_set_max_undo_steps"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_undomanager_set_max_undo_steps(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_undomanager_set_merge_interval"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "undomanager_set_merge_interval"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_undomanager_set_merge_interval(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_undomanager_set_on_pop"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_undomanager_set_on_pop"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_undomanager_set_on_pop(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_undomanager_set_on_push"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_undomanager_set_on_push"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_undomanager_set_on_push(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_undomanager_undo"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_undomanager_undo"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_undomanager_undo(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_unsubscriber_on_unsubscribe"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "unsubscriber_on_unsubscribe"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_unsubscriber_on_unsubscribe(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_valueorcontainer_as_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "valueorcontainer_as_container"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_"
        "counter"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "valueorcontainer_as_loro_counter"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_counter(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_list"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "valueorcontainer_as_loro_list"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_list(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_map"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "valueorcontainer_as_loro_map"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_map(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_movable_"
        "list"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "valueorcontainer_as_loro_movable_list"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_movable_list(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_text"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "valueorcontainer_as_loro_text"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_text(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_tree"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "valueorcontainer_as_loro_tree"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_tree(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_"
        "unknown"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "valueorcontainer_as_loro_unknown"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_unknown(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_valueorcontainer_as_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_valueorcontainer_as_value"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_value(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_valueorcontainer_container_type"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "valueorcontainer_container_type"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_valueorcontainer_container_type(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_valueorcontainer_is_container"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "valueorcontainer_is_container"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_valueorcontainer_is_container(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_valueorcontainer_is_value"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_valueorcontainer_is_value"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_valueorcontainer_is_value(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_versionvector_diff"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_versionvector_diff"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_versionvector_diff(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_versionvector_encode"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_versionvector_encode"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_versionvector_encode(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_versionvector_eq"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_versionvector_eq"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_versionvector_eq(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_versionvector_extend_to_include_"
        "vv"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                    "versionvector_extend_to_include_vv"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_method_versionvector_extend_to_include_vv(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_method_versionvector_get_last"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_versionvector_get_last"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_versionvector_get_last(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_versionvector_get_missing_span"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "versionvector_get_missing_span"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_versionvector_get_missing_span(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_versionvector_includes_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_versionvector_includes_id"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_versionvector_includes_id(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_versionvector_includes_vv"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_versionvector_includes_vv"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_versionvector_includes_vv(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_versionvector_intersect_span"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_method_"
                                        "versionvector_intersect_span"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_versionvector_intersect_span(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_versionvector_merge"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_versionvector_merge"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_method_versionvector_merge(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_versionvector_partial_cmp"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_method_versionvector_partial_cmp"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_versionvector_partial_cmp(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_versionvector_set_end"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_versionvector_set_end"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_versionvector_set_end(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_method_versionvector_set_last"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_method_versionvector_set_last"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_method_versionvector_set_last(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_awareness_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_constructor_awareness_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_constructor_awareness_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_cursor_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_constructor_cursor_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_constructor_cursor_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_diffbatch_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_constructor_diffbatch_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_constructor_diffbatch_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_ephemeralstore_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_constructor_ephemeralstore_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_constructor_ephemeralstore_new(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_fractionalindex_from_bytes"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_uniffi_loro_rs_checksum_constructor_"
                                    "fractionalindex_from_bytes"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_constructor_fractionalindex_from_bytes(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_fractionalindex_from_hex_"
        "string"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_constructor_"
                                    "fractionalindex_from_hex_string"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_constructor_fractionalindex_from_hex_string(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_constructor_frontiers_decode"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_constructor_frontiers_decode"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_constructor_frontiers_decode(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_frontiers_from_id"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_constructor_frontiers_from_id"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_constructor_frontiers_from_id(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_frontiers_from_ids"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_constructor_frontiers_from_ids"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_constructor_frontiers_from_ids(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_frontiers_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_constructor_frontiers_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_constructor_frontiers_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_lorocounter_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_constructor_lorocounter_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_constructor_lorocounter_new(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_lorodoc_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_constructor_lorodoc_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_constructor_lorodoc_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_lorolist_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_constructor_lorolist_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_constructor_lorolist_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_loromap_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_constructor_loromap_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_constructor_loromap_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_loromovablelist_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_constructor_loromovablelist_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_constructor_loromovablelist_new(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_lorotext_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_constructor_lorotext_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_constructor_lorotext_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_lorotree_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_constructor_lorotree_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_checksum_constructor_lorotree_new(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_styleconfigmap_default_rich_"
        "text_config"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_checksum_constructor_"
                                    "styleconfigmap_default_rich_text_config"),
      0,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_checksum_constructor_styleconfigmap_default_rich_text_config(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_checksum_constructor_styleconfigmap_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_constructor_styleconfigmap_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_constructor_styleconfigmap_new(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_undomanager_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_constructor_undomanager_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_constructor_undomanager_new(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_versionvector_decode"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_checksum_constructor_versionvector_decode"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_constructor_versionvector_decode(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_checksum_constructor_versionvector_new"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_checksum_constructor_versionvector_new"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_checksum_constructor_versionvector_new(
                    rt, thisVal, args, count);
          });
  props["ubrn_ffi_loro_rs_uniffi_contract_version"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt,
                                    "ubrn_ffi_loro_rs_uniffi_contract_version"),
          0,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_ffi_loro_rs_uniffi_contract_version(rt, thisVal,
                                                                 args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_init_callback_vtable_changeancestorstraveler"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_init_callback_"
                                        "vtable_changeancestorstraveler"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_init_callback_vtable_changeancestorstraveler(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_init_callback_vtable_containeridlike"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_init_callback_vtable_containeridlike"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_init_callback_vtable_containeridlike(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_init_callback_vtable_ephemeralsubscriber"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_init_callback_"
                                        "vtable_ephemeralsubscriber"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_init_callback_vtable_ephemeralsubscriber(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_init_callback_vtable_"
        "firstcommitfrompeercallback"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_init_callback_"
                                    "vtable_firstcommitfrompeercallback"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_loro_rs_fn_init_callback_vtable_firstcommitfrompeercallback(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_loro_rs_fn_init_callback_vtable_localephemerallistener"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_init_callback_"
                                        "vtable_localephemerallistener"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_init_callback_vtable_localephemerallistener(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_init_callback_vtable_localupdatecallback"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_loro_rs_fn_init_callback_"
                                        "vtable_localupdatecallback"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_init_callback_vtable_localupdatecallback(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_init_callback_vtable_lorovaluelike"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_init_callback_vtable_lorovaluelike"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_init_callback_vtable_lorovaluelike(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_init_callback_vtable_onpop"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_init_callback_vtable_onpop"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_init_callback_vtable_onpop(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_init_callback_vtable_onpush"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_init_callback_vtable_onpush"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_init_callback_vtable_onpush(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_init_callback_vtable_precommitcallback"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_loro_rs_fn_init_callback_vtable_precommitcallback"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_init_callback_vtable_precommitcallback(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_init_callback_vtable_subscriber"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_init_callback_vtable_subscriber"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_loro_rs_fn_init_callback_vtable_subscriber(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_loro_rs_fn_init_callback_vtable_unsubscriber"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_loro_rs_fn_init_callback_vtable_unsubscriber"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_loro_rs_fn_init_callback_vtable_unsubscriber(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_awareness_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_internal_fn_method_awareness_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_awareness_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_changeancestorstraveler_ffi__bless_"
        "pointer"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_internal_fn_method_"
                                "changeancestorstraveler_ffi__bless_pointer"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_internal_fn_method_changeancestorstraveler_ffi__bless_pointer(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_internal_fn_method_changemodifier_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                        "changemodifier_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_changemodifier_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_configure_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_internal_fn_method_configure_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_configure_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_containeridlike_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                        "containeridlike_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_containeridlike_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_cursor_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_method_cursor_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_cursor_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_diffbatch_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_internal_fn_method_diffbatch_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_diffbatch_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_ephemeralstore_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                        "ephemeralstore_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_ephemeralstore_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_ephemeralsubscriber_ffi__bless_"
        "pointer"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                    "ephemeralsubscriber_ffi__bless_pointer"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_internal_fn_method_ephemeralsubscriber_ffi__bless_pointer(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_internal_fn_method_firstcommitfrompeercallback_ffi__bless_"
        "pointer"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(
          rt, "ubrn_uniffi_internal_fn_method_firstcommitfrompeercallback_ffi__"
              "bless_pointer"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_internal_fn_method_firstcommitfrompeercallback_ffi__bless_pointer(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_internal_fn_method_fractionalindex_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                        "fractionalindex_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_fractionalindex_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_frontiers_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_internal_fn_method_frontiers_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_frontiers_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_localephemerallistener_ffi__bless_"
        "pointer"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt,
                                "ubrn_uniffi_internal_fn_method_"
                                "localephemerallistener_ffi__bless_pointer"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_internal_fn_method_localephemerallistener_ffi__bless_pointer(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_internal_fn_method_localupdatecallback_ffi__bless_"
        "pointer"] = jsi::Function::createFromHostFunction(
      rt,
      jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                    "localupdatecallback_ffi__bless_pointer"),
      1,
      [this](jsi::Runtime &rt, const jsi::Value &thisVal,
             const jsi::Value *args, size_t count) -> jsi::Value {
        return this
            ->cpp_uniffi_internal_fn_method_localupdatecallback_ffi__bless_pointer(
                rt, thisVal, args, count);
      });
  props["ubrn_uniffi_internal_fn_method_lorocounter_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_internal_fn_method_lorocounter_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_lorocounter_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_lorodoc_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_method_lorodoc_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_lorodoc_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_lorolist_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_method_lorolist_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_lorolist_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_loromap_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_method_loromap_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_loromap_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_loromovablelist_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                        "loromovablelist_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_loromovablelist_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_lorotext_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_method_lorotext_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_lorotext_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_lorotree_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_method_lorotree_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_lorotree_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_lorounknown_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_internal_fn_method_lorounknown_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_lorounknown_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_lorovaluelike_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                        "lorovaluelike_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_lorovaluelike_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_onpop_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_method_onpop_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this->cpp_uniffi_internal_fn_method_onpop_ffi__bless_pointer(
                rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_onpush_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt, "ubrn_uniffi_internal_fn_method_onpush_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_onpush_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_precommitcallback_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                        "precommitcallback_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_precommitcallback_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_styleconfigmap_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                        "styleconfigmap_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_styleconfigmap_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_subscriber_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_internal_fn_method_subscriber_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_subscriber_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_subscription_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_internal_fn_method_subscription_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_subscription_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_undomanager_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_internal_fn_method_undomanager_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_undomanager_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_unsubscriber_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(
              rt,
              "ubrn_uniffi_internal_fn_method_unsubscriber_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_unsubscriber_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_valueorcontainer_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                        "valueorcontainer_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_valueorcontainer_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
  props["ubrn_uniffi_internal_fn_method_versionvector_ffi__bless_pointer"] =
      jsi::Function::createFromHostFunction(
          rt,
          jsi::PropNameID::forAscii(rt, "ubrn_uniffi_internal_fn_method_"
                                        "versionvector_ffi__bless_pointer"),
          1,
          [this](jsi::Runtime &rt, const jsi::Value &thisVal,
                 const jsi::Value *args, size_t count) -> jsi::Value {
            return this
                ->cpp_uniffi_internal_fn_method_versionvector_ffi__bless_pointer(
                    rt, thisVal, args, count);
          });
}

void NativeLoro::registerModule(
    jsi::Runtime &rt, std::shared_ptr<react::CallInvoker> callInvoker) {
  auto invoker =
      std::make_shared<uniffi_runtime::UniffiCallInvoker>(callInvoker);
  auto tm = std::make_shared<NativeLoro>(rt, invoker);
  auto obj = rt.global().createFromHostObject(rt, tm);
  rt.global().setProperty(rt, "NativeLoro", obj);
}

void NativeLoro::unregisterModule(jsi::Runtime &rt) {
  uniffi::loro::registry::clearRegistry();
}

jsi::Value NativeLoro::get(jsi::Runtime &rt, const jsi::PropNameID &name) {
  try {
    return jsi::Value(rt, props.at(name.utf8(rt)));
  } catch (std::out_of_range &e) {
    return jsi::Value::undefined();
  }
}

std::vector<jsi::PropNameID> NativeLoro::getPropertyNames(jsi::Runtime &rt) {
  std::vector<jsi::PropNameID> rval;
  for (auto &[key, value] : props) {
    rval.push_back(jsi::PropNameID::forUtf8(rt, key));
  }
  return rval;
}

void NativeLoro::set(jsi::Runtime &rt, const jsi::PropNameID &name,
                     const jsi::Value &value) {
  props.insert_or_assign(name.utf8(rt), &value);
}

NativeLoro::~NativeLoro() {
  // Cleanup for callback function RustFutureContinuationCallback
  uniffi::loro::cb::rustfuturecontinuationcallback::cleanup();
  // Cleanup for "free" callback function CallbackInterfaceFree
  uniffi::loro::st::foreignfuture::foreignfuture::free::cleanup();
  uniffi::loro::st::vtablecallbackinterfacechangeancestorstraveler::
      vtablecallbackinterfacechangeancestorstraveler::free::cleanup();
  uniffi::loro::st::vtablecallbackinterfacecontaineridlike::
      vtablecallbackinterfacecontaineridlike::free::cleanup();
  uniffi::loro::st::vtablecallbackinterfaceephemeralsubscriber::
      vtablecallbackinterfaceephemeralsubscriber::free::cleanup();
  uniffi::loro::st::vtablecallbackinterfacefirstcommitfrompeercallback::
      vtablecallbackinterfacefirstcommitfrompeercallback::free::cleanup();
  uniffi::loro::st::vtablecallbackinterfacelocalephemerallistener::
      vtablecallbackinterfacelocalephemerallistener::free::cleanup();
  uniffi::loro::st::vtablecallbackinterfacelocalupdatecallback::
      vtablecallbackinterfacelocalupdatecallback::free::cleanup();
  uniffi::loro::st::vtablecallbackinterfacelorovaluelike::
      vtablecallbackinterfacelorovaluelike::free::cleanup();
  uniffi::loro::st::vtablecallbackinterfaceonpop::vtablecallbackinterfaceonpop::
      free::cleanup();
  uniffi::loro::st::vtablecallbackinterfaceonpush::
      vtablecallbackinterfaceonpush::free::cleanup();
  uniffi::loro::st::vtablecallbackinterfaceprecommitcallback::
      vtablecallbackinterfaceprecommitcallback::free::cleanup();
  uniffi::loro::st::vtablecallbackinterfacesubscriber::
      vtablecallbackinterfacesubscriber::free::cleanup();
  uniffi::loro::st::vtablecallbackinterfaceunsubscriber::
      vtablecallbackinterfaceunsubscriber::free::cleanup();
  uniffi::loro::st::vtablecallbackinterfacevalueorcontainer::
      vtablecallbackinterfacevalueorcontainer::free::cleanup();
  // Cleanup for callback function
  // CallbackInterfaceChangeAncestorsTravelerMethod0
  uniffi::loro::cb::callbackinterfacechangeancestorstravelermethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceContainerIdLikeMethod0
  uniffi::loro::cb::callbackinterfacecontaineridlikemethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceEphemeralSubscriberMethod0
  uniffi::loro::cb::callbackinterfaceephemeralsubscribermethod0::cleanup();
  // Cleanup for callback function
  // CallbackInterfaceFirstCommitFromPeerCallbackMethod0
  uniffi::loro::cb::callbackinterfacefirstcommitfrompeercallbackmethod0::
      cleanup();
  // Cleanup for callback function
  // CallbackInterfaceLocalEphemeralListenerMethod0
  uniffi::loro::cb::callbackinterfacelocalephemerallistenermethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceLocalUpdateCallbackMethod0
  uniffi::loro::cb::callbackinterfacelocalupdatecallbackmethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceLoroValueLikeMethod0
  uniffi::loro::cb::callbackinterfacelorovaluelikemethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceOnPopMethod0
  uniffi::loro::cb::callbackinterfaceonpopmethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceOnPushMethod0
  uniffi::loro::cb::callbackinterfaceonpushmethod0::cleanup();
  // Cleanup for callback function CallbackInterfacePreCommitCallbackMethod0
  uniffi::loro::cb::callbackinterfaceprecommitcallbackmethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceSubscriberMethod0
  uniffi::loro::cb::callbackinterfacesubscribermethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceUnsubscriberMethod0
  uniffi::loro::cb::callbackinterfaceunsubscribermethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceValueOrContainerMethod0
  uniffi::loro::cb::callbackinterfacevalueorcontainermethod0::cleanup();
  // Cleanup for callback function CallbackInterfaceValueOrContainerMethod1
  uniffi::loro::cb::callbackinterfacevalueorcontainermethod1::cleanup();
  // Cleanup for callback function CallbackInterfaceValueOrContainerMethod2
  uniffi::loro::cb::callbackinterfacevalueorcontainermethod2::cleanup();
  // Cleanup for callback function CallbackInterfaceValueOrContainerMethod3
  uniffi::loro::cb::callbackinterfacevalueorcontainermethod3::cleanup();
  // Cleanup for callback function CallbackInterfaceValueOrContainerMethod4
  uniffi::loro::cb::callbackinterfacevalueorcontainermethod4::cleanup();
  // Cleanup for callback function CallbackInterfaceValueOrContainerMethod5
  uniffi::loro::cb::callbackinterfacevalueorcontainermethod5::cleanup();
  // Cleanup for callback function CallbackInterfaceValueOrContainerMethod6
  uniffi::loro::cb::callbackinterfacevalueorcontainermethod6::cleanup();
  // Cleanup for callback function CallbackInterfaceValueOrContainerMethod7
  uniffi::loro::cb::callbackinterfacevalueorcontainermethod7::cleanup();
  // Cleanup for callback function CallbackInterfaceValueOrContainerMethod8
  uniffi::loro::cb::callbackinterfacevalueorcontainermethod8::cleanup();
  // Cleanup for callback function CallbackInterfaceValueOrContainerMethod9
  uniffi::loro::cb::callbackinterfacevalueorcontainermethod9::cleanup();
  // Cleanup for callback function CallbackInterfaceValueOrContainerMethod10
  uniffi::loro::cb::callbackinterfacevalueorcontainermethod10::cleanup();
  // Cleanup for callback function CallbackInterfaceValueOrContainerMethod11
  uniffi::loro::cb::callbackinterfacevalueorcontainermethod11::cleanup();
}

// Utility functions for serialization/deserialization of strings.
jsi::Value NativeLoro::cpp_uniffi_internal_fn_func_ffi__string_to_byte_length(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  return uniffi_jsi::Bridging<std::string>::string_to_bytelength(rt, args[0]);
}

jsi::Value NativeLoro::cpp_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  return uniffi_jsi::Bridging<std::string>::string_to_arraybuffer(rt, args[0]);
}

jsi::Value NativeLoro::cpp_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  return uniffi_jsi::Bridging<std::string>::arraybuffer_to_string(rt, args[0]);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_awareness_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_awareness(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeLoro::
    cpp_uniffi_internal_fn_method_changeancestorstraveler_ffi__bless_pointer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_changeancestorstraveler(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_changemodifier_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_changemodifier(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_configure_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_configure(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_containeridlike_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_containeridlike(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeLoro::cpp_uniffi_internal_fn_method_cursor_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_cursor(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_diffbatch_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_diffbatch(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_ephemeralstore_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_ephemeralstore(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeLoro::
    cpp_uniffi_internal_fn_method_ephemeralsubscriber_ffi__bless_pointer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_ephemeralsubscriber(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeLoro::
    cpp_uniffi_internal_fn_method_firstcommitfrompeercallback_ffi__bless_pointer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_firstcommitfrompeercallback(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_fractionalindex_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_fractionalindex(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_frontiers_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_frontiers(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeLoro::
    cpp_uniffi_internal_fn_method_localephemerallistener_ffi__bless_pointer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_localephemerallistener(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeLoro::
    cpp_uniffi_internal_fn_method_localupdatecallback_ffi__bless_pointer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_localupdatecallback(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_lorocounter_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_lorocounter(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeLoro::cpp_uniffi_internal_fn_method_lorodoc_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_lorodoc(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_lorolist_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_lorolist(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeLoro::cpp_uniffi_internal_fn_method_loromap_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_loromap(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_loromovablelist_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_loromovablelist(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_lorotext_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_lorotext(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_lorotree_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_lorotree(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_lorounknown_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_lorounknown(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_lorovaluelike_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_lorovaluelike(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeLoro::cpp_uniffi_internal_fn_method_onpop_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_onpop(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value NativeLoro::cpp_uniffi_internal_fn_method_onpush_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_onpush(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_precommitcallback_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_precommitcallback(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_styleconfigmap_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_styleconfigmap(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_subscriber_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_subscriber(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_subscription_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_subscription(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_undomanager_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_undomanager(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_unsubscriber_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_unsubscriber(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_valueorcontainer_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_valueorcontainer(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}
jsi::Value
NativeLoro::cpp_uniffi_internal_fn_method_versionvector_ffi__bless_pointer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto pointer =
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]);
  auto static destructor = [](uint64_t p) {
    auto pointer = reinterpret_cast<void *>(static_cast<uintptr_t>(p));
    RustCallStatus status = {0};
    uniffi_loro_rs_fn_free_versionvector(pointer, &status);
  };
  auto ptrObj =
      std::make_shared<uniffi_jsi::DestructibleObject>(pointer, destructor);
  auto obj = jsi::Object::createFromHostObject(rt, ptrObj);
  return jsi::Value(rt, obj);
}

// Methods calling directly into the uniffi generated C API of the Rust crate.
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_awareness(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_awareness(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_awareness(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_awareness(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_awareness_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_awareness_new(
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<int64_t>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_awareness_apply(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_awareness_apply(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_awareness_encode(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_awareness_encode(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_awareness_encode_all(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_awareness_encode_all(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_awareness_get_all_states(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_awareness_get_all_states(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_awareness_get_local_state(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_awareness_get_local_state(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_awareness_peer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_awareness_peer(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_awareness_remove_outdated(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_awareness_remove_outdated(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_awareness_set_local_state(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_awareness_set_local_state(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_changeancestorstraveler(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_changeancestorstraveler(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_changeancestorstraveler(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_changeancestorstraveler(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_changeancestorstraveler_travel(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_changeancestorstraveler_travel(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_changemodifier(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_changemodifier(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_changemodifier(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_changemodifier(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_changemodifier_set_message(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_changemodifier_set_message(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_changemodifier_set_timestamp(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_changemodifier_set_timestamp(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<int64_t>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_configure(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_configure(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_configure(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_configure(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_configure_fork(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_configure_fork(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_configure_merge_interval(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_configure_merge_interval(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_configure_record_timestamp(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_configure_record_timestamp(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_configure_set_merge_interval(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_configure_set_merge_interval(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<int64_t>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_configure_set_record_timestamp(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_configure_set_record_timestamp(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<int8_t>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_configure_text_style_config(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_configure_text_style_config(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_containeridlike(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_containeridlike(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_containeridlike(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_containeridlike(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_containeridlike_as_container_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_containeridlike_as_container_id(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_cursor(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_cursor(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_cursor(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_cursor(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_cursor_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_cursor_new(
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[3]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_diffbatch(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_diffbatch(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_diffbatch(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_diffbatch(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_diffbatch_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_diffbatch_new(&status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_diffbatch_get_diff(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_diffbatch_get_diff(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_diffbatch_push(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_diffbatch_push(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_ephemeralstore(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_ephemeralstore(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_ephemeralstore(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_ephemeralstore(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_ephemeralstore_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_ephemeralstore_new(
      uniffi_jsi::Bridging<int64_t>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_ephemeralstore_apply(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_ephemeralstore_apply(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_ephemeralstore_delete(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_ephemeralstore_delete(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_ephemeralstore_encode(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_ephemeralstore_encode(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_ephemeralstore_encode_all(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_ephemeralstore_encode_all(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_ephemeralstore_get(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_ephemeralstore_get(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_ephemeralstore_get_all_states(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_ephemeralstore_get_all_states(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_ephemeralstore_keys(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_ephemeralstore_keys(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_ephemeralstore_remove_outdated(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_ephemeralstore_remove_outdated(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_ephemeralstore_set(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_ephemeralstore_set(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_ephemeralstore_subscribe(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_ephemeralstore_subscribe(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_ephemeralstore_subscribe_local_update(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_ephemeralstore_subscribe_local_update(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_ephemeralsubscriber(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_ephemeralsubscriber(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_ephemeralsubscriber(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_ephemeralsubscriber(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_ephemeralsubscriber_on_ephemeral_event(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_ephemeralsubscriber_on_ephemeral_event(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_firstcommitfrompeercallback(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_firstcommitfrompeercallback(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_firstcommitfrompeercallback(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_firstcommitfrompeercallback(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_fn_method_firstcommitfrompeercallback_on_first_commit_from_peer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_firstcommitfrompeercallback_on_first_commit_from_peer(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_fractionalindex(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_fractionalindex(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_fractionalindex(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_fractionalindex(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_constructor_fractionalindex_from_bytes(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_fractionalindex_from_bytes(
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_constructor_fractionalindex_from_hex_string(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_fractionalindex_from_hex_string(
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_fractionalindex_to_string(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_fractionalindex_to_string(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_frontiers(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_frontiers(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_frontiers(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_frontiers(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_frontiers_decode(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_frontiers_decode(
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_frontiers_from_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_frontiers_from_id(
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_frontiers_from_ids(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_frontiers_from_ids(
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_frontiers_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_frontiers_new(&status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_frontiers_encode(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_frontiers_encode(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_frontiers_eq(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_frontiers_eq(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_localephemerallistener(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_localephemerallistener(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_localephemerallistener(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_localephemerallistener(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_fn_method_localephemerallistener_on_ephemeral_update(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_localephemerallistener_on_ephemeral_update(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_localupdatecallback(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_localupdatecallback(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_localupdatecallback(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_localupdatecallback(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_localupdatecallback_on_local_update(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_localupdatecallback_on_local_update(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_lorocounter(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_lorocounter(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_lorocounter(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_lorocounter(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_lorocounter_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_lorocounter_new(&status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorocounter_decrement(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorocounter_decrement(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<double>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorocounter_doc(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorocounter_doc(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorocounter_get_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorocounter_get_attached(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorocounter_get_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorocounter_get_value(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<double>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorocounter_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorocounter_id(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorocounter_increment(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorocounter_increment(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<double>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorocounter_is_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorocounter_is_attached(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorocounter_is_deleted(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorocounter_is_deleted(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_lorodoc(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_lorodoc(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_lorodoc(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_lorodoc(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_lorodoc_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_lorodoc_new(&status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_apply_diff(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_apply_diff(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_attach(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_attach(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_check_state_correctness_slow(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_check_state_correctness_slow(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_checkout(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_checkout(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_checkout_to_latest(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_checkout_to_latest(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_clear_next_commit_options(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_clear_next_commit_options(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_cmp_with_frontiers(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_cmp_with_frontiers(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_commit(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_commit(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_commit_with(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_commit_with(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_compact_change_store(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_compact_change_store(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_config(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_config(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_config_default_text_style(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_config_default_text_style(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_config_text_style(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_config_text_style(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_detach(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_detach(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_diff(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_diff(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_export_json_in_id_span(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_export_json_in_id_span(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_export_json_updates(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_export_json_updates(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_fn_method_lorodoc_export_json_updates_without_peer_compression(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_loro_rs_fn_method_lorodoc_export_json_updates_without_peer_compression(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]),
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]),
          &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_export_shallow_snapshot(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_export_shallow_snapshot(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_export_snapshot(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_export_snapshot(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_export_snapshot_at(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_export_snapshot_at(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_export_state_only(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_export_state_only(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_export_updates(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_export_updates(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_export_updates_in_range(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_export_updates_in_range(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_find_id_spans_between(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_find_id_spans_between(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_fork(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_fork(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_fork_at(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_fork_at(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_free_diff_calculator(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_free_diff_calculator(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_free_history_cache(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_free_history_cache(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_frontiers_to_vv(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_frontiers_to_vv(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_get_by_path(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_get_by_path(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_get_by_str_path(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_get_by_str_path(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_get_change(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_get_change(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_get_changed_containers_in(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_get_changed_containers_in(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_get_counter(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_get_counter(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_get_cursor_pos(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_get_cursor_pos(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_get_deep_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_get_deep_value(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_get_deep_value_with_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_get_deep_value_with_id(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_get_list(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_get_list(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_get_map(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_get_map(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_get_movable_list(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_get_movable_list(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_get_path_to_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_get_path_to_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_get_pending_txn_len(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_get_pending_txn_len(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_get_text(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_get_text(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_get_tree(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_get_tree(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_get_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_get_value(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_has_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_has_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_has_history_cache(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_has_history_cache(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_import(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_import(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_import_batch(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_import_batch(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_import_json_updates(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_import_json_updates(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_import_with(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_import_with(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_is_detached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_is_detached(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_is_shallow(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_is_shallow(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_jsonpath(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_jsonpath(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_len_changes(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_len_changes(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_len_ops(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_len_ops(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_log_estimate_size(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_log_estimate_size(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_minimize_frontiers(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_minimize_frontiers(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_oplog_frontiers(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_oplog_frontiers(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_oplog_vv(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_oplog_vv(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_peer_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_peer_id(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<uint64_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_revert_to(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_revert_to(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_set_change_merge_interval(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_set_change_merge_interval(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<int64_t>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_set_next_commit_message(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_set_next_commit_message(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_set_next_commit_options(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_set_next_commit_options(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_set_next_commit_origin(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_set_next_commit_origin(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_set_next_commit_timestamp(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_set_next_commit_timestamp(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<int64_t>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_set_peer_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_set_peer_id(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_set_record_timestamp(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_set_record_timestamp(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<int8_t>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_shallow_since_vv(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_shallow_since_vv(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_state_frontiers(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_state_frontiers(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_state_vv(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_state_vv(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_subscribe(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_subscribe(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_fn_method_lorodoc_subscribe_first_commit_from_peer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_loro_rs_fn_method_lorodoc_subscribe_first_commit_from_peer(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]),
          &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_subscribe_local_update(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_subscribe_local_update(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_subscribe_pre_commit(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_subscribe_pre_commit(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_subscribe_root(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_subscribe_root(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_travel_change_ancestors(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorodoc_travel_change_ancestors(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorodoc_vv_to_frontiers(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorodoc_vv_to_frontiers(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_lorolist(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_lorolist(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_lorolist(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_lorolist(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_lorolist_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_lorolist_new(&status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_clear(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorolist_clear(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_delete(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorolist_delete(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_doc(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_doc(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_get(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_get(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_get_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_get_attached(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_get_cursor(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_get_cursor(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_get_deep_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_get_deep_value(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_get_id_at(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_get_id_at(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_get_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_get_value(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_id(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_insert(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorolist_insert(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_insert_counter_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_insert_counter_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_insert_list_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_insert_list_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_insert_map_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_insert_map_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_insert_movable_list_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_insert_movable_list_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_insert_text_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_insert_text_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_insert_tree_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_insert_tree_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_is_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_is_attached(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_is_deleted(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_is_deleted(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_is_empty(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_is_empty(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_len(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_len(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_pop(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_pop(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_push(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorolist_push(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorolist_to_vec(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorolist_to_vec(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_loromap(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_loromap(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_loromap(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_loromap(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_loromap_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_loromap_new(&status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_clear(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_loromap_clear(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_delete(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_loromap_delete(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_doc(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_doc(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_get(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_get(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_get_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_get_attached(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_get_deep_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_get_deep_value(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_get_last_editor(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_get_last_editor(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_fn_method_loromap_get_or_create_counter_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_get_or_create_counter_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_get_or_create_list_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_get_or_create_list_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_get_or_create_map_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_get_or_create_map_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_fn_method_loromap_get_or_create_movable_list_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_loro_rs_fn_method_loromap_get_or_create_movable_list_container(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]),
          &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_get_or_create_text_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_get_or_create_text_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_get_or_create_tree_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_get_or_create_tree_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_get_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_get_value(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_id(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_insert(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_loromap_insert(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_insert_counter_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_insert_counter_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_insert_list_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_insert_list_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_insert_map_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_insert_map_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_insert_movable_list_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_insert_movable_list_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_insert_text_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_insert_text_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_insert_tree_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_insert_tree_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_is_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_is_attached(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_is_deleted(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_is_deleted(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_is_empty(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_is_empty(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_keys(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_keys(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_len(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_len(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromap_values(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromap_values(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_loromovablelist(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_loromovablelist(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_loromovablelist(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_loromovablelist(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_loromovablelist_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_loromovablelist_new(&status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_clear(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_loromovablelist_clear(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_delete(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_loromovablelist_delete(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_doc(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_doc(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_get(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_get(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_get_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_get_attached(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_get_creator_at(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_get_creator_at(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_get_cursor(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_get_cursor(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_get_deep_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_get_deep_value(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_get_last_editor_at(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_get_last_editor_at(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_get_last_mover_at(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_get_last_mover_at(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_get_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_get_value(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_id(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_insert(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_loromovablelist_insert(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_fn_method_loromovablelist_insert_counter_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_loro_rs_fn_method_loromovablelist_insert_counter_container(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]),
          &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_insert_list_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_insert_list_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_insert_map_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_insert_map_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_fn_method_loromovablelist_insert_movable_list_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_loro_rs_fn_method_loromovablelist_insert_movable_list_container(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]),
          &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_insert_text_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_insert_text_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_insert_tree_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_insert_tree_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_is_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_is_attached(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_is_deleted(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_is_deleted(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_is_empty(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_is_empty(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_len(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_len(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_mov(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_loromovablelist_mov(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_pop(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_pop(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_push(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_loromovablelist_push(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_set(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_loromovablelist_set(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_set_counter_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_set_counter_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_set_list_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_set_list_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_set_map_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_set_map_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_fn_method_loromovablelist_set_movable_list_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_loro_rs_fn_method_loromovablelist_set_movable_list_container(
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
          uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
          uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]),
          &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_set_text_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_set_text_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_set_tree_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_set_tree_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[2]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_loromovablelist_to_vec(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_loromovablelist_to_vec(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_lorotext(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_lorotext(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_lorotext(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_lorotext(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_lorotext_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_lorotext_new(&status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_apply_delta(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotext_apply_delta(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_delete(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotext_delete(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_delete_utf8(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotext_delete_utf8(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_doc(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotext_doc(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_get_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotext_get_attached(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_get_cursor(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotext_get_cursor(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_get_editor_at_unicode_pos(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotext_get_editor_at_unicode_pos(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_get_richtext_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotext_get_richtext_value(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotext_id(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_insert(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotext_insert(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_insert_utf8(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotext_insert_utf8(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_is_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotext_is_attached(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_is_deleted(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotext_is_deleted(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_is_empty(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotext_is_empty(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_len_unicode(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotext_len_unicode(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_len_utf16(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotext_len_utf16(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_len_utf8(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotext_len_utf8(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_mark(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotext_mark(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[2]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[3]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[4]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_push_str(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotext_push_str(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_slice(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotext_slice(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_splice(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotext_splice(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[2]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[3]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_to_delta(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotext_to_delta(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_to_string(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotext_to_string(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_unmark(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotext_unmark(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[2]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[3]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_update(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotext_update(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotext_update_by_line(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotext_update_by_line(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_lorotree(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_lorotree(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_lorotree(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_lorotree(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_lorotree_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_lorotree_new(&status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_children(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_children(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_children_num(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_children_num(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_contains(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_contains(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_create(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_create(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_create_at(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_create_at(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_delete(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotree_delete(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_disable_fractional_index(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotree_disable_fractional_index(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_doc(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_doc(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_enable_fractional_index(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotree_enable_fractional_index(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint8_t>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_fractional_index(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_fractional_index(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_get_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_get_attached(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_get_last_move_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_get_last_move_id(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_get_meta(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_get_meta(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_get_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_get_value(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_get_value_with_meta(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_get_value_with_meta(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_id(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_is_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_is_attached(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_is_deleted(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_is_deleted(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_is_fractional_index_enabled(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_is_fractional_index_enabled(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_is_node_deleted(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_is_node_deleted(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_mov(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotree_mov(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_mov_after(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotree_mov_after(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_mov_before(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotree_mov_before(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_mov_to(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_lorotree_mov_to(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[3]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_nodes(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_nodes(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_parent(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_parent(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorotree_roots(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorotree_roots(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_lorounknown(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_lorounknown(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_lorounknown(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_lorounknown(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorounknown_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorounknown_id(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_lorovaluelike(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_lorovaluelike(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_lorovaluelike(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_lorovaluelike(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_lorovaluelike_as_loro_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_lorovaluelike_as_loro_value(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_onpop(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_onpop(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_onpop(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_onpop(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_onpop_on_pop(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_onpop_on_pop(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[3]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_onpush(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_onpush(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_onpush(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_onpush(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_onpush_on_push(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_onpush_on_push(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[3]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_precommitcallback(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_precommitcallback(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_precommitcallback(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_precommitcallback(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_precommitcallback_on_pre_commit(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_precommitcallback_on_pre_commit(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_styleconfigmap(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_styleconfigmap(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_styleconfigmap(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_styleconfigmap(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_fn_constructor_styleconfigmap_default_rich_text_config(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value =
      uniffi_loro_rs_fn_constructor_styleconfigmap_default_rich_text_config(
          &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_styleconfigmap_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_styleconfigmap_new(&status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_styleconfigmap_get(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_styleconfigmap_get(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_styleconfigmap_insert(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_styleconfigmap_insert(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[2]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_subscriber(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_subscriber(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_subscriber(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_subscriber(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_subscriber_on_diff(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_subscriber_on_diff(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_subscription(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_subscription(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_subscription(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_subscription(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_subscription_detach(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_subscription_detach(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_subscription_unsubscribe(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_subscription_unsubscribe(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_undomanager(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_undomanager(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_undomanager(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_undomanager(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_undomanager_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_undomanager_new(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_undomanager_add_exclude_origin_prefix(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_undomanager_add_exclude_origin_prefix(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_undomanager_can_redo(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_undomanager_can_redo(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_undomanager_can_undo(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_undomanager_can_undo(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_undomanager_record_new_checkpoint(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_undomanager_record_new_checkpoint(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_undomanager_redo(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_undomanager_redo(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_undomanager_set_max_undo_steps(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_undomanager_set_max_undo_steps(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint32_t>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_undomanager_set_merge_interval(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_undomanager_set_merge_interval(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<int64_t>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_undomanager_set_on_pop(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_undomanager_set_on_pop(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_undomanager_set_on_push(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_undomanager_set_on_push(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_undomanager_undo(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_undomanager_undo(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_unsubscriber(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_unsubscriber(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_unsubscriber(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_unsubscriber(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_unsubscriber_on_unsubscribe(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_unsubscriber_on_unsubscribe(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_valueorcontainer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_valueorcontainer(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_valueorcontainer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_valueorcontainer(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_valueorcontainer_as_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_counter(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_valueorcontainer_as_loro_counter(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_list(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_valueorcontainer_as_loro_list(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_map(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_valueorcontainer_as_loro_map(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_movable_list(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_valueorcontainer_as_loro_movable_list(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_text(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_valueorcontainer_as_loro_text(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_tree(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_valueorcontainer_as_loro_tree(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_loro_unknown(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_valueorcontainer_as_loro_unknown(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_valueorcontainer_as_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_valueorcontainer_as_value(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_valueorcontainer_container_type(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_valueorcontainer_container_type(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_valueorcontainer_is_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_valueorcontainer_is_container(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_valueorcontainer_is_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_valueorcontainer_is_value(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_clone_versionvector(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_clone_versionvector(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_free_versionvector(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_free_versionvector(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_versionvector_decode(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_versionvector_decode(
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_constructor_versionvector_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_constructor_versionvector_new(&status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<void *>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_versionvector_diff(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_versionvector_diff(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_versionvector_encode(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_versionvector_encode(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_versionvector_eq(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_versionvector_eq(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_versionvector_extend_to_include_vv(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_versionvector_extend_to_include_vv(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_versionvector_get_last(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_versionvector_get_last(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<uint64_t>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_versionvector_get_missing_span(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_versionvector_get_missing_span(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_versionvector_includes_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_versionvector_includes_id(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_versionvector_includes_vv(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_versionvector_includes_vv(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi_jsi::Bridging<int8_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_method_versionvector_intersect_span(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_versionvector_intersect_span(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_versionvector_merge(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_versionvector_merge(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_versionvector_partial_cmp(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_method_versionvector_partial_cmp(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_versionvector_set_end(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_versionvector_set_end(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_method_versionvector_set_last(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  uniffi_loro_rs_fn_method_versionvector_set_last(
      uniffi_jsi::Bridging<void *>::fromJs(rt, callInvoker, args[0]),
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[1]),
      &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_func_decode_import_blob_meta(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_func_decode_import_blob_meta(
      uniffi::loro::Bridging<RustBuffer>::fromJs(rt, callInvoker, args[0]),
      uniffi_jsi::Bridging<int8_t>::fromJs(rt, callInvoker, args[1]), &status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_func_get_version(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  RustCallStatus status =
      uniffi::loro::Bridging<RustCallStatus>::rustSuccess(rt);
  auto value = uniffi_loro_rs_fn_func_get_version(&status);
  uniffi::loro::Bridging<RustCallStatus>::copyIntoJs(rt, callInvoker, status,
                                                     args[count - 1]);

  return uniffi::loro::Bridging<RustBuffer>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_func_decode_import_blob_meta(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_func_decode_import_blob_meta();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_func_get_version(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_func_get_version();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_awareness_apply(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_awareness_apply();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_awareness_encode(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_awareness_encode();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_awareness_encode_all(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_awareness_encode_all();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_awareness_get_all_states(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_awareness_get_all_states();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_awareness_get_local_state(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_awareness_get_local_state();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_awareness_peer(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_awareness_peer();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_awareness_remove_outdated(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_awareness_remove_outdated();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_awareness_set_local_state(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_awareness_set_local_state();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_changeancestorstraveler_travel(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_changeancestorstraveler_travel();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_changemodifier_set_message(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_changemodifier_set_message();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_changemodifier_set_timestamp(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_changemodifier_set_timestamp();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_configure_fork(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_configure_fork();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_configure_merge_interval(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_configure_merge_interval();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_configure_record_timestamp(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_configure_record_timestamp();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_configure_set_merge_interval(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_configure_set_merge_interval();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_configure_set_record_timestamp(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_configure_set_record_timestamp();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_configure_text_style_config(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_configure_text_style_config();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_containeridlike_as_container_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_containeridlike_as_container_id();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_diffbatch_get_diff(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_diffbatch_get_diff();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_diffbatch_push(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_diffbatch_push();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_ephemeralstore_apply(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_ephemeralstore_apply();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_ephemeralstore_delete(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_ephemeralstore_delete();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_ephemeralstore_encode(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_ephemeralstore_encode();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_ephemeralstore_encode_all(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_ephemeralstore_encode_all();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_ephemeralstore_get(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_ephemeralstore_get();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_ephemeralstore_get_all_states(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_ephemeralstore_get_all_states();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_ephemeralstore_keys(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_ephemeralstore_keys();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_ephemeralstore_remove_outdated(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_ephemeralstore_remove_outdated();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_ephemeralstore_set(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_ephemeralstore_set();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_ephemeralstore_subscribe(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_ephemeralstore_subscribe();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_ephemeralstore_subscribe_local_update(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_ephemeralstore_subscribe_local_update();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_ephemeralsubscriber_on_ephemeral_event(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_ephemeralsubscriber_on_ephemeral_event();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_firstcommitfrompeercallback_on_first_commit_from_peer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_firstcommitfrompeercallback_on_first_commit_from_peer();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_fractionalindex_to_string(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_fractionalindex_to_string();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_frontiers_encode(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_frontiers_encode();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_frontiers_eq(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_frontiers_eq();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_localephemerallistener_on_ephemeral_update(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_localephemerallistener_on_ephemeral_update();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_localupdatecallback_on_local_update(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_localupdatecallback_on_local_update();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorocounter_decrement(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorocounter_decrement();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorocounter_doc(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorocounter_doc();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorocounter_get_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorocounter_get_attached();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorocounter_get_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorocounter_get_value();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorocounter_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorocounter_id();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorocounter_increment(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorocounter_increment();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorocounter_is_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorocounter_is_attached();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorocounter_is_deleted(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorocounter_is_deleted();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_apply_diff(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_apply_diff();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_attach(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_attach();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_lorodoc_check_state_correctness_slow(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_lorodoc_check_state_correctness_slow();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_checkout(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_checkout();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_checkout_to_latest(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_checkout_to_latest();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_lorodoc_clear_next_commit_options(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_lorodoc_clear_next_commit_options();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_cmp_with_frontiers(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_cmp_with_frontiers();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_commit(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_commit();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_commit_with(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_commit_with();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_compact_change_store(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_compact_change_store();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_config(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_config();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_lorodoc_config_default_text_style(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_lorodoc_config_default_text_style();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_config_text_style(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_config_text_style();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_detach(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_detach();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_diff(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_diff();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_export_json_in_id_span(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_export_json_in_id_span();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_export_json_updates(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_export_json_updates();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_lorodoc_export_json_updates_without_peer_compression(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_lorodoc_export_json_updates_without_peer_compression();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_export_shallow_snapshot(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_export_shallow_snapshot();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_export_snapshot(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_export_snapshot();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_export_snapshot_at(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_export_snapshot_at();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_export_state_only(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_export_state_only();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_export_updates(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_export_updates();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_export_updates_in_range(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_export_updates_in_range();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_find_id_spans_between(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_find_id_spans_between();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_fork(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_fork();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_fork_at(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_fork_at();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_free_diff_calculator(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_free_diff_calculator();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_free_history_cache(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_free_history_cache();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_frontiers_to_vv(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_frontiers_to_vv();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_get_by_path(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_get_by_path();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_get_by_str_path(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_get_by_str_path();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_get_change(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_get_change();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_lorodoc_get_changed_containers_in(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_lorodoc_get_changed_containers_in();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_get_counter(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_get_counter();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_get_cursor_pos(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_get_cursor_pos();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_get_deep_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_get_deep_value();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_get_deep_value_with_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_get_deep_value_with_id();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_get_list(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_get_list();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_get_map(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_get_map();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_get_movable_list(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_get_movable_list();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_get_path_to_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_get_path_to_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_get_pending_txn_len(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_get_pending_txn_len();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_get_text(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_get_text();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_get_tree(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_get_tree();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_get_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_get_value();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_has_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_has_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_has_history_cache(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_has_history_cache();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_import(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_import();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_import_batch(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_import_batch();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_import_json_updates(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_import_json_updates();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_import_with(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_import_with();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_is_detached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_is_detached();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_is_shallow(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_is_shallow();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_jsonpath(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_jsonpath();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_len_changes(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_len_changes();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_len_ops(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_len_ops();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_log_estimate_size(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_log_estimate_size();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_minimize_frontiers(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_minimize_frontiers();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_oplog_frontiers(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_oplog_frontiers();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_oplog_vv(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_oplog_vv();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_peer_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_peer_id();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_revert_to(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_revert_to();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_lorodoc_set_change_merge_interval(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_lorodoc_set_change_merge_interval();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_message(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_message();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_options(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_options();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_origin(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_origin();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_timestamp(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_lorodoc_set_next_commit_timestamp();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_set_peer_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_set_peer_id();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_set_record_timestamp(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_set_record_timestamp();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_shallow_since_vv(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_shallow_since_vv();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_state_frontiers(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_state_frontiers();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_state_vv(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_state_vv();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_subscribe(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_subscribe();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_lorodoc_subscribe_first_commit_from_peer(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_lorodoc_subscribe_first_commit_from_peer();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_subscribe_local_update(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_subscribe_local_update();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_subscribe_pre_commit(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_subscribe_pre_commit();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_subscribe_root(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_subscribe_root();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_travel_change_ancestors(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_travel_change_ancestors();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorodoc_vv_to_frontiers(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorodoc_vv_to_frontiers();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_clear(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_clear();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_delete(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_delete();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_doc(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_doc();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_get(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_get();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_get_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_get_attached();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_get_cursor(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_get_cursor();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_get_deep_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_get_deep_value();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_get_id_at(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_get_id_at();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_get_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_get_value();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_id();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_insert(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_insert();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_lorolist_insert_counter_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_lorolist_insert_counter_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_insert_list_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_insert_list_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_insert_map_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_insert_map_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_lorolist_insert_movable_list_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_lorolist_insert_movable_list_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_insert_text_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_insert_text_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_insert_tree_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_insert_tree_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_is_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_is_attached();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_is_deleted(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_is_deleted();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_is_empty(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_is_empty();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_len(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_len();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_pop(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_pop();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_push(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_push();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorolist_to_vec(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorolist_to_vec();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_clear(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_clear();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_delete(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_delete();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_doc(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_doc();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_get(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_get();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_get_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_get_attached();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_get_deep_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_get_deep_value();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_get_last_editor(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_get_last_editor();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromap_get_or_create_counter_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromap_get_or_create_counter_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromap_get_or_create_list_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromap_get_or_create_list_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromap_get_or_create_map_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromap_get_or_create_map_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromap_get_or_create_movable_list_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromap_get_or_create_movable_list_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromap_get_or_create_text_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromap_get_or_create_text_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromap_get_or_create_tree_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromap_get_or_create_tree_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_get_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_get_value();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_id();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_insert(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_insert();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_insert_counter_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromap_insert_counter_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_insert_list_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_insert_list_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_insert_map_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_insert_map_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromap_insert_movable_list_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromap_insert_movable_list_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_insert_text_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_insert_text_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_insert_tree_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_insert_tree_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_is_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_is_attached();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_is_deleted(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_is_deleted();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_is_empty(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_is_empty();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_keys(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_keys();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_len(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_len();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromap_values(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromap_values();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_clear(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_clear();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_delete(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_delete();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_doc(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_doc();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_get(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_get();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_get_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_get_attached();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_get_creator_at(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_get_creator_at();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_get_cursor(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_get_cursor();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_get_deep_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_get_deep_value();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromovablelist_get_last_editor_at(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromovablelist_get_last_editor_at();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromovablelist_get_last_mover_at(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromovablelist_get_last_mover_at();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_get_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_get_value();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_id();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_insert(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_insert();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromovablelist_insert_counter_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromovablelist_insert_counter_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromovablelist_insert_list_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromovablelist_insert_list_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromovablelist_insert_map_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromovablelist_insert_map_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromovablelist_insert_movable_list_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromovablelist_insert_movable_list_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromovablelist_insert_text_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromovablelist_insert_text_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromovablelist_insert_tree_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromovablelist_insert_tree_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_is_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_is_attached();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_is_deleted(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_is_deleted();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_is_empty(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_is_empty();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_len(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_len();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_mov(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_mov();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_pop(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_pop();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_push(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_push();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_set(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_set();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromovablelist_set_counter_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromovablelist_set_counter_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromovablelist_set_list_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromovablelist_set_list_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromovablelist_set_map_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromovablelist_set_map_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromovablelist_set_movable_list_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromovablelist_set_movable_list_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromovablelist_set_text_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromovablelist_set_text_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_loromovablelist_set_tree_container(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_loromovablelist_set_tree_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_loromovablelist_to_vec(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_loromovablelist_to_vec();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_apply_delta(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_apply_delta();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_delete(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_delete();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_delete_utf8(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_delete_utf8();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_doc(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_doc();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_get_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_get_attached();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_get_cursor(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_get_cursor();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_lorotext_get_editor_at_unicode_pos(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_lorotext_get_editor_at_unicode_pos();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_get_richtext_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_get_richtext_value();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_id();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_insert(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_insert();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_insert_utf8(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_insert_utf8();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_is_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_is_attached();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_is_deleted(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_is_deleted();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_is_empty(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_is_empty();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_len_unicode(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_len_unicode();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_len_utf16(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_len_utf16();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_len_utf8(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_len_utf8();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_mark(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_mark();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_push_str(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_push_str();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_slice(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_slice();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_splice(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_splice();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_to_delta(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_to_delta();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_to_string(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_to_string();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_unmark(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_unmark();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_update(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_update();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotext_update_by_line(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotext_update_by_line();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_children(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_children();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_children_num(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_children_num();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_contains(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_contains();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_create(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_create();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_create_at(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_create_at();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_delete(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_delete();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_lorotree_disable_fractional_index(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_lorotree_disable_fractional_index();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_doc(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_doc();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_enable_fractional_index(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_lorotree_enable_fractional_index();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_fractional_index(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_fractional_index();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_get_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_get_attached();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_get_last_move_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_get_last_move_id();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_get_meta(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_get_meta();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_get_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_get_value();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_get_value_with_meta(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_get_value_with_meta();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_id();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_is_attached(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_is_attached();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_is_deleted(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_is_deleted();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_lorotree_is_fractional_index_enabled(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_lorotree_is_fractional_index_enabled();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_is_node_deleted(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_is_node_deleted();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_mov(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_mov();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_mov_after(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_mov_after();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_mov_before(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_mov_before();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_mov_to(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_mov_to();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_nodes(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_nodes();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_parent(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_parent();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorotree_roots(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorotree_roots();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorounknown_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorounknown_id();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_lorovaluelike_as_loro_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_lorovaluelike_as_loro_value();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_onpop_on_pop(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_onpop_on_pop();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_onpush_on_push(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_onpush_on_push();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_precommitcallback_on_pre_commit(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_precommitcallback_on_pre_commit();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_styleconfigmap_get(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_styleconfigmap_get();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_styleconfigmap_insert(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_styleconfigmap_insert();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_subscriber_on_diff(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_subscriber_on_diff();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_subscription_detach(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_subscription_detach();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_subscription_unsubscribe(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_subscription_unsubscribe();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_undomanager_add_exclude_origin_prefix(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_undomanager_add_exclude_origin_prefix();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_undomanager_can_redo(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_undomanager_can_redo();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_undomanager_can_undo(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_undomanager_can_undo();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_undomanager_record_new_checkpoint(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_undomanager_record_new_checkpoint();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_undomanager_redo(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_undomanager_redo();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_undomanager_set_max_undo_steps(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_undomanager_set_max_undo_steps();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_undomanager_set_merge_interval(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_undomanager_set_merge_interval();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_undomanager_set_on_pop(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_undomanager_set_on_pop();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_undomanager_set_on_push(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_undomanager_set_on_push();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_undomanager_undo(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_undomanager_undo();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_unsubscriber_on_unsubscribe(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_unsubscriber_on_unsubscribe();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_valueorcontainer_as_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_counter(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_counter();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_list(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_list();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_map(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_map();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_movable_list(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_movable_list();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_text(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_text();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_tree(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_tree();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_unknown(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_valueorcontainer_as_loro_unknown();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_valueorcontainer_as_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_valueorcontainer_as_value();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_valueorcontainer_container_type(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_valueorcontainer_container_type();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_valueorcontainer_is_container(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_valueorcontainer_is_container();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_valueorcontainer_is_value(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_valueorcontainer_is_value();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_versionvector_diff(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_versionvector_diff();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_versionvector_encode(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_versionvector_encode();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_versionvector_eq(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_versionvector_eq();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_method_versionvector_extend_to_include_vv(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_method_versionvector_extend_to_include_vv();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_versionvector_get_last(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_versionvector_get_last();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_versionvector_get_missing_span(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_versionvector_get_missing_span();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_versionvector_includes_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_versionvector_includes_id();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_versionvector_includes_vv(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_versionvector_includes_vv();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_versionvector_intersect_span(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_versionvector_intersect_span();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_versionvector_merge(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_versionvector_merge();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_versionvector_partial_cmp(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_versionvector_partial_cmp();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_method_versionvector_set_end(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_versionvector_set_end();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_method_versionvector_set_last(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_method_versionvector_set_last();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_awareness_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_awareness_new();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_cursor_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_cursor_new();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_diffbatch_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_diffbatch_new();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_ephemeralstore_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_ephemeralstore_new();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_fractionalindex_from_bytes(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_fractionalindex_from_bytes();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_constructor_fractionalindex_from_hex_string(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_constructor_fractionalindex_from_hex_string();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_frontiers_decode(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_frontiers_decode();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_frontiers_from_id(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_frontiers_from_id();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_frontiers_from_ids(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_frontiers_from_ids();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_frontiers_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_frontiers_new();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_lorocounter_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_lorocounter_new();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_lorodoc_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_lorodoc_new();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_lorolist_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_lorolist_new();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_loromap_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_loromap_new();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_loromovablelist_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_loromovablelist_new();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_lorotext_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_lorotext_new();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_lorotree_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_lorotree_new();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_checksum_constructor_styleconfigmap_default_rich_text_config(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto value =
      uniffi_loro_rs_checksum_constructor_styleconfigmap_default_rich_text_config();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_styleconfigmap_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_styleconfigmap_new();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_undomanager_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_undomanager_new();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_versionvector_decode(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_versionvector_decode();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_checksum_constructor_versionvector_new(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = uniffi_loro_rs_checksum_constructor_versionvector_new();

  return uniffi_jsi::Bridging<uint16_t>::toJs(rt, callInvoker, value);
}
jsi::Value NativeLoro::cpp_ffi_loro_rs_uniffi_contract_version(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto value = ffi_loro_rs_uniffi_contract_version();

  return uniffi_jsi::Bridging<uint32_t>::toJs(rt, callInvoker, value);
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_init_callback_vtable_changeancestorstraveler(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto vtableInstance = uniffi::loro::Bridging<
      UniffiVTableCallbackInterfaceChangeAncestorsTraveler>::fromJs(rt,
                                                                    callInvoker,
                                                                    args[0]);

  std::lock_guard<std::mutex> lock(uniffi::loro::registry::vtableMutex);
  uniffi_loro_rs_fn_init_callback_vtable_changeancestorstraveler(
      uniffi::loro::registry::putTable(
          "UniffiVTableCallbackInterfaceChangeAncestorsTraveler",
          vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_init_callback_vtable_containeridlike(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto vtableInstance = uniffi::loro::Bridging<
      UniffiVTableCallbackInterfaceContainerIdLike>::fromJs(rt, callInvoker,
                                                            args[0]);

  std::lock_guard<std::mutex> lock(uniffi::loro::registry::vtableMutex);
  uniffi_loro_rs_fn_init_callback_vtable_containeridlike(
      uniffi::loro::registry::putTable(
          "UniffiVTableCallbackInterfaceContainerIdLike", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_init_callback_vtable_ephemeralsubscriber(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto vtableInstance = uniffi::loro::Bridging<
      UniffiVTableCallbackInterfaceEphemeralSubscriber>::fromJs(rt, callInvoker,
                                                                args[0]);

  std::lock_guard<std::mutex> lock(uniffi::loro::registry::vtableMutex);
  uniffi_loro_rs_fn_init_callback_vtable_ephemeralsubscriber(
      uniffi::loro::registry::putTable(
          "UniffiVTableCallbackInterfaceEphemeralSubscriber", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value NativeLoro::
    cpp_uniffi_loro_rs_fn_init_callback_vtable_firstcommitfrompeercallback(
        jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
        size_t count) {
  auto vtableInstance = uniffi::loro::Bridging<
      UniffiVTableCallbackInterfaceFirstCommitFromPeerCallback>::
      fromJs(rt, callInvoker, args[0]);

  std::lock_guard<std::mutex> lock(uniffi::loro::registry::vtableMutex);
  uniffi_loro_rs_fn_init_callback_vtable_firstcommitfrompeercallback(
      uniffi::loro::registry::putTable(
          "UniffiVTableCallbackInterfaceFirstCommitFromPeerCallback",
          vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_init_callback_vtable_localephemerallistener(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto vtableInstance = uniffi::loro::Bridging<
      UniffiVTableCallbackInterfaceLocalEphemeralListener>::fromJs(rt,
                                                                   callInvoker,
                                                                   args[0]);

  std::lock_guard<std::mutex> lock(uniffi::loro::registry::vtableMutex);
  uniffi_loro_rs_fn_init_callback_vtable_localephemerallistener(
      uniffi::loro::registry::putTable(
          "UniffiVTableCallbackInterfaceLocalEphemeralListener",
          vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_init_callback_vtable_localupdatecallback(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto vtableInstance = uniffi::loro::Bridging<
      UniffiVTableCallbackInterfaceLocalUpdateCallback>::fromJs(rt, callInvoker,
                                                                args[0]);

  std::lock_guard<std::mutex> lock(uniffi::loro::registry::vtableMutex);
  uniffi_loro_rs_fn_init_callback_vtable_localupdatecallback(
      uniffi::loro::registry::putTable(
          "UniffiVTableCallbackInterfaceLocalUpdateCallback", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_init_callback_vtable_lorovaluelike(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto vtableInstance = uniffi::loro::Bridging<
      UniffiVTableCallbackInterfaceLoroValueLike>::fromJs(rt, callInvoker,
                                                          args[0]);

  std::lock_guard<std::mutex> lock(uniffi::loro::registry::vtableMutex);
  uniffi_loro_rs_fn_init_callback_vtable_lorovaluelike(
      uniffi::loro::registry::putTable(
          "UniffiVTableCallbackInterfaceLoroValueLike", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_init_callback_vtable_onpop(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto vtableInstance =
      uniffi::loro::Bridging<UniffiVTableCallbackInterfaceOnPop>::fromJs(
          rt, callInvoker, args[0]);

  std::lock_guard<std::mutex> lock(uniffi::loro::registry::vtableMutex);
  uniffi_loro_rs_fn_init_callback_vtable_onpop(uniffi::loro::registry::putTable(
      "UniffiVTableCallbackInterfaceOnPop", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_init_callback_vtable_onpush(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto vtableInstance =
      uniffi::loro::Bridging<UniffiVTableCallbackInterfaceOnPush>::fromJs(
          rt, callInvoker, args[0]);

  std::lock_guard<std::mutex> lock(uniffi::loro::registry::vtableMutex);
  uniffi_loro_rs_fn_init_callback_vtable_onpush(
      uniffi::loro::registry::putTable("UniffiVTableCallbackInterfaceOnPush",
                                       vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value
NativeLoro::cpp_uniffi_loro_rs_fn_init_callback_vtable_precommitcallback(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto vtableInstance = uniffi::loro::Bridging<
      UniffiVTableCallbackInterfacePreCommitCallback>::fromJs(rt, callInvoker,
                                                              args[0]);

  std::lock_guard<std::mutex> lock(uniffi::loro::registry::vtableMutex);
  uniffi_loro_rs_fn_init_callback_vtable_precommitcallback(
      uniffi::loro::registry::putTable(
          "UniffiVTableCallbackInterfacePreCommitCallback", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_init_callback_vtable_subscriber(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto vtableInstance =
      uniffi::loro::Bridging<UniffiVTableCallbackInterfaceSubscriber>::fromJs(
          rt, callInvoker, args[0]);

  std::lock_guard<std::mutex> lock(uniffi::loro::registry::vtableMutex);
  uniffi_loro_rs_fn_init_callback_vtable_subscriber(
      uniffi::loro::registry::putTable(
          "UniffiVTableCallbackInterfaceSubscriber", vtableInstance));
  return jsi::Value::undefined();
}
jsi::Value NativeLoro::cpp_uniffi_loro_rs_fn_init_callback_vtable_unsubscriber(
    jsi::Runtime &rt, const jsi::Value &thisVal, const jsi::Value *args,
    size_t count) {
  auto vtableInstance =
      uniffi::loro::Bridging<UniffiVTableCallbackInterfaceUnsubscriber>::fromJs(
          rt, callInvoker, args[0]);

  std::lock_guard<std::mutex> lock(uniffi::loro::registry::vtableMutex);
  uniffi_loro_rs_fn_init_callback_vtable_unsubscriber(
      uniffi::loro::registry::putTable(
          "UniffiVTableCallbackInterfaceUnsubscriber", vtableInstance));
  return jsi::Value::undefined();
}