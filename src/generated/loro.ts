// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
  type UniffiVTableCallbackInterfaceChangeAncestorsTraveler,
  type UniffiVTableCallbackInterfaceContainerIdLike,
  type UniffiVTableCallbackInterfaceEphemeralSubscriber,
  type UniffiVTableCallbackInterfaceFirstCommitFromPeerCallback,
  type UniffiVTableCallbackInterfaceLocalEphemeralListener,
  type UniffiVTableCallbackInterfaceLocalUpdateCallback,
  type UniffiVTableCallbackInterfaceLoroValueLike,
  type UniffiVTableCallbackInterfaceOnPop,
  type UniffiVTableCallbackInterfaceOnPush,
  type UniffiVTableCallbackInterfacePreCommitCallback,
  type UniffiVTableCallbackInterfaceSubscriber,
  type UniffiVTableCallbackInterfaceUnsubscriber,
  type UniffiVTableCallbackInterfaceValueOrContainer,
} from './loro-ffi';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiHandle,
  type UniffiObjectFactory,
  type UniffiReferenceHolder,
  type UniffiRustArcPtr,
  type UniffiRustCallStatus,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterArrayBuffer,
  FfiConverterBool,
  FfiConverterFloat64,
  FfiConverterInt32,
  FfiConverterInt64,
  FfiConverterMap,
  FfiConverterObject,
  FfiConverterObjectWithCallbacks,
  FfiConverterOptional,
  FfiConverterUInt32,
  FfiConverterUInt64,
  FfiConverterUInt8,
  RustBuffer,
  UniffiAbstractObject,
  UniffiEnum,
  UniffiError,
  UniffiInternalError,
  UniffiResult,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiTraitInterfaceCall,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller();

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

/**
 * Decodes the metadata for an imported blob from the provided bytes.
 */
export function decodeImportBlobMeta(
  bytes: ArrayBuffer,
  checkChecksum: boolean
): ImportBlobMetadata /*throws*/ {
  return FfiConverterTypeImportBlobMetadata.lift(
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_func_decode_import_blob_meta(
          FfiConverterArrayBuffer.lower(bytes),
          FfiConverterBool.lower(checkChecksum),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}
export function getVersion(): string {
  return FfiConverterString.lift(
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_func_get_version(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    )
  );
}

export type AbsolutePosition = {
  pos: /*u32*/ number;
  side: Side;
};

/**
 * Generated factory for {@link AbsolutePosition} record objects.
 */
export const AbsolutePosition = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<AbsolutePosition, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AbsolutePosition}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AbsolutePosition}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<AbsolutePosition>,
  });
})();

const FfiConverterTypeAbsolutePosition = (() => {
  type TypeName = AbsolutePosition;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        pos: FfiConverterUInt32.read(from),
        side: FfiConverterTypeSide.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.pos, into);
      FfiConverterTypeSide.write(value.side, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.pos) +
        FfiConverterTypeSide.allocationSize(value.side)
      );
    }
  }
  return new FFIConverter();
})();

export type AwarenessPeerUpdate = {
  updated: Array</*u64*/ bigint>;
  added: Array</*u64*/ bigint>;
};

/**
 * Generated factory for {@link AwarenessPeerUpdate} record objects.
 */
export const AwarenessPeerUpdate = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<AwarenessPeerUpdate, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link AwarenessPeerUpdate}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link AwarenessPeerUpdate}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<AwarenessPeerUpdate>,
  });
})();

const FfiConverterTypeAwarenessPeerUpdate = (() => {
  type TypeName = AwarenessPeerUpdate;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        updated: FfiConverterArrayUInt64.read(from),
        added: FfiConverterArrayUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayUInt64.write(value.updated, into);
      FfiConverterArrayUInt64.write(value.added, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayUInt64.allocationSize(value.updated) +
        FfiConverterArrayUInt64.allocationSize(value.added)
      );
    }
  }
  return new FFIConverter();
})();

export type ChangeMeta = {
  /**
   * Lamport timestamp of the Change
   */
  lamport: /*u32*/ number;
  /**
   * The first Op id of the Change
   */
  id: Id;
  /**
   * [Unix time](https://en.wikipedia.org/wiki/Unix_time)
   * It is the number of seconds that have elapsed since 00:00:00 UTC on 1 January 1970.
   */
  timestamp: /*i64*/ bigint;
  /**
   * The commit message of the change
   */
  message: string | undefined;
  /**
   * The dependencies of the first op of the change
   */
  deps: FrontiersInterface;
  /**
   * The total op num inside this change
   */
  len: /*u32*/ number;
};

/**
 * Generated factory for {@link ChangeMeta} record objects.
 */
export const ChangeMeta = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ChangeMeta, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ChangeMeta}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ChangeMeta}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ChangeMeta>,
  });
})();

const FfiConverterTypeChangeMeta = (() => {
  type TypeName = ChangeMeta;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        lamport: FfiConverterUInt32.read(from),
        id: FfiConverterTypeID.read(from),
        timestamp: FfiConverterInt64.read(from),
        message: FfiConverterOptionalString.read(from),
        deps: FfiConverterTypeFrontiers.read(from),
        len: FfiConverterUInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.lamport, into);
      FfiConverterTypeID.write(value.id, into);
      FfiConverterInt64.write(value.timestamp, into);
      FfiConverterOptionalString.write(value.message, into);
      FfiConverterTypeFrontiers.write(value.deps, into);
      FfiConverterUInt32.write(value.len, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.lamport) +
        FfiConverterTypeID.allocationSize(value.id) +
        FfiConverterInt64.allocationSize(value.timestamp) +
        FfiConverterOptionalString.allocationSize(value.message) +
        FfiConverterTypeFrontiers.allocationSize(value.deps) +
        FfiConverterUInt32.allocationSize(value.len)
      );
    }
  }
  return new FFIConverter();
})();

export type CommitOptions = {
  origin: string | undefined;
  immediateRenew: boolean;
  timestamp: /*i64*/ bigint | undefined;
  commitMsg: string | undefined;
};

/**
 * Generated factory for {@link CommitOptions} record objects.
 */
export const CommitOptions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<CommitOptions, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CommitOptions}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CommitOptions}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CommitOptions>,
  });
})();

const FfiConverterTypeCommitOptions = (() => {
  type TypeName = CommitOptions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        origin: FfiConverterOptionalString.read(from),
        immediateRenew: FfiConverterBool.read(from),
        timestamp: FfiConverterOptionalInt64.read(from),
        commitMsg: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.origin, into);
      FfiConverterBool.write(value.immediateRenew, into);
      FfiConverterOptionalInt64.write(value.timestamp, into);
      FfiConverterOptionalString.write(value.commitMsg, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.origin) +
        FfiConverterBool.allocationSize(value.immediateRenew) +
        FfiConverterOptionalInt64.allocationSize(value.timestamp) +
        FfiConverterOptionalString.allocationSize(value.commitMsg)
      );
    }
  }
  return new FFIConverter();
})();

/**
 * A diff of a container.
 */
export type ContainerDiff = {
  /**
   * The target container id of the diff.
   */
  target: ContainerId;
  /**
   * The path of the diff.
   */
  path: Array<PathItem>;
  /**
   * Whether the diff is from unknown container.
   */
  isUnknown: boolean;
  /**
   * The diff
   */
  diff: Diff;
};

/**
 * Generated factory for {@link ContainerDiff} record objects.
 */
export const ContainerDiff = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ContainerDiff, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ContainerDiff}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ContainerDiff}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ContainerDiff>,
  });
})();

const FfiConverterTypeContainerDiff = (() => {
  type TypeName = ContainerDiff;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        target: FfiConverterTypeContainerID.read(from),
        path: FfiConverterArrayTypePathItem.read(from),
        isUnknown: FfiConverterBool.read(from),
        diff: FfiConverterTypeDiff.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeContainerID.write(value.target, into);
      FfiConverterArrayTypePathItem.write(value.path, into);
      FfiConverterBool.write(value.isUnknown, into);
      FfiConverterTypeDiff.write(value.diff, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeContainerID.allocationSize(value.target) +
        FfiConverterArrayTypePathItem.allocationSize(value.path) +
        FfiConverterBool.allocationSize(value.isUnknown) +
        FfiConverterTypeDiff.allocationSize(value.diff)
      );
    }
  }
  return new FFIConverter();
})();

export type ContainerIdAndDiff = {
  cid: ContainerId;
  diff: Diff;
};

/**
 * Generated factory for {@link ContainerIdAndDiff} record objects.
 */
export const ContainerIdAndDiff = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ContainerIdAndDiff, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ContainerIdAndDiff}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ContainerIdAndDiff}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ContainerIdAndDiff>,
  });
})();

const FfiConverterTypeContainerIDAndDiff = (() => {
  type TypeName = ContainerIdAndDiff;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        cid: FfiConverterTypeContainerID.read(from),
        diff: FfiConverterTypeDiff.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeContainerID.write(value.cid, into);
      FfiConverterTypeDiff.write(value.diff, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeContainerID.allocationSize(value.cid) +
        FfiConverterTypeDiff.allocationSize(value.diff)
      );
    }
  }
  return new FFIConverter();
})();

export type ContainerPath = {
  id: ContainerId;
  path: Index;
};

/**
 * Generated factory for {@link ContainerPath} record objects.
 */
export const ContainerPath = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ContainerPath, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ContainerPath}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ContainerPath}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ContainerPath>,
  });
})();

const FfiConverterTypeContainerPath = (() => {
  type TypeName = ContainerPath;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        id: FfiConverterTypeContainerID.read(from),
        path: FfiConverterTypeIndex.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeContainerID.write(value.id, into);
      FfiConverterTypeIndex.write(value.path, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeContainerID.allocationSize(value.id) +
        FfiConverterTypeIndex.allocationSize(value.path)
      );
    }
  }
  return new FFIConverter();
})();

export type CounterSpan = {
  start: /*i32*/ number;
  end: /*i32*/ number;
};

/**
 * Generated factory for {@link CounterSpan} record objects.
 */
export const CounterSpan = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<CounterSpan, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CounterSpan}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CounterSpan}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CounterSpan>,
  });
})();

const FfiConverterTypeCounterSpan = (() => {
  type TypeName = CounterSpan;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        start: FfiConverterInt32.read(from),
        end: FfiConverterInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterInt32.write(value.start, into);
      FfiConverterInt32.write(value.end, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterInt32.allocationSize(value.start) +
        FfiConverterInt32.allocationSize(value.end)
      );
    }
  }
  return new FFIConverter();
})();

export type CursorWithPos = {
  cursor: CursorInterface;
  pos: AbsolutePosition;
};

/**
 * Generated factory for {@link CursorWithPos} record objects.
 */
export const CursorWithPos = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<CursorWithPos, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link CursorWithPos}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link CursorWithPos}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<CursorWithPos>,
  });
})();

const FfiConverterTypeCursorWithPos = (() => {
  type TypeName = CursorWithPos;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        cursor: FfiConverterTypeCursor.read(from),
        pos: FfiConverterTypeAbsolutePosition.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeCursor.write(value.cursor, into);
      FfiConverterTypeAbsolutePosition.write(value.pos, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeCursor.allocationSize(value.cursor) +
        FfiConverterTypeAbsolutePosition.allocationSize(value.pos)
      );
    }
  }
  return new FFIConverter();
})();

export type DiffEvent = {
  /**
   * How the event is triggered.
   */
  triggeredBy: EventTriggerKind;
  /**
   * The origin of the event.
   */
  origin: string;
  /**
   * The current receiver of the event.
   */
  currentTarget: ContainerId | undefined;
  /**
   * The diffs of the event.
   */
  events: Array<ContainerDiff>;
};

/**
 * Generated factory for {@link DiffEvent} record objects.
 */
export const DiffEvent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<DiffEvent, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link DiffEvent}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link DiffEvent}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<DiffEvent>,
  });
})();

const FfiConverterTypeDiffEvent = (() => {
  type TypeName = DiffEvent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        triggeredBy: FfiConverterTypeEventTriggerKind.read(from),
        origin: FfiConverterString.read(from),
        currentTarget: FfiConverterOptionalTypeContainerID.read(from),
        events: FfiConverterArrayTypeContainerDiff.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeEventTriggerKind.write(value.triggeredBy, into);
      FfiConverterString.write(value.origin, into);
      FfiConverterOptionalTypeContainerID.write(value.currentTarget, into);
      FfiConverterArrayTypeContainerDiff.write(value.events, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeEventTriggerKind.allocationSize(value.triggeredBy) +
        FfiConverterString.allocationSize(value.origin) +
        FfiConverterOptionalTypeContainerID.allocationSize(
          value.currentTarget
        ) +
        FfiConverterArrayTypeContainerDiff.allocationSize(value.events)
      );
    }
  }
  return new FFIConverter();
})();

export type EphemeralStoreEvent = {
  by: EphemeralEventTrigger;
  added: Array<string>;
  removed: Array<string>;
  updated: Array<string>;
};

/**
 * Generated factory for {@link EphemeralStoreEvent} record objects.
 */
export const EphemeralStoreEvent = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<EphemeralStoreEvent, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EphemeralStoreEvent}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EphemeralStoreEvent}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<EphemeralStoreEvent>,
  });
})();

const FfiConverterTypeEphemeralStoreEvent = (() => {
  type TypeName = EphemeralStoreEvent;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        by: FfiConverterTypeEphemeralEventTrigger.read(from),
        added: FfiConverterArrayString.read(from),
        removed: FfiConverterArrayString.read(from),
        updated: FfiConverterArrayString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeEphemeralEventTrigger.write(value.by, into);
      FfiConverterArrayString.write(value.added, into);
      FfiConverterArrayString.write(value.removed, into);
      FfiConverterArrayString.write(value.updated, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeEphemeralEventTrigger.allocationSize(value.by) +
        FfiConverterArrayString.allocationSize(value.added) +
        FfiConverterArrayString.allocationSize(value.removed) +
        FfiConverterArrayString.allocationSize(value.updated)
      );
    }
  }
  return new FFIConverter();
})();

export type FirstCommitFromPeerPayload = {
  peer: /*u64*/ bigint;
};

/**
 * Generated factory for {@link FirstCommitFromPeerPayload} record objects.
 */
export const FirstCommitFromPeerPayload = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      FirstCommitFromPeerPayload,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FirstCommitFromPeerPayload}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FirstCommitFromPeerPayload}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<FirstCommitFromPeerPayload>,
  });
})();

const FfiConverterTypeFirstCommitFromPeerPayload = (() => {
  type TypeName = FirstCommitFromPeerPayload;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        peer: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.peer, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterUInt64.allocationSize(value.peer);
    }
  }
  return new FFIConverter();
})();

export type FrontiersOrId = {
  frontiers: FrontiersInterface | undefined;
  id: Id | undefined;
};

/**
 * Generated factory for {@link FrontiersOrId} record objects.
 */
export const FrontiersOrId = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<FrontiersOrId, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link FrontiersOrId}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link FrontiersOrId}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<FrontiersOrId>,
  });
})();

const FfiConverterTypeFrontiersOrID = (() => {
  type TypeName = FrontiersOrId;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        frontiers: FfiConverterOptionalTypeFrontiers.read(from),
        id: FfiConverterOptionalTypeID.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalTypeFrontiers.write(value.frontiers, into);
      FfiConverterOptionalTypeID.write(value.id, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalTypeFrontiers.allocationSize(value.frontiers) +
        FfiConverterOptionalTypeID.allocationSize(value.id)
      );
    }
  }
  return new FFIConverter();
})();

export type Id = {
  peer: /*u64*/ bigint;
  counter: /*i32*/ number;
};

/**
 * Generated factory for {@link Id} record objects.
 */
export const Id = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Id, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Id}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Id}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Id>,
  });
})();

const FfiConverterTypeID = (() => {
  type TypeName = Id;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        peer: FfiConverterUInt64.read(from),
        counter: FfiConverterInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.peer, into);
      FfiConverterInt32.write(value.counter, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.peer) +
        FfiConverterInt32.allocationSize(value.counter)
      );
    }
  }
  return new FFIConverter();
})();

export type IdLp = {
  lamport: /*u32*/ number;
  peer: /*u64*/ bigint;
};

/**
 * Generated factory for {@link IdLp} record objects.
 */
export const IdLp = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<IdLp, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link IdLp}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link IdLp}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<IdLp>,
  });
})();

const FfiConverterTypeIdLp = (() => {
  type TypeName = IdLp;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        lamport: FfiConverterUInt32.read(from),
        peer: FfiConverterUInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt32.write(value.lamport, into);
      FfiConverterUInt64.write(value.peer, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt32.allocationSize(value.lamport) +
        FfiConverterUInt64.allocationSize(value.peer)
      );
    }
  }
  return new FFIConverter();
})();

export type IdSpan = {
  peer: /*u64*/ bigint;
  counter: CounterSpan;
};

/**
 * Generated factory for {@link IdSpan} record objects.
 */
export const IdSpan = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<IdSpan, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link IdSpan}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link IdSpan}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<IdSpan>,
  });
})();

const FfiConverterTypeIdSpan = (() => {
  type TypeName = IdSpan;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        peer: FfiConverterUInt64.read(from),
        counter: FfiConverterTypeCounterSpan.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.peer, into);
      FfiConverterTypeCounterSpan.write(value.counter, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.peer) +
        FfiConverterTypeCounterSpan.allocationSize(value.counter)
      );
    }
  }
  return new FFIConverter();
})();

export type ImportBlobMetadata = {
  /**
   * The partial start version vector.
   *
   * Import blob includes all the ops from `partial_start_vv` to `partial_end_vv`.
   * However, it does not constitute a complete version vector, as it only contains counters
   * from peers included within the import blob.
   */
  partialStartVv: VersionVectorInterface;
  /**
   * The partial end version vector.
   *
   * Import blob includes all the ops from `partial_start_vv` to `partial_end_vv`.
   * However, it does not constitute a complete version vector, as it only contains counters
   * from peers included within the import blob.
   */
  partialEndVv: VersionVectorInterface;
  startTimestamp: /*i64*/ bigint;
  startFrontiers: FrontiersInterface;
  endTimestamp: /*i64*/ bigint;
  changeNum: /*u32*/ number;
  mode: string;
};

/**
 * Generated factory for {@link ImportBlobMetadata} record objects.
 */
export const ImportBlobMetadata = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ImportBlobMetadata, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ImportBlobMetadata}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ImportBlobMetadata}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ImportBlobMetadata>,
  });
})();

const FfiConverterTypeImportBlobMetadata = (() => {
  type TypeName = ImportBlobMetadata;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        partialStartVv: FfiConverterTypeVersionVector.read(from),
        partialEndVv: FfiConverterTypeVersionVector.read(from),
        startTimestamp: FfiConverterInt64.read(from),
        startFrontiers: FfiConverterTypeFrontiers.read(from),
        endTimestamp: FfiConverterInt64.read(from),
        changeNum: FfiConverterUInt32.read(from),
        mode: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeVersionVector.write(value.partialStartVv, into);
      FfiConverterTypeVersionVector.write(value.partialEndVv, into);
      FfiConverterInt64.write(value.startTimestamp, into);
      FfiConverterTypeFrontiers.write(value.startFrontiers, into);
      FfiConverterInt64.write(value.endTimestamp, into);
      FfiConverterUInt32.write(value.changeNum, into);
      FfiConverterString.write(value.mode, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeVersionVector.allocationSize(value.partialStartVv) +
        FfiConverterTypeVersionVector.allocationSize(value.partialEndVv) +
        FfiConverterInt64.allocationSize(value.startTimestamp) +
        FfiConverterTypeFrontiers.allocationSize(value.startFrontiers) +
        FfiConverterInt64.allocationSize(value.endTimestamp) +
        FfiConverterUInt32.allocationSize(value.changeNum) +
        FfiConverterString.allocationSize(value.mode)
      );
    }
  }
  return new FFIConverter();
})();

export type ImportStatus = {
  success: Map</*u64*/ bigint, CounterSpan>;
  pending: Map</*u64*/ bigint, CounterSpan> | undefined;
};

/**
 * Generated factory for {@link ImportStatus} record objects.
 */
export const ImportStatus = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ImportStatus, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ImportStatus}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ImportStatus}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ImportStatus>,
  });
})();

const FfiConverterTypeImportStatus = (() => {
  type TypeName = ImportStatus;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        success: FfiConverterMapUInt64TypeCounterSpan.read(from),
        pending: FfiConverterOptionalMapUInt64TypeCounterSpan.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterMapUInt64TypeCounterSpan.write(value.success, into);
      FfiConverterOptionalMapUInt64TypeCounterSpan.write(value.pending, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterMapUInt64TypeCounterSpan.allocationSize(value.success) +
        FfiConverterOptionalMapUInt64TypeCounterSpan.allocationSize(
          value.pending
        )
      );
    }
  }
  return new FFIConverter();
})();

export type MapDelta = {
  updated: Map<string, ValueOrContainerInterface | undefined>;
};

/**
 * Generated factory for {@link MapDelta} record objects.
 */
export const MapDelta = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<MapDelta, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link MapDelta}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link MapDelta}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<MapDelta>,
  });
})();

const FfiConverterTypeMapDelta = (() => {
  type TypeName = MapDelta;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        updated: FfiConverterMapStringOptionalTypeValueOrContainer.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterMapStringOptionalTypeValueOrContainer.write(
        value.updated,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return FfiConverterMapStringOptionalTypeValueOrContainer.allocationSize(
        value.updated
      );
    }
  }
  return new FFIConverter();
})();

export type PathItem = {
  container: ContainerId;
  index: Index;
};

/**
 * Generated factory for {@link PathItem} record objects.
 */
export const PathItem = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PathItem, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PathItem}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PathItem}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PathItem>,
  });
})();

const FfiConverterTypePathItem = (() => {
  type TypeName = PathItem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        container: FfiConverterTypeContainerID.read(from),
        index: FfiConverterTypeIndex.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeContainerID.write(value.container, into);
      FfiConverterTypeIndex.write(value.index, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeContainerID.allocationSize(value.container) +
        FfiConverterTypeIndex.allocationSize(value.index)
      );
    }
  }
  return new FFIConverter();
})();

export type PeerInfo = {
  state: LoroValue;
  counter: /*i32*/ number;
  timestamp: /*i64*/ bigint;
};

/**
 * Generated factory for {@link PeerInfo} record objects.
 */
export const PeerInfo = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PeerInfo, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PeerInfo}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PeerInfo}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PeerInfo>,
  });
})();

const FfiConverterTypePeerInfo = (() => {
  type TypeName = PeerInfo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        state: FfiConverterTypeLoroValue.read(from),
        counter: FfiConverterInt32.read(from),
        timestamp: FfiConverterInt64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeLoroValue.write(value.state, into);
      FfiConverterInt32.write(value.counter, into);
      FfiConverterInt64.write(value.timestamp, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeLoroValue.allocationSize(value.state) +
        FfiConverterInt32.allocationSize(value.counter) +
        FfiConverterInt64.allocationSize(value.timestamp)
      );
    }
  }
  return new FFIConverter();
})();

export type PosQueryResult = {
  update: CursorInterface | undefined;
  current: AbsolutePosition;
};

/**
 * Generated factory for {@link PosQueryResult} record objects.
 */
export const PosQueryResult = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<PosQueryResult, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PosQueryResult}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PosQueryResult}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<PosQueryResult>,
  });
})();

const FfiConverterTypePosQueryResult = (() => {
  type TypeName = PosQueryResult;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        update: FfiConverterOptionalTypeCursor.read(from),
        current: FfiConverterTypeAbsolutePosition.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalTypeCursor.write(value.update, into);
      FfiConverterTypeAbsolutePosition.write(value.current, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalTypeCursor.allocationSize(value.update) +
        FfiConverterTypeAbsolutePosition.allocationSize(value.current)
      );
    }
  }
  return new FFIConverter();
})();

export type PreCommitCallbackPayload = {
  changeMeta: ChangeMeta;
  origin: string;
  modifier: ChangeModifierInterface;
};

/**
 * Generated factory for {@link PreCommitCallbackPayload} record objects.
 */
export const PreCommitCallbackPayload = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      PreCommitCallbackPayload,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link PreCommitCallbackPayload}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link PreCommitCallbackPayload}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<PreCommitCallbackPayload>,
  });
})();

const FfiConverterTypePreCommitCallbackPayload = (() => {
  type TypeName = PreCommitCallbackPayload;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        changeMeta: FfiConverterTypeChangeMeta.read(from),
        origin: FfiConverterString.read(from),
        modifier: FfiConverterTypeChangeModifier.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeChangeMeta.write(value.changeMeta, into);
      FfiConverterString.write(value.origin, into);
      FfiConverterTypeChangeModifier.write(value.modifier, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeChangeMeta.allocationSize(value.changeMeta) +
        FfiConverterString.allocationSize(value.origin) +
        FfiConverterTypeChangeModifier.allocationSize(value.modifier)
      );
    }
  }
  return new FFIConverter();
})();

export type StyleConfig = {
  expand: ExpandType;
};

/**
 * Generated factory for {@link StyleConfig} record objects.
 */
export const StyleConfig = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<StyleConfig, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link StyleConfig}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link StyleConfig}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<StyleConfig>,
  });
})();

const FfiConverterTypeStyleConfig = (() => {
  type TypeName = StyleConfig;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        expand: FfiConverterTypeExpandType.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeExpandType.write(value.expand, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterTypeExpandType.allocationSize(value.expand);
    }
  }
  return new FFIConverter();
})();

export type TreeDiff = {
  diff: Array<TreeDiffItem>;
};

/**
 * Generated factory for {@link TreeDiff} record objects.
 */
export const TreeDiff = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TreeDiff, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TreeDiff}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TreeDiff}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TreeDiff>,
  });
})();

const FfiConverterTypeTreeDiff = (() => {
  type TypeName = TreeDiff;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        diff: FfiConverterArrayTypeTreeDiffItem.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeTreeDiffItem.write(value.diff, into);
    }
    allocationSize(value: TypeName): number {
      return FfiConverterArrayTypeTreeDiffItem.allocationSize(value.diff);
    }
  }
  return new FFIConverter();
})();

export type TreeDiffItem = {
  target: TreeId;
  action: TreeExternalDiff;
};

/**
 * Generated factory for {@link TreeDiffItem} record objects.
 */
export const TreeDiffItem = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TreeDiffItem, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TreeDiffItem}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TreeDiffItem}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TreeDiffItem>,
  });
})();

const FfiConverterTypeTreeDiffItem = (() => {
  type TypeName = TreeDiffItem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        target: FfiConverterTypeTreeID.read(from),
        action: FfiConverterTypeTreeExternalDiff.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeTreeID.write(value.target, into);
      FfiConverterTypeTreeExternalDiff.write(value.action, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeTreeID.allocationSize(value.target) +
        FfiConverterTypeTreeExternalDiff.allocationSize(value.action)
      );
    }
  }
  return new FFIConverter();
})();

export type TreeId = {
  peer: /*u64*/ bigint;
  counter: /*i32*/ number;
};

/**
 * Generated factory for {@link TreeId} record objects.
 */
export const TreeId = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<TreeId, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link TreeId}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link TreeId}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<TreeId>,
  });
})();

const FfiConverterTypeTreeID = (() => {
  type TypeName = TreeId;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        peer: FfiConverterUInt64.read(from),
        counter: FfiConverterInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.peer, into);
      FfiConverterInt32.write(value.counter, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.peer) +
        FfiConverterInt32.allocationSize(value.counter)
      );
    }
  }
  return new FFIConverter();
})();

export type UndoItemMeta = {
  value: LoroValue;
  cursors: Array<CursorWithPos>;
};

/**
 * Generated factory for {@link UndoItemMeta} record objects.
 */
export const UndoItemMeta = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<UndoItemMeta, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UndoItemMeta}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UndoItemMeta}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UndoItemMeta>,
  });
})();

const FfiConverterTypeUndoItemMeta = (() => {
  type TypeName = UndoItemMeta;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        value: FfiConverterTypeLoroValue.read(from),
        cursors: FfiConverterArrayTypeCursorWithPos.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterTypeLoroValue.write(value.value, into);
      FfiConverterArrayTypeCursorWithPos.write(value.cursors, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterTypeLoroValue.allocationSize(value.value) +
        FfiConverterArrayTypeCursorWithPos.allocationSize(value.cursors)
      );
    }
  }
  return new FFIConverter();
})();

export type UpdateOptions = {
  timeoutMs: /*f64*/ number | undefined;
  useRefinedDiff: boolean;
};

/**
 * Generated factory for {@link UpdateOptions} record objects.
 */
export const UpdateOptions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<UpdateOptions, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link UpdateOptions}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link UpdateOptions}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<UpdateOptions>,
  });
})();

const FfiConverterTypeUpdateOptions = (() => {
  type TypeName = UpdateOptions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        timeoutMs: FfiConverterOptionalFloat64.read(from),
        useRefinedDiff: FfiConverterBool.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalFloat64.write(value.timeoutMs, into);
      FfiConverterBool.write(value.useRefinedDiff, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalFloat64.allocationSize(value.timeoutMs) +
        FfiConverterBool.allocationSize(value.useRefinedDiff)
      );
    }
  }
  return new FFIConverter();
})();

export type VersionRangeItem = {
  peer: /*u64*/ bigint;
  start: /*i32*/ number;
  end: /*i32*/ number;
};

/**
 * Generated factory for {@link VersionRangeItem} record objects.
 */
export const VersionRangeItem = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<VersionRangeItem, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VersionRangeItem}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link VersionRangeItem}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<VersionRangeItem>,
  });
})();

const FfiConverterTypeVersionRangeItem = (() => {
  type TypeName = VersionRangeItem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        peer: FfiConverterUInt64.read(from),
        start: FfiConverterInt32.read(from),
        end: FfiConverterInt32.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterUInt64.write(value.peer, into);
      FfiConverterInt32.write(value.start, into);
      FfiConverterInt32.write(value.end, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterUInt64.allocationSize(value.peer) +
        FfiConverterInt32.allocationSize(value.start) +
        FfiConverterInt32.allocationSize(value.end)
      );
    }
  }
  return new FFIConverter();
})();

export type VersionVectorDiff = {
  /**
   * need to add these spans to move from right to left
   */
  retreat: Map</*u64*/ bigint, CounterSpan>;
  /**
   * need to add these spans to move from left to right
   */
  forward: Map</*u64*/ bigint, CounterSpan>;
};

/**
 * Generated factory for {@link VersionVectorDiff} record objects.
 */
export const VersionVectorDiff = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<VersionVectorDiff, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VersionVectorDiff}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link VersionVectorDiff}, with defaults specified
     * in Rust, in the {@link loro} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link loro} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<VersionVectorDiff>,
  });
})();

const FfiConverterTypeVersionVectorDiff = (() => {
  type TypeName = VersionVectorDiff;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        retreat: FfiConverterMapUInt64TypeCounterSpan.read(from),
        forward: FfiConverterMapUInt64TypeCounterSpan.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterMapUInt64TypeCounterSpan.write(value.retreat, into);
      FfiConverterMapUInt64TypeCounterSpan.write(value.forward, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterMapUInt64TypeCounterSpan.allocationSize(value.retreat) +
        FfiConverterMapUInt64TypeCounterSpan.allocationSize(value.forward)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Flat error type: CannotFindRelativePosition
export enum CannotFindRelativePosition_Tags {
  ContainerDeleted = 'ContainerDeleted',
  HistoryCleared = 'HistoryCleared',
  IdNotFound = 'IdNotFound',
}
export const CannotFindRelativePosition = (() => {
  class ContainerDeleted extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'CannotFindRelativePosition';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = CannotFindRelativePosition_Tags.ContainerDeleted;

    constructor(message: string) {
      super('CannotFindRelativePosition', 'ContainerDeleted', message);
    }

    static instanceOf(e: any): e is ContainerDeleted {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class HistoryCleared extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'CannotFindRelativePosition';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = CannotFindRelativePosition_Tags.HistoryCleared;

    constructor(message: string) {
      super('CannotFindRelativePosition', 'HistoryCleared', message);
    }

    static instanceOf(e: any): e is HistoryCleared {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class IdNotFound extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'CannotFindRelativePosition';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = CannotFindRelativePosition_Tags.IdNotFound;

    constructor(message: string) {
      super('CannotFindRelativePosition', 'IdNotFound', message);
    }

    static instanceOf(e: any): e is IdNotFound {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is CannotFindRelativePosition {
    return (e as any)[uniffiTypeNameSymbol] === 'CannotFindRelativePosition';
  }
  return {
    ContainerDeleted,
    HistoryCleared,
    IdNotFound,
    instanceOf,
  };
})();

// Union type for CannotFindRelativePosition error type.

export type CannotFindRelativePosition = InstanceType<
  (typeof CannotFindRelativePosition)[keyof Omit<
    typeof CannotFindRelativePosition,
    'instanceOf'
  >]
>;

const FfiConverterTypeCannotFindRelativePosition = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = CannotFindRelativePosition;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new CannotFindRelativePosition.ContainerDeleted(
            FfiConverterString.read(from)
          );

        case 2:
          return new CannotFindRelativePosition.HistoryCleared(
            FfiConverterString.read(from)
          );

        case 3:
          return new CannotFindRelativePosition.IdNotFound(
            FfiConverterString.read(from)
          );

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Flat error type: ChangeTravelError
export enum ChangeTravelError_Tags {
  TargetIdNotFound = 'TargetIdNotFound',
  TargetVersionNotIncluded = 'TargetVersionNotIncluded',
}
export const ChangeTravelError = (() => {
  class TargetIdNotFound extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ChangeTravelError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = ChangeTravelError_Tags.TargetIdNotFound;

    constructor(message: string) {
      super('ChangeTravelError', 'TargetIdNotFound', message);
    }

    static instanceOf(e: any): e is TargetIdNotFound {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class TargetVersionNotIncluded extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'ChangeTravelError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = ChangeTravelError_Tags.TargetVersionNotIncluded;

    constructor(message: string) {
      super('ChangeTravelError', 'TargetVersionNotIncluded', message);
    }

    static instanceOf(e: any): e is TargetVersionNotIncluded {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is ChangeTravelError {
    return (e as any)[uniffiTypeNameSymbol] === 'ChangeTravelError';
  }
  return {
    TargetIdNotFound,
    TargetVersionNotIncluded,
    instanceOf,
  };
})();

// Union type for ChangeTravelError error type.

export type ChangeTravelError = InstanceType<
  (typeof ChangeTravelError)[keyof Omit<typeof ChangeTravelError, 'instanceOf'>]
>;

const FfiConverterTypeChangeTravelError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = ChangeTravelError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new ChangeTravelError.TargetIdNotFound(
            FfiConverterString.read(from)
          );

        case 2:
          return new ChangeTravelError.TargetVersionNotIncluded(
            FfiConverterString.read(from)
          );

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Enum: ContainerId
export enum ContainerId_Tags {
  Root = 'Root',
  Normal = 'Normal',
}
export const ContainerId = (() => {
  type Root__interface = {
    tag: ContainerId_Tags.Root;
    inner: Readonly<{ name: string; containerType: ContainerType }>;
  };

  class Root_ extends UniffiEnum implements Root__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ContainerId';
    readonly tag = ContainerId_Tags.Root;
    readonly inner: Readonly<{ name: string; containerType: ContainerType }>;
    constructor(inner: { name: string; containerType: ContainerType }) {
      super('ContainerId', 'Root');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { name: string; containerType: ContainerType }): Root_ {
      return new Root_(inner);
    }

    static instanceOf(obj: any): obj is Root_ {
      return obj.tag === ContainerId_Tags.Root;
    }
  }

  type Normal__interface = {
    tag: ContainerId_Tags.Normal;
    inner: Readonly<{
      peer: /*u64*/ bigint;
      counter: /*i32*/ number;
      containerType: ContainerType;
    }>;
  };

  class Normal_ extends UniffiEnum implements Normal__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ContainerId';
    readonly tag = ContainerId_Tags.Normal;
    readonly inner: Readonly<{
      peer: /*u64*/ bigint;
      counter: /*i32*/ number;
      containerType: ContainerType;
    }>;
    constructor(inner: {
      peer: /*u64*/ bigint;
      counter: /*i32*/ number;
      containerType: ContainerType;
    }) {
      super('ContainerId', 'Normal');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      peer: /*u64*/ bigint;
      counter: /*i32*/ number;
      containerType: ContainerType;
    }): Normal_ {
      return new Normal_(inner);
    }

    static instanceOf(obj: any): obj is Normal_ {
      return obj.tag === ContainerId_Tags.Normal;
    }
  }

  function instanceOf(obj: any): obj is ContainerId {
    return obj[uniffiTypeNameSymbol] === 'ContainerId';
  }

  return Object.freeze({
    instanceOf,
    Root: Root_,
    Normal: Normal_,
  });
})();

export type ContainerId = InstanceType<
  (typeof ContainerId)[keyof Omit<typeof ContainerId, 'instanceOf'>]
>;

// FfiConverter for enum ContainerId
const FfiConverterTypeContainerID = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ContainerId;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ContainerId.Root({
            name: FfiConverterString.read(from),
            containerType: FfiConverterTypeContainerType.read(from),
          });
        case 2:
          return new ContainerId.Normal({
            peer: FfiConverterUInt64.read(from),
            counter: FfiConverterInt32.read(from),
            containerType: FfiConverterTypeContainerType.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ContainerId_Tags.Root: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.name, into);
          FfiConverterTypeContainerType.write(inner.containerType, into);
          return;
        }
        case ContainerId_Tags.Normal: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt64.write(inner.peer, into);
          FfiConverterInt32.write(inner.counter, into);
          FfiConverterTypeContainerType.write(inner.containerType, into);
          return;
        }
        default:
          // Throwing from here means that ContainerId_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ContainerId_Tags.Root: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.name);
          size += FfiConverterTypeContainerType.allocationSize(
            inner.containerType
          );
          return size;
        }
        case ContainerId_Tags.Normal: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt64.allocationSize(inner.peer);
          size += FfiConverterInt32.allocationSize(inner.counter);
          size += FfiConverterTypeContainerType.allocationSize(
            inner.containerType
          );
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: ContainerType
export enum ContainerType_Tags {
  Text = 'Text',
  Map = 'Map',
  List = 'List',
  MovableList = 'MovableList',
  Tree = 'Tree',
  Counter = 'Counter',
  Unknown = 'Unknown',
}
export const ContainerType = (() => {
  type Text__interface = {
    tag: ContainerType_Tags.Text;
  };

  class Text_ extends UniffiEnum implements Text__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ContainerType';
    readonly tag = ContainerType_Tags.Text;
    constructor() {
      super('ContainerType', 'Text');
    }

    static new(): Text_ {
      return new Text_();
    }

    static instanceOf(obj: any): obj is Text_ {
      return obj.tag === ContainerType_Tags.Text;
    }
  }

  type Map__interface = {
    tag: ContainerType_Tags.Map;
  };

  class Map_ extends UniffiEnum implements Map__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ContainerType';
    readonly tag = ContainerType_Tags.Map;
    constructor() {
      super('ContainerType', 'Map');
    }

    static new(): Map_ {
      return new Map_();
    }

    static instanceOf(obj: any): obj is Map_ {
      return obj.tag === ContainerType_Tags.Map;
    }
  }

  type List__interface = {
    tag: ContainerType_Tags.List;
  };

  class List_ extends UniffiEnum implements List__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ContainerType';
    readonly tag = ContainerType_Tags.List;
    constructor() {
      super('ContainerType', 'List');
    }

    static new(): List_ {
      return new List_();
    }

    static instanceOf(obj: any): obj is List_ {
      return obj.tag === ContainerType_Tags.List;
    }
  }

  type MovableList__interface = {
    tag: ContainerType_Tags.MovableList;
  };

  class MovableList_ extends UniffiEnum implements MovableList__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ContainerType';
    readonly tag = ContainerType_Tags.MovableList;
    constructor() {
      super('ContainerType', 'MovableList');
    }

    static new(): MovableList_ {
      return new MovableList_();
    }

    static instanceOf(obj: any): obj is MovableList_ {
      return obj.tag === ContainerType_Tags.MovableList;
    }
  }

  type Tree__interface = {
    tag: ContainerType_Tags.Tree;
  };

  class Tree_ extends UniffiEnum implements Tree__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ContainerType';
    readonly tag = ContainerType_Tags.Tree;
    constructor() {
      super('ContainerType', 'Tree');
    }

    static new(): Tree_ {
      return new Tree_();
    }

    static instanceOf(obj: any): obj is Tree_ {
      return obj.tag === ContainerType_Tags.Tree;
    }
  }

  type Counter__interface = {
    tag: ContainerType_Tags.Counter;
  };

  class Counter_ extends UniffiEnum implements Counter__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ContainerType';
    readonly tag = ContainerType_Tags.Counter;
    constructor() {
      super('ContainerType', 'Counter');
    }

    static new(): Counter_ {
      return new Counter_();
    }

    static instanceOf(obj: any): obj is Counter_ {
      return obj.tag === ContainerType_Tags.Counter;
    }
  }

  type Unknown__interface = {
    tag: ContainerType_Tags.Unknown;
    inner: Readonly<{ kind: /*u8*/ number }>;
  };

  class Unknown_ extends UniffiEnum implements Unknown__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ContainerType';
    readonly tag = ContainerType_Tags.Unknown;
    readonly inner: Readonly<{ kind: /*u8*/ number }>;
    constructor(inner: { kind: /*u8*/ number }) {
      super('ContainerType', 'Unknown');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { kind: /*u8*/ number }): Unknown_ {
      return new Unknown_(inner);
    }

    static instanceOf(obj: any): obj is Unknown_ {
      return obj.tag === ContainerType_Tags.Unknown;
    }
  }

  function instanceOf(obj: any): obj is ContainerType {
    return obj[uniffiTypeNameSymbol] === 'ContainerType';
  }

  return Object.freeze({
    instanceOf,
    Text: Text_,
    Map: Map_,
    List: List_,
    MovableList: MovableList_,
    Tree: Tree_,
    Counter: Counter_,
    Unknown: Unknown_,
  });
})();

export type ContainerType = InstanceType<
  (typeof ContainerType)[keyof Omit<typeof ContainerType, 'instanceOf'>]
>;

// FfiConverter for enum ContainerType
const FfiConverterTypeContainerType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ContainerType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ContainerType.Text();
        case 2:
          return new ContainerType.Map();
        case 3:
          return new ContainerType.List();
        case 4:
          return new ContainerType.MovableList();
        case 5:
          return new ContainerType.Tree();
        case 6:
          return new ContainerType.Counter();
        case 7:
          return new ContainerType.Unknown({
            kind: FfiConverterUInt8.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ContainerType_Tags.Text: {
          ordinalConverter.write(1, into);
          return;
        }
        case ContainerType_Tags.Map: {
          ordinalConverter.write(2, into);
          return;
        }
        case ContainerType_Tags.List: {
          ordinalConverter.write(3, into);
          return;
        }
        case ContainerType_Tags.MovableList: {
          ordinalConverter.write(4, into);
          return;
        }
        case ContainerType_Tags.Tree: {
          ordinalConverter.write(5, into);
          return;
        }
        case ContainerType_Tags.Counter: {
          ordinalConverter.write(6, into);
          return;
        }
        case ContainerType_Tags.Unknown: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterUInt8.write(inner.kind, into);
          return;
        }
        default:
          // Throwing from here means that ContainerType_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ContainerType_Tags.Text: {
          return ordinalConverter.allocationSize(1);
        }
        case ContainerType_Tags.Map: {
          return ordinalConverter.allocationSize(2);
        }
        case ContainerType_Tags.List: {
          return ordinalConverter.allocationSize(3);
        }
        case ContainerType_Tags.MovableList: {
          return ordinalConverter.allocationSize(4);
        }
        case ContainerType_Tags.Tree: {
          return ordinalConverter.allocationSize(5);
        }
        case ContainerType_Tags.Counter: {
          return ordinalConverter.allocationSize(6);
        }
        case ContainerType_Tags.Unknown: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterUInt8.allocationSize(inner.kind);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: Diff
export enum Diff_Tags {
  List = 'List',
  Text = 'Text',
  Map = 'Map',
  Tree = 'Tree',
  Counter = 'Counter',
  Unknown = 'Unknown',
}
export const Diff = (() => {
  type List__interface = {
    tag: Diff_Tags.List;
    inner: Readonly<{ diff: Array<ListDiffItem> }>;
  };

  class List_ extends UniffiEnum implements List__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Diff';
    readonly tag = Diff_Tags.List;
    readonly inner: Readonly<{ diff: Array<ListDiffItem> }>;
    constructor(inner: { diff: Array<ListDiffItem> }) {
      super('Diff', 'List');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { diff: Array<ListDiffItem> }): List_ {
      return new List_(inner);
    }

    static instanceOf(obj: any): obj is List_ {
      return obj.tag === Diff_Tags.List;
    }
  }

  type Text__interface = {
    tag: Diff_Tags.Text;
    inner: Readonly<{ diff: Array<TextDelta> }>;
  };

  class Text_ extends UniffiEnum implements Text__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Diff';
    readonly tag = Diff_Tags.Text;
    readonly inner: Readonly<{ diff: Array<TextDelta> }>;
    constructor(inner: { diff: Array<TextDelta> }) {
      super('Diff', 'Text');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { diff: Array<TextDelta> }): Text_ {
      return new Text_(inner);
    }

    static instanceOf(obj: any): obj is Text_ {
      return obj.tag === Diff_Tags.Text;
    }
  }

  type Map__interface = {
    tag: Diff_Tags.Map;
    inner: Readonly<{ diff: MapDelta }>;
  };

  class Map_ extends UniffiEnum implements Map__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Diff';
    readonly tag = Diff_Tags.Map;
    readonly inner: Readonly<{ diff: MapDelta }>;
    constructor(inner: { diff: MapDelta }) {
      super('Diff', 'Map');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { diff: MapDelta }): Map_ {
      return new Map_(inner);
    }

    static instanceOf(obj: any): obj is Map_ {
      return obj.tag === Diff_Tags.Map;
    }
  }

  type Tree__interface = {
    tag: Diff_Tags.Tree;
    inner: Readonly<{ diff: TreeDiff }>;
  };

  class Tree_ extends UniffiEnum implements Tree__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Diff';
    readonly tag = Diff_Tags.Tree;
    readonly inner: Readonly<{ diff: TreeDiff }>;
    constructor(inner: { diff: TreeDiff }) {
      super('Diff', 'Tree');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { diff: TreeDiff }): Tree_ {
      return new Tree_(inner);
    }

    static instanceOf(obj: any): obj is Tree_ {
      return obj.tag === Diff_Tags.Tree;
    }
  }

  type Counter__interface = {
    tag: Diff_Tags.Counter;
    inner: Readonly<{ diff: /*f64*/ number }>;
  };

  class Counter_ extends UniffiEnum implements Counter__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Diff';
    readonly tag = Diff_Tags.Counter;
    readonly inner: Readonly<{ diff: /*f64*/ number }>;
    constructor(inner: { diff: /*f64*/ number }) {
      super('Diff', 'Counter');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { diff: /*f64*/ number }): Counter_ {
      return new Counter_(inner);
    }

    static instanceOf(obj: any): obj is Counter_ {
      return obj.tag === Diff_Tags.Counter;
    }
  }

  type Unknown__interface = {
    tag: Diff_Tags.Unknown;
  };

  class Unknown_ extends UniffiEnum implements Unknown__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Diff';
    readonly tag = Diff_Tags.Unknown;
    constructor() {
      super('Diff', 'Unknown');
    }

    static new(): Unknown_ {
      return new Unknown_();
    }

    static instanceOf(obj: any): obj is Unknown_ {
      return obj.tag === Diff_Tags.Unknown;
    }
  }

  function instanceOf(obj: any): obj is Diff {
    return obj[uniffiTypeNameSymbol] === 'Diff';
  }

  return Object.freeze({
    instanceOf,
    List: List_,
    Text: Text_,
    Map: Map_,
    Tree: Tree_,
    Counter: Counter_,
    Unknown: Unknown_,
  });
})();

export type Diff = InstanceType<
  (typeof Diff)[keyof Omit<typeof Diff, 'instanceOf'>]
>;

// FfiConverter for enum Diff
const FfiConverterTypeDiff = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Diff;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Diff.List({
            diff: FfiConverterArrayTypeListDiffItem.read(from),
          });
        case 2:
          return new Diff.Text({
            diff: FfiConverterArrayTypeTextDelta.read(from),
          });
        case 3:
          return new Diff.Map({ diff: FfiConverterTypeMapDelta.read(from) });
        case 4:
          return new Diff.Tree({ diff: FfiConverterTypeTreeDiff.read(from) });
        case 5:
          return new Diff.Counter({ diff: FfiConverterFloat64.read(from) });
        case 6:
          return new Diff.Unknown();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Diff_Tags.List: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterArrayTypeListDiffItem.write(inner.diff, into);
          return;
        }
        case Diff_Tags.Text: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterArrayTypeTextDelta.write(inner.diff, into);
          return;
        }
        case Diff_Tags.Map: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeMapDelta.write(inner.diff, into);
          return;
        }
        case Diff_Tags.Tree: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterTypeTreeDiff.write(inner.diff, into);
          return;
        }
        case Diff_Tags.Counter: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterFloat64.write(inner.diff, into);
          return;
        }
        case Diff_Tags.Unknown: {
          ordinalConverter.write(6, into);
          return;
        }
        default:
          // Throwing from here means that Diff_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Diff_Tags.List: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterArrayTypeListDiffItem.allocationSize(inner.diff);
          return size;
        }
        case Diff_Tags.Text: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterArrayTypeTextDelta.allocationSize(inner.diff);
          return size;
        }
        case Diff_Tags.Map: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeMapDelta.allocationSize(inner.diff);
          return size;
        }
        case Diff_Tags.Tree: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterTypeTreeDiff.allocationSize(inner.diff);
          return size;
        }
        case Diff_Tags.Counter: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterFloat64.allocationSize(inner.diff);
          return size;
        }
        case Diff_Tags.Unknown: {
          return ordinalConverter.allocationSize(6);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum EphemeralEventTrigger {
  Local,
  Import,
  Timeout,
}

const FfiConverterTypeEphemeralEventTrigger = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EphemeralEventTrigger;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return EphemeralEventTrigger.Local;
        case 2:
          return EphemeralEventTrigger.Import;
        case 3:
          return EphemeralEventTrigger.Timeout;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case EphemeralEventTrigger.Local:
          return ordinalConverter.write(1, into);
        case EphemeralEventTrigger.Import:
          return ordinalConverter.write(2, into);
        case EphemeralEventTrigger.Timeout:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

/**
 * The kind of the event trigger.
 */
export enum EventTriggerKind {
  /**
   * The event is triggered by a local transaction.
   */
  Local,
  /**
   * The event is triggered by importing
   */
  Import,
  /**
   * The event is triggered by checkout
   */
  Checkout,
}

const FfiConverterTypeEventTriggerKind = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = EventTriggerKind;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return EventTriggerKind.Local;
        case 2:
          return EventTriggerKind.Import;
        case 3:
          return EventTriggerKind.Checkout;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case EventTriggerKind.Local:
          return ordinalConverter.write(1, into);
        case EventTriggerKind.Import:
          return ordinalConverter.write(2, into);
        case EventTriggerKind.Checkout:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum ExpandType {
  Before,
  After,
  Both,
  None,
}

const FfiConverterTypeExpandType = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ExpandType;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return ExpandType.Before;
        case 2:
          return ExpandType.After;
        case 3:
          return ExpandType.Both;
        case 4:
          return ExpandType.None;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case ExpandType.Before:
          return ordinalConverter.write(1, into);
        case ExpandType.After:
          return ordinalConverter.write(2, into);
        case ExpandType.Both:
          return ordinalConverter.write(3, into);
        case ExpandType.None:
          return ordinalConverter.write(4, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: Index
export enum Index_Tags {
  Key = 'Key',
  Seq = 'Seq',
  Node = 'Node',
}
export const Index = (() => {
  type Key__interface = {
    tag: Index_Tags.Key;
    inner: Readonly<{ key: string }>;
  };

  class Key_ extends UniffiEnum implements Key__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Index';
    readonly tag = Index_Tags.Key;
    readonly inner: Readonly<{ key: string }>;
    constructor(inner: { key: string }) {
      super('Index', 'Key');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { key: string }): Key_ {
      return new Key_(inner);
    }

    static instanceOf(obj: any): obj is Key_ {
      return obj.tag === Index_Tags.Key;
    }
  }

  type Seq__interface = {
    tag: Index_Tags.Seq;
    inner: Readonly<{ index: /*u32*/ number }>;
  };

  class Seq_ extends UniffiEnum implements Seq__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Index';
    readonly tag = Index_Tags.Seq;
    readonly inner: Readonly<{ index: /*u32*/ number }>;
    constructor(inner: { index: /*u32*/ number }) {
      super('Index', 'Seq');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { index: /*u32*/ number }): Seq_ {
      return new Seq_(inner);
    }

    static instanceOf(obj: any): obj is Seq_ {
      return obj.tag === Index_Tags.Seq;
    }
  }

  type Node__interface = {
    tag: Index_Tags.Node;
    inner: Readonly<{ target: TreeId }>;
  };

  class Node_ extends UniffiEnum implements Node__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'Index';
    readonly tag = Index_Tags.Node;
    readonly inner: Readonly<{ target: TreeId }>;
    constructor(inner: { target: TreeId }) {
      super('Index', 'Node');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { target: TreeId }): Node_ {
      return new Node_(inner);
    }

    static instanceOf(obj: any): obj is Node_ {
      return obj.tag === Index_Tags.Node;
    }
  }

  function instanceOf(obj: any): obj is Index {
    return obj[uniffiTypeNameSymbol] === 'Index';
  }

  return Object.freeze({
    instanceOf,
    Key: Key_,
    Seq: Seq_,
    Node: Node_,
  });
})();

export type Index = InstanceType<
  (typeof Index)[keyof Omit<typeof Index, 'instanceOf'>]
>;

// FfiConverter for enum Index
const FfiConverterTypeIndex = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Index;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new Index.Key({ key: FfiConverterString.read(from) });
        case 2:
          return new Index.Seq({ index: FfiConverterUInt32.read(from) });
        case 3:
          return new Index.Node({ target: FfiConverterTypeTreeID.read(from) });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case Index_Tags.Key: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.key, into);
          return;
        }
        case Index_Tags.Seq: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.index, into);
          return;
        }
        case Index_Tags.Node: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeTreeID.write(inner.target, into);
          return;
        }
        default:
          // Throwing from here means that Index_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case Index_Tags.Key: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.key);
          return size;
        }
        case Index_Tags.Seq: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt32.allocationSize(inner.index);
          return size;
        }
        case Index_Tags.Node: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeTreeID.allocationSize(inner.target);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: JsonPathError
export enum JsonPathError_Tags {
  InvalidJsonPath = 'InvalidJsonPath',
  EvaluationError = 'EvaluationError',
}
export const JsonPathError = (() => {
  class InvalidJsonPath extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'JsonPathError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = JsonPathError_Tags.InvalidJsonPath;

    constructor(message: string) {
      super('JsonPathError', 'InvalidJsonPath', message);
    }

    static instanceOf(e: any): e is InvalidJsonPath {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class EvaluationError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'JsonPathError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = JsonPathError_Tags.EvaluationError;

    constructor(message: string) {
      super('JsonPathError', 'EvaluationError', message);
    }

    static instanceOf(e: any): e is EvaluationError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is JsonPathError {
    return (e as any)[uniffiTypeNameSymbol] === 'JsonPathError';
  }
  return {
    InvalidJsonPath,
    EvaluationError,
    instanceOf,
  };
})();

// Union type for JsonPathError error type.

export type JsonPathError = InstanceType<
  (typeof JsonPathError)[keyof Omit<typeof JsonPathError, 'instanceOf'>]
>;

const FfiConverterTypeJsonPathError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = JsonPathError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new JsonPathError.InvalidJsonPath(
            FfiConverterString.read(from)
          );

        case 2:
          return new JsonPathError.EvaluationError(
            FfiConverterString.read(from)
          );

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Enum: ListDiffItem
export enum ListDiffItem_Tags {
  Insert = 'Insert',
  Delete = 'Delete',
  Retain = 'Retain',
}
export const ListDiffItem = (() => {
  type Insert__interface = {
    tag: ListDiffItem_Tags.Insert;
    inner: Readonly<{
      insert: Array<ValueOrContainerInterface>;
      isMove: boolean;
    }>;
  };

  /**
   * Insert a new element into the list.
   */
  class Insert_ extends UniffiEnum implements Insert__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ListDiffItem';
    readonly tag = ListDiffItem_Tags.Insert;
    readonly inner: Readonly<{
      insert: Array<ValueOrContainerInterface>;
      isMove: boolean;
    }>;
    constructor(inner: {
      insert: Array<ValueOrContainerInterface>;
      isMove: boolean;
    }) {
      super('ListDiffItem', 'Insert');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      insert: Array<ValueOrContainerInterface>;
      isMove: boolean;
    }): Insert_ {
      return new Insert_(inner);
    }

    static instanceOf(obj: any): obj is Insert_ {
      return obj.tag === ListDiffItem_Tags.Insert;
    }
  }

  type Delete__interface = {
    tag: ListDiffItem_Tags.Delete;
    inner: Readonly<{ delete_: /*u32*/ number }>;
  };

  /**
   * Delete n elements from the list at the current index.
   */
  class Delete_ extends UniffiEnum implements Delete__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ListDiffItem';
    readonly tag = ListDiffItem_Tags.Delete;
    readonly inner: Readonly<{ delete_: /*u32*/ number }>;
    constructor(inner: { delete_: /*u32*/ number }) {
      super('ListDiffItem', 'Delete');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { delete_: /*u32*/ number }): Delete_ {
      return new Delete_(inner);
    }

    static instanceOf(obj: any): obj is Delete_ {
      return obj.tag === ListDiffItem_Tags.Delete;
    }
  }

  type Retain__interface = {
    tag: ListDiffItem_Tags.Retain;
    inner: Readonly<{ retain: /*u32*/ number }>;
  };

  /**
   * Retain n elements in the list.
   *
   * This is used to keep the current index unchanged.
   */
  class Retain_ extends UniffiEnum implements Retain__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'ListDiffItem';
    readonly tag = ListDiffItem_Tags.Retain;
    readonly inner: Readonly<{ retain: /*u32*/ number }>;
    constructor(inner: { retain: /*u32*/ number }) {
      super('ListDiffItem', 'Retain');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { retain: /*u32*/ number }): Retain_ {
      return new Retain_(inner);
    }

    static instanceOf(obj: any): obj is Retain_ {
      return obj.tag === ListDiffItem_Tags.Retain;
    }
  }

  function instanceOf(obj: any): obj is ListDiffItem {
    return obj[uniffiTypeNameSymbol] === 'ListDiffItem';
  }

  return Object.freeze({
    instanceOf,
    Insert: Insert_,
    Delete: Delete_,
    Retain: Retain_,
  });
})();

export type ListDiffItem = InstanceType<
  (typeof ListDiffItem)[keyof Omit<typeof ListDiffItem, 'instanceOf'>]
>;

// FfiConverter for enum ListDiffItem
const FfiConverterTypeListDiffItem = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = ListDiffItem;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new ListDiffItem.Insert({
            insert: FfiConverterArrayTypeValueOrContainer.read(from),
            isMove: FfiConverterBool.read(from),
          });
        case 2:
          return new ListDiffItem.Delete({
            delete_: FfiConverterUInt32.read(from),
          });
        case 3:
          return new ListDiffItem.Retain({
            retain: FfiConverterUInt32.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case ListDiffItem_Tags.Insert: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterArrayTypeValueOrContainer.write(inner.insert, into);
          FfiConverterBool.write(inner.isMove, into);
          return;
        }
        case ListDiffItem_Tags.Delete: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.delete_, into);
          return;
        }
        case ListDiffItem_Tags.Retain: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.retain, into);
          return;
        }
        default:
          // Throwing from here means that ListDiffItem_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case ListDiffItem_Tags.Insert: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterArrayTypeValueOrContainer.allocationSize(
            inner.insert
          );
          size += FfiConverterBool.allocationSize(inner.isMove);
          return size;
        }
        case ListDiffItem_Tags.Delete: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterUInt32.allocationSize(inner.delete_);
          return size;
        }
        case ListDiffItem_Tags.Retain: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterUInt32.allocationSize(inner.retain);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Flat error type: LoroEncodeError
export enum LoroEncodeError_Tags {
  FrontiersNotFound = 'FrontiersNotFound',
  ShallowSnapshotIncompatibleWithOldFormat = 'ShallowSnapshotIncompatibleWithOldFormat',
  UnknownContainer = 'UnknownContainer',
}
export const LoroEncodeError = (() => {
  class FrontiersNotFound extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroEncodeError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = LoroEncodeError_Tags.FrontiersNotFound;

    constructor(message: string) {
      super('LoroEncodeError', 'FrontiersNotFound', message);
    }

    static instanceOf(e: any): e is FrontiersNotFound {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class ShallowSnapshotIncompatibleWithOldFormat extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroEncodeError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag =
      LoroEncodeError_Tags.ShallowSnapshotIncompatibleWithOldFormat;

    constructor(message: string) {
      super(
        'LoroEncodeError',
        'ShallowSnapshotIncompatibleWithOldFormat',
        message
      );
    }

    static instanceOf(e: any): e is ShallowSnapshotIncompatibleWithOldFormat {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class UnknownContainer extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroEncodeError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = LoroEncodeError_Tags.UnknownContainer;

    constructor(message: string) {
      super('LoroEncodeError', 'UnknownContainer', message);
    }

    static instanceOf(e: any): e is UnknownContainer {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is LoroEncodeError {
    return (e as any)[uniffiTypeNameSymbol] === 'LoroEncodeError';
  }
  return {
    FrontiersNotFound,
    ShallowSnapshotIncompatibleWithOldFormat,
    UnknownContainer,
    instanceOf,
  };
})();

// Union type for LoroEncodeError error type.

export type LoroEncodeError = InstanceType<
  (typeof LoroEncodeError)[keyof Omit<typeof LoroEncodeError, 'instanceOf'>]
>;

const FfiConverterTypeLoroEncodeError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = LoroEncodeError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new LoroEncodeError.FrontiersNotFound(
            FfiConverterString.read(from)
          );

        case 2:
          return new LoroEncodeError.ShallowSnapshotIncompatibleWithOldFormat(
            FfiConverterString.read(from)
          );

        case 3:
          return new LoroEncodeError.UnknownContainer(
            FfiConverterString.read(from)
          );

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Flat error type: LoroError
export enum LoroError_Tags {
  UnmatchedContext = 'UnmatchedContext',
  DecodeVersionVectorError = 'DecodeVersionVectorError',
  DecodeError = 'DecodeError',
  DecodeDataCorruptionError = 'DecodeDataCorruptionError',
  DecodeChecksumMismatchError = 'DecodeChecksumMismatchError',
  IncompatibleFutureEncodingError = 'IncompatibleFutureEncodingError',
  JsError = 'JsError',
  LockError = 'LockError',
  DuplicatedTransactionError = 'DuplicatedTransactionError',
  NotFoundError = 'NotFoundError',
  TransactionError = 'TransactionError',
  OutOfBound = 'OutOfBound',
  UsedOpId = 'UsedOpID',
  TreeError = 'TreeError',
  ArgErr = 'ArgErr',
  AutoCommitNotStarted = 'AutoCommitNotStarted',
  StyleConfigMissing = 'StyleConfigMissing',
  Unknown = 'Unknown',
  FrontiersNotFound = 'FrontiersNotFound',
  ImportWhenInTxn = 'ImportWhenInTxn',
  MisuseDetachedContainer = 'MisuseDetachedContainer',
  NotImplemented = 'NotImplemented',
  ReattachAttachedContainer = 'ReattachAttachedContainer',
  EditWhenDetached = 'EditWhenDetached',
  UndoInvalidIdSpan = 'UndoInvalidIdSpan',
  UndoWithDifferentPeerId = 'UndoWithDifferentPeerId',
  InvalidJsonSchema = 'InvalidJsonSchema',
  Utf8InUnicodeCodePoint = 'UTF8InUnicodeCodePoint',
  Utf16InUnicodeCodePoint = 'UTF16InUnicodeCodePoint',
  EndIndexLessThanStartIndex = 'EndIndexLessThanStartIndex',
  InvalidRootContainerName = 'InvalidRootContainerName',
  ImportUpdatesThatDependsOnOutdatedVersion = 'ImportUpdatesThatDependsOnOutdatedVersion',
  SwitchToVersionBeforeShallowRoot = 'SwitchToVersionBeforeShallowRoot',
  ContainerDeleted = 'ContainerDeleted',
  ConcurrentOpsWithSamePeerId = 'ConcurrentOpsWithSamePeerID',
  InvalidPeerId = 'InvalidPeerID',
  ContainersNotFound = 'ContainersNotFound',
  UndoGroupAlreadyStarted = 'UndoGroupAlreadyStarted',
}
export const LoroError = (() => {
  class UnmatchedContext extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = LoroError_Tags.UnmatchedContext;

    constructor(message: string) {
      super('LoroError', 'UnmatchedContext', message);
    }

    static instanceOf(e: any): e is UnmatchedContext {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }
  class DecodeVersionVectorError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 2;

    public readonly tag = LoroError_Tags.DecodeVersionVectorError;

    constructor(message: string) {
      super('LoroError', 'DecodeVersionVectorError', message);
    }

    static instanceOf(e: any): e is DecodeVersionVectorError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 2;
    }
  }
  class DecodeError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 3;

    public readonly tag = LoroError_Tags.DecodeError;

    constructor(message: string) {
      super('LoroError', 'DecodeError', message);
    }

    static instanceOf(e: any): e is DecodeError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 3;
    }
  }
  class DecodeDataCorruptionError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 4;

    public readonly tag = LoroError_Tags.DecodeDataCorruptionError;

    constructor(message: string) {
      super('LoroError', 'DecodeDataCorruptionError', message);
    }

    static instanceOf(e: any): e is DecodeDataCorruptionError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 4;
    }
  }
  class DecodeChecksumMismatchError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 5;

    public readonly tag = LoroError_Tags.DecodeChecksumMismatchError;

    constructor(message: string) {
      super('LoroError', 'DecodeChecksumMismatchError', message);
    }

    static instanceOf(e: any): e is DecodeChecksumMismatchError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 5;
    }
  }
  class IncompatibleFutureEncodingError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 6;

    public readonly tag = LoroError_Tags.IncompatibleFutureEncodingError;

    constructor(message: string) {
      super('LoroError', 'IncompatibleFutureEncodingError', message);
    }

    static instanceOf(e: any): e is IncompatibleFutureEncodingError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 6;
    }
  }
  class JsError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 7;

    public readonly tag = LoroError_Tags.JsError;

    constructor(message: string) {
      super('LoroError', 'JsError', message);
    }

    static instanceOf(e: any): e is JsError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 7;
    }
  }
  class LockError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 8;

    public readonly tag = LoroError_Tags.LockError;

    constructor(message: string) {
      super('LoroError', 'LockError', message);
    }

    static instanceOf(e: any): e is LockError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 8;
    }
  }
  class DuplicatedTransactionError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 9;

    public readonly tag = LoroError_Tags.DuplicatedTransactionError;

    constructor(message: string) {
      super('LoroError', 'DuplicatedTransactionError', message);
    }

    static instanceOf(e: any): e is DuplicatedTransactionError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 9;
    }
  }
  class NotFoundError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 10;

    public readonly tag = LoroError_Tags.NotFoundError;

    constructor(message: string) {
      super('LoroError', 'NotFoundError', message);
    }

    static instanceOf(e: any): e is NotFoundError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 10;
    }
  }
  class TransactionError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 11;

    public readonly tag = LoroError_Tags.TransactionError;

    constructor(message: string) {
      super('LoroError', 'TransactionError', message);
    }

    static instanceOf(e: any): e is TransactionError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 11;
    }
  }
  class OutOfBound extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 12;

    public readonly tag = LoroError_Tags.OutOfBound;

    constructor(message: string) {
      super('LoroError', 'OutOfBound', message);
    }

    static instanceOf(e: any): e is OutOfBound {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 12;
    }
  }
  class UsedOpId extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 13;

    public readonly tag = LoroError_Tags.UsedOpId;

    constructor(message: string) {
      super('LoroError', 'UsedOpId', message);
    }

    static instanceOf(e: any): e is UsedOpId {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 13;
    }
  }
  class TreeError extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 14;

    public readonly tag = LoroError_Tags.TreeError;

    constructor(message: string) {
      super('LoroError', 'TreeError', message);
    }

    static instanceOf(e: any): e is TreeError {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 14;
    }
  }
  class ArgErr extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 15;

    public readonly tag = LoroError_Tags.ArgErr;

    constructor(message: string) {
      super('LoroError', 'ArgErr', message);
    }

    static instanceOf(e: any): e is ArgErr {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 15;
    }
  }
  class AutoCommitNotStarted extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 16;

    public readonly tag = LoroError_Tags.AutoCommitNotStarted;

    constructor(message: string) {
      super('LoroError', 'AutoCommitNotStarted', message);
    }

    static instanceOf(e: any): e is AutoCommitNotStarted {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 16;
    }
  }
  class StyleConfigMissing extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 17;

    public readonly tag = LoroError_Tags.StyleConfigMissing;

    constructor(message: string) {
      super('LoroError', 'StyleConfigMissing', message);
    }

    static instanceOf(e: any): e is StyleConfigMissing {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 17;
    }
  }
  class Unknown extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 18;

    public readonly tag = LoroError_Tags.Unknown;

    constructor(message: string) {
      super('LoroError', 'Unknown', message);
    }

    static instanceOf(e: any): e is Unknown {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 18;
    }
  }
  class FrontiersNotFound extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 19;

    public readonly tag = LoroError_Tags.FrontiersNotFound;

    constructor(message: string) {
      super('LoroError', 'FrontiersNotFound', message);
    }

    static instanceOf(e: any): e is FrontiersNotFound {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 19;
    }
  }
  class ImportWhenInTxn extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 20;

    public readonly tag = LoroError_Tags.ImportWhenInTxn;

    constructor(message: string) {
      super('LoroError', 'ImportWhenInTxn', message);
    }

    static instanceOf(e: any): e is ImportWhenInTxn {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 20;
    }
  }
  class MisuseDetachedContainer extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 21;

    public readonly tag = LoroError_Tags.MisuseDetachedContainer;

    constructor(message: string) {
      super('LoroError', 'MisuseDetachedContainer', message);
    }

    static instanceOf(e: any): e is MisuseDetachedContainer {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 21;
    }
  }
  class NotImplemented extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 22;

    public readonly tag = LoroError_Tags.NotImplemented;

    constructor(message: string) {
      super('LoroError', 'NotImplemented', message);
    }

    static instanceOf(e: any): e is NotImplemented {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 22;
    }
  }
  class ReattachAttachedContainer extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 23;

    public readonly tag = LoroError_Tags.ReattachAttachedContainer;

    constructor(message: string) {
      super('LoroError', 'ReattachAttachedContainer', message);
    }

    static instanceOf(e: any): e is ReattachAttachedContainer {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 23;
    }
  }
  class EditWhenDetached extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 24;

    public readonly tag = LoroError_Tags.EditWhenDetached;

    constructor(message: string) {
      super('LoroError', 'EditWhenDetached', message);
    }

    static instanceOf(e: any): e is EditWhenDetached {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 24;
    }
  }
  class UndoInvalidIdSpan extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 25;

    public readonly tag = LoroError_Tags.UndoInvalidIdSpan;

    constructor(message: string) {
      super('LoroError', 'UndoInvalidIdSpan', message);
    }

    static instanceOf(e: any): e is UndoInvalidIdSpan {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 25;
    }
  }
  class UndoWithDifferentPeerId extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 26;

    public readonly tag = LoroError_Tags.UndoWithDifferentPeerId;

    constructor(message: string) {
      super('LoroError', 'UndoWithDifferentPeerId', message);
    }

    static instanceOf(e: any): e is UndoWithDifferentPeerId {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 26;
    }
  }
  class InvalidJsonSchema extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 27;

    public readonly tag = LoroError_Tags.InvalidJsonSchema;

    constructor(message: string) {
      super('LoroError', 'InvalidJsonSchema', message);
    }

    static instanceOf(e: any): e is InvalidJsonSchema {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 27;
    }
  }
  class Utf8InUnicodeCodePoint extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 28;

    public readonly tag = LoroError_Tags.Utf8InUnicodeCodePoint;

    constructor(message: string) {
      super('LoroError', 'Utf8InUnicodeCodePoint', message);
    }

    static instanceOf(e: any): e is Utf8InUnicodeCodePoint {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 28;
    }
  }
  class Utf16InUnicodeCodePoint extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 29;

    public readonly tag = LoroError_Tags.Utf16InUnicodeCodePoint;

    constructor(message: string) {
      super('LoroError', 'Utf16InUnicodeCodePoint', message);
    }

    static instanceOf(e: any): e is Utf16InUnicodeCodePoint {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 29;
    }
  }
  class EndIndexLessThanStartIndex extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 30;

    public readonly tag = LoroError_Tags.EndIndexLessThanStartIndex;

    constructor(message: string) {
      super('LoroError', 'EndIndexLessThanStartIndex', message);
    }

    static instanceOf(e: any): e is EndIndexLessThanStartIndex {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 30;
    }
  }
  class InvalidRootContainerName extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 31;

    public readonly tag = LoroError_Tags.InvalidRootContainerName;

    constructor(message: string) {
      super('LoroError', 'InvalidRootContainerName', message);
    }

    static instanceOf(e: any): e is InvalidRootContainerName {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 31;
    }
  }
  class ImportUpdatesThatDependsOnOutdatedVersion extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 32;

    public readonly tag =
      LoroError_Tags.ImportUpdatesThatDependsOnOutdatedVersion;

    constructor(message: string) {
      super('LoroError', 'ImportUpdatesThatDependsOnOutdatedVersion', message);
    }

    static instanceOf(e: any): e is ImportUpdatesThatDependsOnOutdatedVersion {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 32;
    }
  }
  class SwitchToVersionBeforeShallowRoot extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 33;

    public readonly tag = LoroError_Tags.SwitchToVersionBeforeShallowRoot;

    constructor(message: string) {
      super('LoroError', 'SwitchToVersionBeforeShallowRoot', message);
    }

    static instanceOf(e: any): e is SwitchToVersionBeforeShallowRoot {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 33;
    }
  }
  class ContainerDeleted extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 34;

    public readonly tag = LoroError_Tags.ContainerDeleted;

    constructor(message: string) {
      super('LoroError', 'ContainerDeleted', message);
    }

    static instanceOf(e: any): e is ContainerDeleted {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 34;
    }
  }
  class ConcurrentOpsWithSamePeerId extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 35;

    public readonly tag = LoroError_Tags.ConcurrentOpsWithSamePeerId;

    constructor(message: string) {
      super('LoroError', 'ConcurrentOpsWithSamePeerId', message);
    }

    static instanceOf(e: any): e is ConcurrentOpsWithSamePeerId {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 35;
    }
  }
  class InvalidPeerId extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 36;

    public readonly tag = LoroError_Tags.InvalidPeerId;

    constructor(message: string) {
      super('LoroError', 'InvalidPeerId', message);
    }

    static instanceOf(e: any): e is InvalidPeerId {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 36;
    }
  }
  class ContainersNotFound extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 37;

    public readonly tag = LoroError_Tags.ContainersNotFound;

    constructor(message: string) {
      super('LoroError', 'ContainersNotFound', message);
    }

    static instanceOf(e: any): e is ContainersNotFound {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 37;
    }
  }
  class UndoGroupAlreadyStarted extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'LoroError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 38;

    public readonly tag = LoroError_Tags.UndoGroupAlreadyStarted;

    constructor(message: string) {
      super('LoroError', 'UndoGroupAlreadyStarted', message);
    }

    static instanceOf(e: any): e is UndoGroupAlreadyStarted {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 38;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is LoroError {
    return (e as any)[uniffiTypeNameSymbol] === 'LoroError';
  }
  return {
    UnmatchedContext,
    DecodeVersionVectorError,
    DecodeError,
    DecodeDataCorruptionError,
    DecodeChecksumMismatchError,
    IncompatibleFutureEncodingError,
    JsError,
    LockError,
    DuplicatedTransactionError,
    NotFoundError,
    TransactionError,
    OutOfBound,
    UsedOpId,
    TreeError,
    ArgErr,
    AutoCommitNotStarted,
    StyleConfigMissing,
    Unknown,
    FrontiersNotFound,
    ImportWhenInTxn,
    MisuseDetachedContainer,
    NotImplemented,
    ReattachAttachedContainer,
    EditWhenDetached,
    UndoInvalidIdSpan,
    UndoWithDifferentPeerId,
    InvalidJsonSchema,
    Utf8InUnicodeCodePoint,
    Utf16InUnicodeCodePoint,
    EndIndexLessThanStartIndex,
    InvalidRootContainerName,
    ImportUpdatesThatDependsOnOutdatedVersion,
    SwitchToVersionBeforeShallowRoot,
    ContainerDeleted,
    ConcurrentOpsWithSamePeerId,
    InvalidPeerId,
    ContainersNotFound,
    UndoGroupAlreadyStarted,
    instanceOf,
  };
})();

// Union type for LoroError error type.

export type LoroError = InstanceType<
  (typeof LoroError)[keyof Omit<typeof LoroError, 'instanceOf'>]
>;

const FfiConverterTypeLoroError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = LoroError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new LoroError.UnmatchedContext(FfiConverterString.read(from));

        case 2:
          return new LoroError.DecodeVersionVectorError(
            FfiConverterString.read(from)
          );

        case 3:
          return new LoroError.DecodeError(FfiConverterString.read(from));

        case 4:
          return new LoroError.DecodeDataCorruptionError(
            FfiConverterString.read(from)
          );

        case 5:
          return new LoroError.DecodeChecksumMismatchError(
            FfiConverterString.read(from)
          );

        case 6:
          return new LoroError.IncompatibleFutureEncodingError(
            FfiConverterString.read(from)
          );

        case 7:
          return new LoroError.JsError(FfiConverterString.read(from));

        case 8:
          return new LoroError.LockError(FfiConverterString.read(from));

        case 9:
          return new LoroError.DuplicatedTransactionError(
            FfiConverterString.read(from)
          );

        case 10:
          return new LoroError.NotFoundError(FfiConverterString.read(from));

        case 11:
          return new LoroError.TransactionError(FfiConverterString.read(from));

        case 12:
          return new LoroError.OutOfBound(FfiConverterString.read(from));

        case 13:
          return new LoroError.UsedOpId(FfiConverterString.read(from));

        case 14:
          return new LoroError.TreeError(FfiConverterString.read(from));

        case 15:
          return new LoroError.ArgErr(FfiConverterString.read(from));

        case 16:
          return new LoroError.AutoCommitNotStarted(
            FfiConverterString.read(from)
          );

        case 17:
          return new LoroError.StyleConfigMissing(
            FfiConverterString.read(from)
          );

        case 18:
          return new LoroError.Unknown(FfiConverterString.read(from));

        case 19:
          return new LoroError.FrontiersNotFound(FfiConverterString.read(from));

        case 20:
          return new LoroError.ImportWhenInTxn(FfiConverterString.read(from));

        case 21:
          return new LoroError.MisuseDetachedContainer(
            FfiConverterString.read(from)
          );

        case 22:
          return new LoroError.NotImplemented(FfiConverterString.read(from));

        case 23:
          return new LoroError.ReattachAttachedContainer(
            FfiConverterString.read(from)
          );

        case 24:
          return new LoroError.EditWhenDetached(FfiConverterString.read(from));

        case 25:
          return new LoroError.UndoInvalidIdSpan(FfiConverterString.read(from));

        case 26:
          return new LoroError.UndoWithDifferentPeerId(
            FfiConverterString.read(from)
          );

        case 27:
          return new LoroError.InvalidJsonSchema(FfiConverterString.read(from));

        case 28:
          return new LoroError.Utf8InUnicodeCodePoint(
            FfiConverterString.read(from)
          );

        case 29:
          return new LoroError.Utf16InUnicodeCodePoint(
            FfiConverterString.read(from)
          );

        case 30:
          return new LoroError.EndIndexLessThanStartIndex(
            FfiConverterString.read(from)
          );

        case 31:
          return new LoroError.InvalidRootContainerName(
            FfiConverterString.read(from)
          );

        case 32:
          return new LoroError.ImportUpdatesThatDependsOnOutdatedVersion(
            FfiConverterString.read(from)
          );

        case 33:
          return new LoroError.SwitchToVersionBeforeShallowRoot(
            FfiConverterString.read(from)
          );

        case 34:
          return new LoroError.ContainerDeleted(FfiConverterString.read(from));

        case 35:
          return new LoroError.ConcurrentOpsWithSamePeerId(
            FfiConverterString.read(from)
          );

        case 36:
          return new LoroError.InvalidPeerId(FfiConverterString.read(from));

        case 37:
          return new LoroError.ContainersNotFound(
            FfiConverterString.read(from)
          );

        case 38:
          return new LoroError.UndoGroupAlreadyStarted(
            FfiConverterString.read(from)
          );

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// Enum: LoroValue
export enum LoroValue_Tags {
  Null = 'Null',
  Bool = 'Bool',
  Double = 'Double',
  I64 = 'I64',
  Binary = 'Binary',
  String = 'String',
  List = 'List',
  Map = 'Map',
  Container = 'Container',
}
export const LoroValue = (() => {
  type Null__interface = {
    tag: LoroValue_Tags.Null;
  };

  class Null_ extends UniffiEnum implements Null__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LoroValue';
    readonly tag = LoroValue_Tags.Null;
    constructor() {
      super('LoroValue', 'Null');
    }

    static new(): Null_ {
      return new Null_();
    }

    static instanceOf(obj: any): obj is Null_ {
      return obj.tag === LoroValue_Tags.Null;
    }
  }

  type Bool__interface = {
    tag: LoroValue_Tags.Bool;
    inner: Readonly<{ value: boolean }>;
  };

  class Bool_ extends UniffiEnum implements Bool__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LoroValue';
    readonly tag = LoroValue_Tags.Bool;
    readonly inner: Readonly<{ value: boolean }>;
    constructor(inner: { value: boolean }) {
      super('LoroValue', 'Bool');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: boolean }): Bool_ {
      return new Bool_(inner);
    }

    static instanceOf(obj: any): obj is Bool_ {
      return obj.tag === LoroValue_Tags.Bool;
    }
  }

  type Double__interface = {
    tag: LoroValue_Tags.Double;
    inner: Readonly<{ value: /*f64*/ number }>;
  };

  class Double_ extends UniffiEnum implements Double__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LoroValue';
    readonly tag = LoroValue_Tags.Double;
    readonly inner: Readonly<{ value: /*f64*/ number }>;
    constructor(inner: { value: /*f64*/ number }) {
      super('LoroValue', 'Double');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: /*f64*/ number }): Double_ {
      return new Double_(inner);
    }

    static instanceOf(obj: any): obj is Double_ {
      return obj.tag === LoroValue_Tags.Double;
    }
  }

  type I64__interface = {
    tag: LoroValue_Tags.I64;
    inner: Readonly<{ value: /*i64*/ bigint }>;
  };

  class I64_ extends UniffiEnum implements I64__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LoroValue';
    readonly tag = LoroValue_Tags.I64;
    readonly inner: Readonly<{ value: /*i64*/ bigint }>;
    constructor(inner: { value: /*i64*/ bigint }) {
      super('LoroValue', 'I64');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: /*i64*/ bigint }): I64_ {
      return new I64_(inner);
    }

    static instanceOf(obj: any): obj is I64_ {
      return obj.tag === LoroValue_Tags.I64;
    }
  }

  type Binary__interface = {
    tag: LoroValue_Tags.Binary;
    inner: Readonly<{ value: ArrayBuffer }>;
  };

  class Binary_ extends UniffiEnum implements Binary__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LoroValue';
    readonly tag = LoroValue_Tags.Binary;
    readonly inner: Readonly<{ value: ArrayBuffer }>;
    constructor(inner: { value: ArrayBuffer }) {
      super('LoroValue', 'Binary');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: ArrayBuffer }): Binary_ {
      return new Binary_(inner);
    }

    static instanceOf(obj: any): obj is Binary_ {
      return obj.tag === LoroValue_Tags.Binary;
    }
  }

  type String__interface = {
    tag: LoroValue_Tags.String;
    inner: Readonly<{ value: string }>;
  };

  class String_ extends UniffiEnum implements String__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LoroValue';
    readonly tag = LoroValue_Tags.String;
    readonly inner: Readonly<{ value: string }>;
    constructor(inner: { value: string }) {
      super('LoroValue', 'String');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: string }): String_ {
      return new String_(inner);
    }

    static instanceOf(obj: any): obj is String_ {
      return obj.tag === LoroValue_Tags.String;
    }
  }

  type List__interface = {
    tag: LoroValue_Tags.List;
    inner: Readonly<{ value: Array<LoroValue> }>;
  };

  class List_ extends UniffiEnum implements List__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LoroValue';
    readonly tag = LoroValue_Tags.List;
    readonly inner: Readonly<{ value: Array<LoroValue> }>;
    constructor(inner: { value: Array<LoroValue> }) {
      super('LoroValue', 'List');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: Array<LoroValue> }): List_ {
      return new List_(inner);
    }

    static instanceOf(obj: any): obj is List_ {
      return obj.tag === LoroValue_Tags.List;
    }
  }

  type Map__interface = {
    tag: LoroValue_Tags.Map;
    inner: Readonly<{ value: Map<string, LoroValue> }>;
  };

  class Map_ extends UniffiEnum implements Map__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LoroValue';
    readonly tag = LoroValue_Tags.Map;
    readonly inner: Readonly<{ value: Map<string, LoroValue> }>;
    constructor(inner: { value: Map<string, LoroValue> }) {
      super('LoroValue', 'Map');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: Map<string, LoroValue> }): Map_ {
      return new Map_(inner);
    }

    static instanceOf(obj: any): obj is Map_ {
      return obj.tag === LoroValue_Tags.Map;
    }
  }

  type Container__interface = {
    tag: LoroValue_Tags.Container;
    inner: Readonly<{ value: ContainerId }>;
  };

  class Container_ extends UniffiEnum implements Container__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'LoroValue';
    readonly tag = LoroValue_Tags.Container;
    readonly inner: Readonly<{ value: ContainerId }>;
    constructor(inner: { value: ContainerId }) {
      super('LoroValue', 'Container');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { value: ContainerId }): Container_ {
      return new Container_(inner);
    }

    static instanceOf(obj: any): obj is Container_ {
      return obj.tag === LoroValue_Tags.Container;
    }
  }

  function instanceOf(obj: any): obj is LoroValue {
    return obj[uniffiTypeNameSymbol] === 'LoroValue';
  }

  return Object.freeze({
    instanceOf,
    Null: Null_,
    Bool: Bool_,
    Double: Double_,
    I64: I64_,
    Binary: Binary_,
    String: String_,
    List: List_,
    Map: Map_,
    Container: Container_,
  });
})();

export type LoroValue = InstanceType<
  (typeof LoroValue)[keyof Omit<typeof LoroValue, 'instanceOf'>]
>;

// FfiConverter for enum LoroValue
const FfiConverterTypeLoroValue = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = LoroValue;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new LoroValue.Null();
        case 2:
          return new LoroValue.Bool({ value: FfiConverterBool.read(from) });
        case 3:
          return new LoroValue.Double({
            value: FfiConverterFloat64.read(from),
          });
        case 4:
          return new LoroValue.I64({ value: FfiConverterInt64.read(from) });
        case 5:
          return new LoroValue.Binary({
            value: FfiConverterArrayBuffer.read(from),
          });
        case 6:
          return new LoroValue.String({ value: FfiConverterString.read(from) });
        case 7:
          return new LoroValue.List({
            value: FfiConverterArrayTypeLoroValue.read(from),
          });
        case 8:
          return new LoroValue.Map({
            value: FfiConverterMapStringTypeLoroValue.read(from),
          });
        case 9:
          return new LoroValue.Container({
            value: FfiConverterTypeContainerID.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case LoroValue_Tags.Null: {
          ordinalConverter.write(1, into);
          return;
        }
        case LoroValue_Tags.Bool: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterBool.write(inner.value, into);
          return;
        }
        case LoroValue_Tags.Double: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterFloat64.write(inner.value, into);
          return;
        }
        case LoroValue_Tags.I64: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterInt64.write(inner.value, into);
          return;
        }
        case LoroValue_Tags.Binary: {
          ordinalConverter.write(5, into);
          const inner = value.inner;
          FfiConverterArrayBuffer.write(inner.value, into);
          return;
        }
        case LoroValue_Tags.String: {
          ordinalConverter.write(6, into);
          const inner = value.inner;
          FfiConverterString.write(inner.value, into);
          return;
        }
        case LoroValue_Tags.List: {
          ordinalConverter.write(7, into);
          const inner = value.inner;
          FfiConverterArrayTypeLoroValue.write(inner.value, into);
          return;
        }
        case LoroValue_Tags.Map: {
          ordinalConverter.write(8, into);
          const inner = value.inner;
          FfiConverterMapStringTypeLoroValue.write(inner.value, into);
          return;
        }
        case LoroValue_Tags.Container: {
          ordinalConverter.write(9, into);
          const inner = value.inner;
          FfiConverterTypeContainerID.write(inner.value, into);
          return;
        }
        default:
          // Throwing from here means that LoroValue_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case LoroValue_Tags.Null: {
          return ordinalConverter.allocationSize(1);
        }
        case LoroValue_Tags.Bool: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterBool.allocationSize(inner.value);
          return size;
        }
        case LoroValue_Tags.Double: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterFloat64.allocationSize(inner.value);
          return size;
        }
        case LoroValue_Tags.I64: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterInt64.allocationSize(inner.value);
          return size;
        }
        case LoroValue_Tags.Binary: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(5);
          size += FfiConverterArrayBuffer.allocationSize(inner.value);
          return size;
        }
        case LoroValue_Tags.String: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(6);
          size += FfiConverterString.allocationSize(inner.value);
          return size;
        }
        case LoroValue_Tags.List: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(7);
          size += FfiConverterArrayTypeLoroValue.allocationSize(inner.value);
          return size;
        }
        case LoroValue_Tags.Map: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(8);
          size += FfiConverterMapStringTypeLoroValue.allocationSize(
            inner.value
          );
          return size;
        }
        case LoroValue_Tags.Container: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(9);
          size += FfiConverterTypeContainerID.allocationSize(inner.value);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum Ordering {
  Less,
  Equal,
  Greater,
}

const FfiConverterTypeOrdering = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Ordering;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Ordering.Less;
        case 2:
          return Ordering.Equal;
        case 3:
          return Ordering.Greater;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Ordering.Less:
          return ordinalConverter.write(1, into);
        case Ordering.Equal:
          return ordinalConverter.write(2, into);
        case Ordering.Greater:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

export enum Side {
  Left,
  Middle,
  Right,
}

const FfiConverterTypeSide = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = Side;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return Side.Left;
        case 2:
          return Side.Middle;
        case 3:
          return Side.Right;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case Side.Left:
          return ordinalConverter.write(1, into);
        case Side.Middle:
          return ordinalConverter.write(2, into);
        case Side.Right:
          return ordinalConverter.write(3, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Enum: TextDelta
export enum TextDelta_Tags {
  Retain = 'Retain',
  Insert = 'Insert',
  Delete = 'Delete',
}
export const TextDelta = (() => {
  type Retain__interface = {
    tag: TextDelta_Tags.Retain;
    inner: Readonly<{
      retain: /*u32*/ number;
      attributes: Map<string, LoroValue> | undefined;
    }>;
  };

  class Retain_ extends UniffiEnum implements Retain__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TextDelta';
    readonly tag = TextDelta_Tags.Retain;
    readonly inner: Readonly<{
      retain: /*u32*/ number;
      attributes: Map<string, LoroValue> | undefined;
    }>;
    constructor(inner: {
      retain: /*u32*/ number;
      attributes: Map<string, LoroValue> | undefined;
    }) {
      super('TextDelta', 'Retain');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      retain: /*u32*/ number;
      attributes: Map<string, LoroValue> | undefined;
    }): Retain_ {
      return new Retain_(inner);
    }

    static instanceOf(obj: any): obj is Retain_ {
      return obj.tag === TextDelta_Tags.Retain;
    }
  }

  type Insert__interface = {
    tag: TextDelta_Tags.Insert;
    inner: Readonly<{
      insert: string;
      attributes: Map<string, LoroValue> | undefined;
    }>;
  };

  class Insert_ extends UniffiEnum implements Insert__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TextDelta';
    readonly tag = TextDelta_Tags.Insert;
    readonly inner: Readonly<{
      insert: string;
      attributes: Map<string, LoroValue> | undefined;
    }>;
    constructor(inner: {
      insert: string;
      attributes: Map<string, LoroValue> | undefined;
    }) {
      super('TextDelta', 'Insert');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      insert: string;
      attributes: Map<string, LoroValue> | undefined;
    }): Insert_ {
      return new Insert_(inner);
    }

    static instanceOf(obj: any): obj is Insert_ {
      return obj.tag === TextDelta_Tags.Insert;
    }
  }

  type Delete__interface = {
    tag: TextDelta_Tags.Delete;
    inner: Readonly<{ delete_: /*u32*/ number }>;
  };

  class Delete_ extends UniffiEnum implements Delete__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TextDelta';
    readonly tag = TextDelta_Tags.Delete;
    readonly inner: Readonly<{ delete_: /*u32*/ number }>;
    constructor(inner: { delete_: /*u32*/ number }) {
      super('TextDelta', 'Delete');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { delete_: /*u32*/ number }): Delete_ {
      return new Delete_(inner);
    }

    static instanceOf(obj: any): obj is Delete_ {
      return obj.tag === TextDelta_Tags.Delete;
    }
  }

  function instanceOf(obj: any): obj is TextDelta {
    return obj[uniffiTypeNameSymbol] === 'TextDelta';
  }

  return Object.freeze({
    instanceOf,
    Retain: Retain_,
    Insert: Insert_,
    Delete: Delete_,
  });
})();

export type TextDelta = InstanceType<
  (typeof TextDelta)[keyof Omit<typeof TextDelta, 'instanceOf'>]
>;

// FfiConverter for enum TextDelta
const FfiConverterTypeTextDelta = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TextDelta;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new TextDelta.Retain({
            retain: FfiConverterUInt32.read(from),
            attributes: FfiConverterOptionalMapStringTypeLoroValue.read(from),
          });
        case 2:
          return new TextDelta.Insert({
            insert: FfiConverterString.read(from),
            attributes: FfiConverterOptionalMapStringTypeLoroValue.read(from),
          });
        case 3:
          return new TextDelta.Delete({
            delete_: FfiConverterUInt32.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case TextDelta_Tags.Retain: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.retain, into);
          FfiConverterOptionalMapStringTypeLoroValue.write(
            inner.attributes,
            into
          );
          return;
        }
        case TextDelta_Tags.Insert: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.insert, into);
          FfiConverterOptionalMapStringTypeLoroValue.write(
            inner.attributes,
            into
          );
          return;
        }
        case TextDelta_Tags.Delete: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterUInt32.write(inner.delete_, into);
          return;
        }
        default:
          // Throwing from here means that TextDelta_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case TextDelta_Tags.Retain: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterUInt32.allocationSize(inner.retain);
          size += FfiConverterOptionalMapStringTypeLoroValue.allocationSize(
            inner.attributes
          );
          return size;
        }
        case TextDelta_Tags.Insert: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.insert);
          size += FfiConverterOptionalMapStringTypeLoroValue.allocationSize(
            inner.attributes
          );
          return size;
        }
        case TextDelta_Tags.Delete: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterUInt32.allocationSize(inner.delete_);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: TreeExternalDiff
export enum TreeExternalDiff_Tags {
  Create = 'Create',
  Move = 'Move',
  Delete = 'Delete',
}
export const TreeExternalDiff = (() => {
  type Create__interface = {
    tag: TreeExternalDiff_Tags.Create;
    inner: Readonly<{
      parent: TreeParentId;
      index: /*u32*/ number;
      fractionalIndex: string;
    }>;
  };

  class Create_ extends UniffiEnum implements Create__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TreeExternalDiff';
    readonly tag = TreeExternalDiff_Tags.Create;
    readonly inner: Readonly<{
      parent: TreeParentId;
      index: /*u32*/ number;
      fractionalIndex: string;
    }>;
    constructor(inner: {
      parent: TreeParentId;
      index: /*u32*/ number;
      fractionalIndex: string;
    }) {
      super('TreeExternalDiff', 'Create');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      parent: TreeParentId;
      index: /*u32*/ number;
      fractionalIndex: string;
    }): Create_ {
      return new Create_(inner);
    }

    static instanceOf(obj: any): obj is Create_ {
      return obj.tag === TreeExternalDiff_Tags.Create;
    }
  }

  type Move__interface = {
    tag: TreeExternalDiff_Tags.Move;
    inner: Readonly<{
      parent: TreeParentId;
      index: /*u32*/ number;
      fractionalIndex: string;
      oldParent: TreeParentId;
      oldIndex: /*u32*/ number;
    }>;
  };

  class Move_ extends UniffiEnum implements Move__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TreeExternalDiff';
    readonly tag = TreeExternalDiff_Tags.Move;
    readonly inner: Readonly<{
      parent: TreeParentId;
      index: /*u32*/ number;
      fractionalIndex: string;
      oldParent: TreeParentId;
      oldIndex: /*u32*/ number;
    }>;
    constructor(inner: {
      parent: TreeParentId;
      index: /*u32*/ number;
      fractionalIndex: string;
      oldParent: TreeParentId;
      oldIndex: /*u32*/ number;
    }) {
      super('TreeExternalDiff', 'Move');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      parent: TreeParentId;
      index: /*u32*/ number;
      fractionalIndex: string;
      oldParent: TreeParentId;
      oldIndex: /*u32*/ number;
    }): Move_ {
      return new Move_(inner);
    }

    static instanceOf(obj: any): obj is Move_ {
      return obj.tag === TreeExternalDiff_Tags.Move;
    }
  }

  type Delete__interface = {
    tag: TreeExternalDiff_Tags.Delete;
    inner: Readonly<{ oldParent: TreeParentId; oldIndex: /*u32*/ number }>;
  };

  class Delete_ extends UniffiEnum implements Delete__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TreeExternalDiff';
    readonly tag = TreeExternalDiff_Tags.Delete;
    readonly inner: Readonly<{
      oldParent: TreeParentId;
      oldIndex: /*u32*/ number;
    }>;
    constructor(inner: { oldParent: TreeParentId; oldIndex: /*u32*/ number }) {
      super('TreeExternalDiff', 'Delete');
      this.inner = Object.freeze(inner);
    }

    static new(inner: {
      oldParent: TreeParentId;
      oldIndex: /*u32*/ number;
    }): Delete_ {
      return new Delete_(inner);
    }

    static instanceOf(obj: any): obj is Delete_ {
      return obj.tag === TreeExternalDiff_Tags.Delete;
    }
  }

  function instanceOf(obj: any): obj is TreeExternalDiff {
    return obj[uniffiTypeNameSymbol] === 'TreeExternalDiff';
  }

  return Object.freeze({
    instanceOf,
    Create: Create_,
    Move: Move_,
    Delete: Delete_,
  });
})();

export type TreeExternalDiff = InstanceType<
  (typeof TreeExternalDiff)[keyof Omit<typeof TreeExternalDiff, 'instanceOf'>]
>;

// FfiConverter for enum TreeExternalDiff
const FfiConverterTypeTreeExternalDiff = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TreeExternalDiff;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new TreeExternalDiff.Create({
            parent: FfiConverterTypeTreeParentId.read(from),
            index: FfiConverterUInt32.read(from),
            fractionalIndex: FfiConverterString.read(from),
          });
        case 2:
          return new TreeExternalDiff.Move({
            parent: FfiConverterTypeTreeParentId.read(from),
            index: FfiConverterUInt32.read(from),
            fractionalIndex: FfiConverterString.read(from),
            oldParent: FfiConverterTypeTreeParentId.read(from),
            oldIndex: FfiConverterUInt32.read(from),
          });
        case 3:
          return new TreeExternalDiff.Delete({
            oldParent: FfiConverterTypeTreeParentId.read(from),
            oldIndex: FfiConverterUInt32.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case TreeExternalDiff_Tags.Create: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeTreeParentId.write(inner.parent, into);
          FfiConverterUInt32.write(inner.index, into);
          FfiConverterString.write(inner.fractionalIndex, into);
          return;
        }
        case TreeExternalDiff_Tags.Move: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterTypeTreeParentId.write(inner.parent, into);
          FfiConverterUInt32.write(inner.index, into);
          FfiConverterString.write(inner.fractionalIndex, into);
          FfiConverterTypeTreeParentId.write(inner.oldParent, into);
          FfiConverterUInt32.write(inner.oldIndex, into);
          return;
        }
        case TreeExternalDiff_Tags.Delete: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterTypeTreeParentId.write(inner.oldParent, into);
          FfiConverterUInt32.write(inner.oldIndex, into);
          return;
        }
        default:
          // Throwing from here means that TreeExternalDiff_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case TreeExternalDiff_Tags.Create: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeTreeParentId.allocationSize(inner.parent);
          size += FfiConverterUInt32.allocationSize(inner.index);
          size += FfiConverterString.allocationSize(inner.fractionalIndex);
          return size;
        }
        case TreeExternalDiff_Tags.Move: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterTypeTreeParentId.allocationSize(inner.parent);
          size += FfiConverterUInt32.allocationSize(inner.index);
          size += FfiConverterString.allocationSize(inner.fractionalIndex);
          size += FfiConverterTypeTreeParentId.allocationSize(inner.oldParent);
          size += FfiConverterUInt32.allocationSize(inner.oldIndex);
          return size;
        }
        case TreeExternalDiff_Tags.Delete: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterTypeTreeParentId.allocationSize(inner.oldParent);
          size += FfiConverterUInt32.allocationSize(inner.oldIndex);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// Enum: TreeParentId
export enum TreeParentId_Tags {
  Node = 'Node',
  Root = 'Root',
  Deleted = 'Deleted',
  Unexist = 'Unexist',
}
export const TreeParentId = (() => {
  type Node__interface = {
    tag: TreeParentId_Tags.Node;
    inner: Readonly<{ id: TreeId }>;
  };

  class Node_ extends UniffiEnum implements Node__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TreeParentId';
    readonly tag = TreeParentId_Tags.Node;
    readonly inner: Readonly<{ id: TreeId }>;
    constructor(inner: { id: TreeId }) {
      super('TreeParentId', 'Node');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { id: TreeId }): Node_ {
      return new Node_(inner);
    }

    static instanceOf(obj: any): obj is Node_ {
      return obj.tag === TreeParentId_Tags.Node;
    }
  }

  type Root__interface = {
    tag: TreeParentId_Tags.Root;
  };

  class Root_ extends UniffiEnum implements Root__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TreeParentId';
    readonly tag = TreeParentId_Tags.Root;
    constructor() {
      super('TreeParentId', 'Root');
    }

    static new(): Root_ {
      return new Root_();
    }

    static instanceOf(obj: any): obj is Root_ {
      return obj.tag === TreeParentId_Tags.Root;
    }
  }

  type Deleted__interface = {
    tag: TreeParentId_Tags.Deleted;
  };

  class Deleted_ extends UniffiEnum implements Deleted__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TreeParentId';
    readonly tag = TreeParentId_Tags.Deleted;
    constructor() {
      super('TreeParentId', 'Deleted');
    }

    static new(): Deleted_ {
      return new Deleted_();
    }

    static instanceOf(obj: any): obj is Deleted_ {
      return obj.tag === TreeParentId_Tags.Deleted;
    }
  }

  type Unexist__interface = {
    tag: TreeParentId_Tags.Unexist;
  };

  class Unexist_ extends UniffiEnum implements Unexist__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'TreeParentId';
    readonly tag = TreeParentId_Tags.Unexist;
    constructor() {
      super('TreeParentId', 'Unexist');
    }

    static new(): Unexist_ {
      return new Unexist_();
    }

    static instanceOf(obj: any): obj is Unexist_ {
      return obj.tag === TreeParentId_Tags.Unexist;
    }
  }

  function instanceOf(obj: any): obj is TreeParentId {
    return obj[uniffiTypeNameSymbol] === 'TreeParentId';
  }

  return Object.freeze({
    instanceOf,
    Node: Node_,
    Root: Root_,
    Deleted: Deleted_,
    Unexist: Unexist_,
  });
})();

export type TreeParentId = InstanceType<
  (typeof TreeParentId)[keyof Omit<typeof TreeParentId, 'instanceOf'>]
>;

// FfiConverter for enum TreeParentId
const FfiConverterTypeTreeParentId = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = TreeParentId;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new TreeParentId.Node({
            id: FfiConverterTypeTreeID.read(from),
          });
        case 2:
          return new TreeParentId.Root();
        case 3:
          return new TreeParentId.Deleted();
        case 4:
          return new TreeParentId.Unexist();
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case TreeParentId_Tags.Node: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterTypeTreeID.write(inner.id, into);
          return;
        }
        case TreeParentId_Tags.Root: {
          ordinalConverter.write(2, into);
          return;
        }
        case TreeParentId_Tags.Deleted: {
          ordinalConverter.write(3, into);
          return;
        }
        case TreeParentId_Tags.Unexist: {
          ordinalConverter.write(4, into);
          return;
        }
        default:
          // Throwing from here means that TreeParentId_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case TreeParentId_Tags.Node: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterTypeTreeID.allocationSize(inner.id);
          return size;
        }
        case TreeParentId_Tags.Root: {
          return ordinalConverter.allocationSize(2);
        }
        case TreeParentId_Tags.Deleted: {
          return ordinalConverter.allocationSize(3);
        }
        case TreeParentId_Tags.Unexist: {
          return ordinalConverter.allocationSize(4);
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

export enum UndoOrRedo {
  Undo,
  Redo,
}

const FfiConverterTypeUndoOrRedo = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = UndoOrRedo;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return UndoOrRedo.Undo;
        case 2:
          return UndoOrRedo.Redo;
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value) {
        case UndoOrRedo.Undo:
          return ordinalConverter.write(1, into);
        case UndoOrRedo.Redo:
          return ordinalConverter.write(2, into);
      }
    }
    allocationSize(value: TypeName): number {
      return ordinalConverter.allocationSize(0);
    }
  }
  return new FFIConverter();
})();

// Flat error type: UpdateTimeoutError
export enum UpdateTimeoutError_Tags {
  Timeout = 'Timeout',
}
export const UpdateTimeoutError = (() => {
  class Timeout extends UniffiError {
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [uniffiTypeNameSymbol]: string = 'UpdateTimeoutError';
    /**
     * @private
     * This field is private and should not be used.
     */
    readonly [variantOrdinalSymbol] = 1;

    public readonly tag = UpdateTimeoutError_Tags.Timeout;

    constructor(message: string) {
      super('UpdateTimeoutError', 'Timeout', message);
    }

    static instanceOf(e: any): e is Timeout {
      return instanceOf(e) && (e as any)[variantOrdinalSymbol] === 1;
    }
  }

  // Utility function which does not rely on instanceof.
  function instanceOf(e: any): e is UpdateTimeoutError {
    return (e as any)[uniffiTypeNameSymbol] === 'UpdateTimeoutError';
  }
  return {
    Timeout,
    instanceOf,
  };
})();

// Union type for UpdateTimeoutError error type.

export type UpdateTimeoutError = InstanceType<
  (typeof UpdateTimeoutError)[keyof Omit<
    typeof UpdateTimeoutError,
    'instanceOf'
  >]
>;

const FfiConverterTypeUpdateTimeoutError = (() => {
  const intConverter = FfiConverterInt32;
  type TypeName = UpdateTimeoutError;
  class FfiConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (intConverter.read(from)) {
        case 1:
          return new UpdateTimeoutError.Timeout(FfiConverterString.read(from));

        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      const obj = value as any;
      const index = obj[variantOrdinalSymbol] as number;
      intConverter.write(index, into);
    }
    allocationSize(value: TypeName): number {
      return intConverter.allocationSize(0);
    }
  }
  return new FfiConverter();
})();

// FfiConverter for Map</*u64*/bigint, CounterSpan>
const FfiConverterMapUInt64TypeCounterSpan = new FfiConverterMap(
  FfiConverterUInt64,
  FfiConverterTypeCounterSpan
);

// FfiConverter for Map</*u64*/bigint, PeerInfo>
const FfiConverterMapUInt64TypePeerInfo = new FfiConverterMap(
  FfiConverterUInt64,
  FfiConverterTypePeerInfo
);

/**
 * Deprecated, use `EphemeralStore` instead.
 */
export interface AwarenessInterface {
  apply(encodedPeersInfo: ArrayBuffer): AwarenessPeerUpdate;
  encode(peers: Array</*u64*/ bigint>): ArrayBuffer;
  encodeAll(): ArrayBuffer;
  getAllStates(): Map</*u64*/ bigint, PeerInfo>;
  getLocalState(): LoroValue | undefined;
  peer(): /*u64*/ bigint;
  removeOutdated(): Array</*u64*/ bigint>;
  setLocalState(value: LoroValueLike): void;
}

/**
 * Deprecated, use `EphemeralStore` instead.
 */
export class Awareness
  extends UniffiAbstractObject
  implements AwarenessInterface
{
  readonly [uniffiTypeNameSymbol] = 'Awareness';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(peer: /*u64*/ bigint, timeout: /*i64*/ bigint) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_awareness_new(
          FfiConverterUInt64.lower(peer),
          FfiConverterInt64.lower(timeout),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeAwarenessObjectFactory.bless(pointer);
  }

  public apply(encodedPeersInfo: ArrayBuffer): AwarenessPeerUpdate {
    return FfiConverterTypeAwarenessPeerUpdate.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_awareness_apply(
            uniffiTypeAwarenessObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(encodedPeersInfo),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public encode(peers: Array</*u64*/ bigint>): ArrayBuffer {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_awareness_encode(
            uniffiTypeAwarenessObjectFactory.clonePointer(this),
            FfiConverterArrayUInt64.lower(peers),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public encodeAll(): ArrayBuffer {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_awareness_encode_all(
            uniffiTypeAwarenessObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getAllStates(): Map</*u64*/ bigint, PeerInfo> {
    return FfiConverterMapUInt64TypePeerInfo.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_awareness_get_all_states(
            uniffiTypeAwarenessObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getLocalState(): LoroValue | undefined {
    return FfiConverterOptionalTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_awareness_get_local_state(
            uniffiTypeAwarenessObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public peer(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_awareness_peer(
            uniffiTypeAwarenessObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public removeOutdated(): Array</*u64*/ bigint> {
    return FfiConverterArrayUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_awareness_remove_outdated(
            uniffiTypeAwarenessObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setLocalState(value: LoroValueLike): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_awareness_set_local_state(
          uniffiTypeAwarenessObjectFactory.clonePointer(this),
          FfiConverterTypeLoroValueLike.lower(value),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeAwarenessObjectFactory.pointer(this);
      uniffiTypeAwarenessObjectFactory.freePointer(pointer);
      uniffiTypeAwarenessObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Awareness {
    return uniffiTypeAwarenessObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeAwarenessObjectFactory: UniffiObjectFactory<AwarenessInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): AwarenessInterface {
      const instance = Object.create(Awareness.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Awareness';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_awareness_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: AwarenessInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: AwarenessInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_awareness(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_awareness(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is AwarenessInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Awareness'
      );
    },
  };
// FfiConverter for AwarenessInterface
const FfiConverterTypeAwareness = new FfiConverterObject(
  uniffiTypeAwarenessObjectFactory
);

export interface ChangeAncestorsTraveler {
  travel(change: ChangeMeta): boolean;
}

export class ChangeAncestorsTravelerImpl
  extends UniffiAbstractObject
  implements ChangeAncestorsTraveler
{
  readonly [uniffiTypeNameSymbol] = 'ChangeAncestorsTravelerImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeChangeAncestorsTravelerImplObjectFactory.bless(pointer);
  }

  public travel(change: ChangeMeta): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_changeancestorstraveler_travel(
            uniffiTypeChangeAncestorsTravelerImplObjectFactory.clonePointer(
              this
            ),
            FfiConverterTypeChangeMeta.lower(change),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeChangeAncestorsTravelerImplObjectFactory.pointer(this);
      uniffiTypeChangeAncestorsTravelerImplObjectFactory.freePointer(pointer);
      uniffiTypeChangeAncestorsTravelerImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is ChangeAncestorsTravelerImpl {
    return uniffiTypeChangeAncestorsTravelerImplObjectFactory.isConcreteType(
      obj
    );
  }
}

const uniffiTypeChangeAncestorsTravelerImplObjectFactory: UniffiObjectFactory<ChangeAncestorsTraveler> =
  {
    create(pointer: UnsafeMutableRawPointer): ChangeAncestorsTraveler {
      const instance = Object.create(ChangeAncestorsTravelerImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ChangeAncestorsTravelerImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_changeancestorstraveler_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: ChangeAncestorsTraveler): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ChangeAncestorsTraveler): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_changeancestorstraveler(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_changeancestorstraveler(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is ChangeAncestorsTraveler {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'ChangeAncestorsTravelerImpl'
      );
    },
  };
// FfiConverter for ChangeAncestorsTraveler
const FfiConverterTypeChangeAncestorsTraveler =
  new FfiConverterObjectWithCallbacks(
    uniffiTypeChangeAncestorsTravelerImplObjectFactory
  );

// Add a vtavble for the callbacks that go in ChangeAncestorsTraveler.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceChangeAncestorsTraveler: {
  vtable: UniffiVTableCallbackInterfaceChangeAncestorsTraveler;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    travel: (uniffiHandle: bigint, change: Uint8Array) => {
      const uniffiMakeCall = (): boolean => {
        const jsCallback =
          FfiConverterTypeChangeAncestorsTraveler.lift(uniffiHandle);
        return jsCallback.travel(FfiConverterTypeChangeMeta.lift(change));
      };
      const uniffiResult = UniffiResult.ready<number>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(uniffiResult, FfiConverterBool.lower(obj));
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // ChangeAncestorsTraveler: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeChangeAncestorsTraveler.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_loro_ffi_fn_init_callback_vtable_changeancestorstraveler(
      uniffiCallbackInterfaceChangeAncestorsTraveler.vtable
    );
  },
};

export interface ChangeModifierInterface {
  setMessage(msg: string): void;
  setTimestamp(timestamp: /*i64*/ bigint): void;
}

export class ChangeModifier
  extends UniffiAbstractObject
  implements ChangeModifierInterface
{
  readonly [uniffiTypeNameSymbol] = 'ChangeModifier';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeChangeModifierObjectFactory.bless(pointer);
  }

  public setMessage(msg: string): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_changemodifier_set_message(
          uniffiTypeChangeModifierObjectFactory.clonePointer(this),
          FfiConverterString.lower(msg),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public setTimestamp(timestamp: /*i64*/ bigint): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_changemodifier_set_timestamp(
          uniffiTypeChangeModifierObjectFactory.clonePointer(this),
          FfiConverterInt64.lower(timestamp),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeChangeModifierObjectFactory.pointer(this);
      uniffiTypeChangeModifierObjectFactory.freePointer(pointer);
      uniffiTypeChangeModifierObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is ChangeModifier {
    return uniffiTypeChangeModifierObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeChangeModifierObjectFactory: UniffiObjectFactory<ChangeModifierInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): ChangeModifierInterface {
      const instance = Object.create(ChangeModifier.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ChangeModifier';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_changemodifier_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: ChangeModifierInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ChangeModifierInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_changemodifier(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_changemodifier(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is ChangeModifierInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'ChangeModifier'
      );
    },
  };
// FfiConverter for ChangeModifierInterface
const FfiConverterTypeChangeModifier = new FfiConverterObject(
  uniffiTypeChangeModifierObjectFactory
);

export interface ConfigureInterface {
  fork(): ConfigureInterface;
  mergeInterval(): /*i64*/ bigint;
  recordTimestamp(): boolean;
  setMergeInterval(interval: /*i64*/ bigint): void;
  setRecordTimestamp(record: boolean): void;
  textStyleConfig(): StyleConfigMapInterface;
}

export class Configure
  extends UniffiAbstractObject
  implements ConfigureInterface
{
  readonly [uniffiTypeNameSymbol] = 'Configure';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeConfigureObjectFactory.bless(pointer);
  }

  public fork(): ConfigureInterface {
    return FfiConverterTypeConfigure.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_configure_fork(
            uniffiTypeConfigureObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public mergeInterval(): /*i64*/ bigint {
    return FfiConverterInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_configure_merge_interval(
            uniffiTypeConfigureObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public recordTimestamp(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_configure_record_timestamp(
            uniffiTypeConfigureObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setMergeInterval(interval: /*i64*/ bigint): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_configure_set_merge_interval(
          uniffiTypeConfigureObjectFactory.clonePointer(this),
          FfiConverterInt64.lower(interval),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public setRecordTimestamp(record: boolean): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_configure_set_record_timestamp(
          uniffiTypeConfigureObjectFactory.clonePointer(this),
          FfiConverterBool.lower(record),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public textStyleConfig(): StyleConfigMapInterface {
    return FfiConverterTypeStyleConfigMap.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_configure_text_style_config(
            uniffiTypeConfigureObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeConfigureObjectFactory.pointer(this);
      uniffiTypeConfigureObjectFactory.freePointer(pointer);
      uniffiTypeConfigureObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Configure {
    return uniffiTypeConfigureObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeConfigureObjectFactory: UniffiObjectFactory<ConfigureInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): ConfigureInterface {
      const instance = Object.create(Configure.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Configure';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_configure_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: ConfigureInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ConfigureInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_configure(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_configure(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is ConfigureInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Configure'
      );
    },
  };
// FfiConverter for ConfigureInterface
const FfiConverterTypeConfigure = new FfiConverterObject(
  uniffiTypeConfigureObjectFactory
);

export interface ContainerIdLike {
  asContainerId(ty: ContainerType): ContainerId;
}

export class ContainerIdLikeImpl
  extends UniffiAbstractObject
  implements ContainerIdLike
{
  readonly [uniffiTypeNameSymbol] = 'ContainerIdLikeImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeContainerIdLikeImplObjectFactory.bless(pointer);
  }

  public asContainerId(ty: ContainerType): ContainerId {
    return FfiConverterTypeContainerID.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_containeridlike_as_container_id(
            uniffiTypeContainerIdLikeImplObjectFactory.clonePointer(this),
            FfiConverterTypeContainerType.lower(ty),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeContainerIdLikeImplObjectFactory.pointer(this);
      uniffiTypeContainerIdLikeImplObjectFactory.freePointer(pointer);
      uniffiTypeContainerIdLikeImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is ContainerIdLikeImpl {
    return uniffiTypeContainerIdLikeImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeContainerIdLikeImplObjectFactory: UniffiObjectFactory<ContainerIdLike> =
  {
    create(pointer: UnsafeMutableRawPointer): ContainerIdLike {
      const instance = Object.create(ContainerIdLikeImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ContainerIdLikeImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_containeridlike_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: ContainerIdLike): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ContainerIdLike): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_containeridlike(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_containeridlike(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is ContainerIdLike {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'ContainerIdLikeImpl'
      );
    },
  };
// FfiConverter for ContainerIdLike
const FfiConverterTypeContainerIdLike = new FfiConverterObjectWithCallbacks(
  uniffiTypeContainerIdLikeImplObjectFactory
);

// Add a vtavble for the callbacks that go in ContainerIdLike.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceContainerIdLike: {
  vtable: UniffiVTableCallbackInterfaceContainerIdLike;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    asContainerId: (uniffiHandle: bigint, ty: Uint8Array) => {
      const uniffiMakeCall = (): ContainerId => {
        const jsCallback = FfiConverterTypeContainerIdLike.lift(uniffiHandle);
        return jsCallback.asContainerId(FfiConverterTypeContainerType.lift(ty));
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterTypeContainerID.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // ContainerIdLike: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeContainerIdLike.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_loro_ffi_fn_init_callback_vtable_containeridlike(
      uniffiCallbackInterfaceContainerIdLike.vtable
    );
  },
};

export interface CursorInterface {
  encode(): ArrayBuffer;
}

export class Cursor extends UniffiAbstractObject implements CursorInterface {
  readonly [uniffiTypeNameSymbol] = 'Cursor';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(
    id: Id | undefined,
    container: ContainerId,
    side: Side,
    originPos: /*u32*/ number
  ) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_cursor_new(
          FfiConverterOptionalTypeID.lower(id),
          FfiConverterTypeContainerID.lower(container),
          FfiConverterTypeSide.lower(side),
          FfiConverterUInt32.lower(originPos),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeCursorObjectFactory.bless(pointer);
  }

  public static decode(data: ArrayBuffer): CursorInterface /*throws*/ {
    return FfiConverterTypeCursor.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_cursor_decode(
            FfiConverterArrayBuffer.lower(data),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public encode(): ArrayBuffer {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_cursor_encode(
            uniffiTypeCursorObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeCursorObjectFactory.pointer(this);
      uniffiTypeCursorObjectFactory.freePointer(pointer);
      uniffiTypeCursorObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Cursor {
    return uniffiTypeCursorObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeCursorObjectFactory: UniffiObjectFactory<CursorInterface> = {
  create(pointer: UnsafeMutableRawPointer): CursorInterface {
    const instance = Object.create(Cursor.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'Cursor';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_cursor_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: CursorInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: CursorInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_loro_ffi_fn_clone_cursor(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_loro_ffi_fn_free_cursor(pointer, callStatus),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is CursorInterface {
    return obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Cursor';
  },
};
// FfiConverter for CursorInterface
const FfiConverterTypeCursor = new FfiConverterObject(
  uniffiTypeCursorObjectFactory
);

export interface DiffBatchInterface {
  /**
   * Returns an iterator over the diffs in this batch, in the order they were added.
   *
   * The iterator yields tuples of `(&ContainerID, &Diff)` where:
   * - `ContainerID` is the ID of the container that was modified
   * - `Diff` contains the actual changes made to that container
   *
   * The order of the diffs is preserved from when they were originally added to the batch.
   */
  getDiff(): Array<ContainerIdAndDiff>;
  /**
   * Push a new event to the batch.
   *
   * If the cid already exists in the batch, return Err
   */
  push(cid: ContainerId, diff: Diff): Diff | undefined;
}

export class DiffBatch
  extends UniffiAbstractObject
  implements DiffBatchInterface
{
  readonly [uniffiTypeNameSymbol] = 'DiffBatch';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_diffbatch_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeDiffBatchObjectFactory.bless(pointer);
  }

  /**
   * Returns an iterator over the diffs in this batch, in the order they were added.
   *
   * The iterator yields tuples of `(&ContainerID, &Diff)` where:
   * - `ContainerID` is the ID of the container that was modified
   * - `Diff` contains the actual changes made to that container
   *
   * The order of the diffs is preserved from when they were originally added to the batch.
   */
  public getDiff(): Array<ContainerIdAndDiff> {
    return FfiConverterArrayTypeContainerIDAndDiff.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_diffbatch_get_diff(
            uniffiTypeDiffBatchObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Push a new event to the batch.
   *
   * If the cid already exists in the batch, return Err
   */
  public push(cid: ContainerId, diff: Diff): Diff | undefined {
    return FfiConverterOptionalTypeDiff.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_diffbatch_push(
            uniffiTypeDiffBatchObjectFactory.clonePointer(this),
            FfiConverterTypeContainerID.lower(cid),
            FfiConverterTypeDiff.lower(diff),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeDiffBatchObjectFactory.pointer(this);
      uniffiTypeDiffBatchObjectFactory.freePointer(pointer);
      uniffiTypeDiffBatchObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is DiffBatch {
    return uniffiTypeDiffBatchObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeDiffBatchObjectFactory: UniffiObjectFactory<DiffBatchInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): DiffBatchInterface {
      const instance = Object.create(DiffBatch.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'DiffBatch';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_diffbatch_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: DiffBatchInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: DiffBatchInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_diffbatch(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_diffbatch(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is DiffBatchInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'DiffBatch'
      );
    },
  };
// FfiConverter for DiffBatchInterface
const FfiConverterTypeDiffBatch = new FfiConverterObject(
  uniffiTypeDiffBatchObjectFactory
);

export interface EphemeralStoreInterface {
  apply(data: ArrayBuffer): void;
  delete_(key: string): void;
  encode(key: string): ArrayBuffer;
  encodeAll(): ArrayBuffer;
  get(key: string): LoroValue | undefined;
  getAllStates(): Map<string, LoroValue>;
  keys(): Array<string>;
  removeOutdated(): void;
  set(key: string, value: LoroValueLike): void;
  subscribe(listener: EphemeralSubscriber): SubscriptionInterface;
  subscribeLocalUpdate(listener: LocalEphemeralListener): SubscriptionInterface;
}

export class EphemeralStore
  extends UniffiAbstractObject
  implements EphemeralStoreInterface
{
  readonly [uniffiTypeNameSymbol] = 'EphemeralStore';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(timeout: /*i64*/ bigint) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_ephemeralstore_new(
          FfiConverterInt64.lower(timeout),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeEphemeralStoreObjectFactory.bless(pointer);
  }

  public apply(data: ArrayBuffer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_ephemeralstore_apply(
          uniffiTypeEphemeralStoreObjectFactory.clonePointer(this),
          FfiConverterArrayBuffer.lower(data),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public delete_(key: string): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_ephemeralstore_delete(
          uniffiTypeEphemeralStoreObjectFactory.clonePointer(this),
          FfiConverterString.lower(key),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public encode(key: string): ArrayBuffer {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_ephemeralstore_encode(
            uniffiTypeEphemeralStoreObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public encodeAll(): ArrayBuffer {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_ephemeralstore_encode_all(
            uniffiTypeEphemeralStoreObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public get(key: string): LoroValue | undefined {
    return FfiConverterOptionalTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_ephemeralstore_get(
            uniffiTypeEphemeralStoreObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getAllStates(): Map<string, LoroValue> {
    return FfiConverterMapStringTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_ephemeralstore_get_all_states(
            uniffiTypeEphemeralStoreObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public keys(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_ephemeralstore_keys(
            uniffiTypeEphemeralStoreObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public removeOutdated(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_ephemeralstore_remove_outdated(
          uniffiTypeEphemeralStoreObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public set(key: string, value: LoroValueLike): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_ephemeralstore_set(
          uniffiTypeEphemeralStoreObjectFactory.clonePointer(this),
          FfiConverterString.lower(key),
          FfiConverterTypeLoroValueLike.lower(value),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public subscribe(listener: EphemeralSubscriber): SubscriptionInterface {
    return FfiConverterTypeSubscription.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_ephemeralstore_subscribe(
            uniffiTypeEphemeralStoreObjectFactory.clonePointer(this),
            FfiConverterTypeEphemeralSubscriber.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public subscribeLocalUpdate(
    listener: LocalEphemeralListener
  ): SubscriptionInterface {
    return FfiConverterTypeSubscription.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_ephemeralstore_subscribe_local_update(
            uniffiTypeEphemeralStoreObjectFactory.clonePointer(this),
            FfiConverterTypeLocalEphemeralListener.lower(listener),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeEphemeralStoreObjectFactory.pointer(this);
      uniffiTypeEphemeralStoreObjectFactory.freePointer(pointer);
      uniffiTypeEphemeralStoreObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is EphemeralStore {
    return uniffiTypeEphemeralStoreObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeEphemeralStoreObjectFactory: UniffiObjectFactory<EphemeralStoreInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): EphemeralStoreInterface {
      const instance = Object.create(EphemeralStore.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'EphemeralStore';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_ephemeralstore_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: EphemeralStoreInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: EphemeralStoreInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_ephemeralstore(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_ephemeralstore(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is EphemeralStoreInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'EphemeralStore'
      );
    },
  };
// FfiConverter for EphemeralStoreInterface
const FfiConverterTypeEphemeralStore = new FfiConverterObject(
  uniffiTypeEphemeralStoreObjectFactory
);

export interface EphemeralSubscriber {
  onEphemeralEvent(event: EphemeralStoreEvent): void;
}

export class EphemeralSubscriberImpl
  extends UniffiAbstractObject
  implements EphemeralSubscriber
{
  readonly [uniffiTypeNameSymbol] = 'EphemeralSubscriberImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeEphemeralSubscriberImplObjectFactory.bless(pointer);
  }

  public onEphemeralEvent(event: EphemeralStoreEvent): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_ephemeralsubscriber_on_ephemeral_event(
          uniffiTypeEphemeralSubscriberImplObjectFactory.clonePointer(this),
          FfiConverterTypeEphemeralStoreEvent.lower(event),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeEphemeralSubscriberImplObjectFactory.pointer(this);
      uniffiTypeEphemeralSubscriberImplObjectFactory.freePointer(pointer);
      uniffiTypeEphemeralSubscriberImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is EphemeralSubscriberImpl {
    return uniffiTypeEphemeralSubscriberImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeEphemeralSubscriberImplObjectFactory: UniffiObjectFactory<EphemeralSubscriber> =
  {
    create(pointer: UnsafeMutableRawPointer): EphemeralSubscriber {
      const instance = Object.create(EphemeralSubscriberImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'EphemeralSubscriberImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_ephemeralsubscriber_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: EphemeralSubscriber): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: EphemeralSubscriber): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_ephemeralsubscriber(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_ephemeralsubscriber(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is EphemeralSubscriber {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'EphemeralSubscriberImpl'
      );
    },
  };
// FfiConverter for EphemeralSubscriber
const FfiConverterTypeEphemeralSubscriber = new FfiConverterObjectWithCallbacks(
  uniffiTypeEphemeralSubscriberImplObjectFactory
);

// Add a vtavble for the callbacks that go in EphemeralSubscriber.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceEphemeralSubscriber: {
  vtable: UniffiVTableCallbackInterfaceEphemeralSubscriber;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onEphemeralEvent: (uniffiHandle: bigint, event: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeEphemeralSubscriber.lift(uniffiHandle);
        return jsCallback.onEphemeralEvent(
          FfiConverterTypeEphemeralStoreEvent.lift(event)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // EphemeralSubscriber: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeEphemeralSubscriber.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_loro_ffi_fn_init_callback_vtable_ephemeralsubscriber(
      uniffiCallbackInterfaceEphemeralSubscriber.vtable
    );
  },
};

export interface FirstCommitFromPeerCallback {
  onFirstCommitFromPeer(payload: FirstCommitFromPeerPayload): void;
}

export class FirstCommitFromPeerCallbackImpl
  extends UniffiAbstractObject
  implements FirstCommitFromPeerCallback
{
  readonly [uniffiTypeNameSymbol] = 'FirstCommitFromPeerCallbackImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFirstCommitFromPeerCallbackImplObjectFactory.bless(pointer);
  }

  public onFirstCommitFromPeer(payload: FirstCommitFromPeerPayload): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_firstcommitfrompeercallback_on_first_commit_from_peer(
          uniffiTypeFirstCommitFromPeerCallbackImplObjectFactory.clonePointer(
            this
          ),
          FfiConverterTypeFirstCommitFromPeerPayload.lower(payload),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeFirstCommitFromPeerCallbackImplObjectFactory.pointer(this);
      uniffiTypeFirstCommitFromPeerCallbackImplObjectFactory.freePointer(
        pointer
      );
      uniffiTypeFirstCommitFromPeerCallbackImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FirstCommitFromPeerCallbackImpl {
    return uniffiTypeFirstCommitFromPeerCallbackImplObjectFactory.isConcreteType(
      obj
    );
  }
}

const uniffiTypeFirstCommitFromPeerCallbackImplObjectFactory: UniffiObjectFactory<FirstCommitFromPeerCallback> =
  {
    create(pointer: UnsafeMutableRawPointer): FirstCommitFromPeerCallback {
      const instance = Object.create(FirstCommitFromPeerCallbackImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'FirstCommitFromPeerCallbackImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_firstcommitfrompeercallback_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: FirstCommitFromPeerCallback): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: FirstCommitFromPeerCallback): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_firstcommitfrompeercallback(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_firstcommitfrompeercallback(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is FirstCommitFromPeerCallback {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'FirstCommitFromPeerCallbackImpl'
      );
    },
  };
// FfiConverter for FirstCommitFromPeerCallback
const FfiConverterTypeFirstCommitFromPeerCallback =
  new FfiConverterObjectWithCallbacks(
    uniffiTypeFirstCommitFromPeerCallbackImplObjectFactory
  );

// Add a vtavble for the callbacks that go in FirstCommitFromPeerCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceFirstCommitFromPeerCallback: {
  vtable: UniffiVTableCallbackInterfaceFirstCommitFromPeerCallback;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onFirstCommitFromPeer: (uniffiHandle: bigint, payload: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeFirstCommitFromPeerCallback.lift(uniffiHandle);
        return jsCallback.onFirstCommitFromPeer(
          FfiConverterTypeFirstCommitFromPeerPayload.lift(payload)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // FirstCommitFromPeerCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeFirstCommitFromPeerCallback.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_loro_ffi_fn_init_callback_vtable_firstcommitfrompeercallback(
      uniffiCallbackInterfaceFirstCommitFromPeerCallback.vtable
    );
  },
};

export interface FractionalIndexInterface {
  toString(): string;
}

export class FractionalIndex
  extends UniffiAbstractObject
  implements FractionalIndexInterface
{
  readonly [uniffiTypeNameSymbol] = 'FractionalIndex';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFractionalIndexObjectFactory.bless(pointer);
  }

  public static fromBytes(bytes: ArrayBuffer): FractionalIndexInterface {
    return FfiConverterTypeFractionalIndex.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_fractionalindex_from_bytes(
            FfiConverterArrayBuffer.lower(bytes),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static fromHexString(str: string): FractionalIndexInterface {
    return FfiConverterTypeFractionalIndex.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_fractionalindex_from_hex_string(
            FfiConverterString.lower(str),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public toString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_fractionalindex_to_string(
            uniffiTypeFractionalIndexObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFractionalIndexObjectFactory.pointer(this);
      uniffiTypeFractionalIndexObjectFactory.freePointer(pointer);
      uniffiTypeFractionalIndexObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FractionalIndex {
    return uniffiTypeFractionalIndexObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFractionalIndexObjectFactory: UniffiObjectFactory<FractionalIndexInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): FractionalIndexInterface {
      const instance = Object.create(FractionalIndex.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'FractionalIndex';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_fractionalindex_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: FractionalIndexInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: FractionalIndexInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_fractionalindex(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_fractionalindex(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is FractionalIndexInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'FractionalIndex'
      );
    },
  };
// FfiConverter for FractionalIndexInterface
const FfiConverterTypeFractionalIndex = new FfiConverterObject(
  uniffiTypeFractionalIndexObjectFactory
);

export interface FrontiersInterface {
  encode(): ArrayBuffer;
  eq(other: FrontiersInterface): boolean;
}

export class Frontiers
  extends UniffiAbstractObject
  implements FrontiersInterface
{
  readonly [uniffiTypeNameSymbol] = 'Frontiers';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_frontiers_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFrontiersObjectFactory.bless(pointer);
  }

  public static decode(bytes: ArrayBuffer): FrontiersInterface /*throws*/ {
    return FfiConverterTypeFrontiers.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_frontiers_decode(
            FfiConverterArrayBuffer.lower(bytes),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static fromId(id: Id): FrontiersInterface {
    return FfiConverterTypeFrontiers.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_frontiers_from_id(
            FfiConverterTypeID.lower(id),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public static fromIds(ids: Array<Id>): FrontiersInterface {
    return FfiConverterTypeFrontiers.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_frontiers_from_ids(
            FfiConverterArrayTypeID.lower(ids),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public encode(): ArrayBuffer {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_frontiers_encode(
            uniffiTypeFrontiersObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public eq(other: FrontiersInterface): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_frontiers_eq(
            uniffiTypeFrontiersObjectFactory.clonePointer(this),
            FfiConverterTypeFrontiers.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFrontiersObjectFactory.pointer(this);
      uniffiTypeFrontiersObjectFactory.freePointer(pointer);
      uniffiTypeFrontiersObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Frontiers {
    return uniffiTypeFrontiersObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFrontiersObjectFactory: UniffiObjectFactory<FrontiersInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): FrontiersInterface {
      const instance = Object.create(Frontiers.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Frontiers';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_frontiers_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: FrontiersInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: FrontiersInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_frontiers(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_frontiers(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is FrontiersInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'Frontiers'
      );
    },
  };
// FfiConverter for FrontiersInterface
const FfiConverterTypeFrontiers = new FfiConverterObject(
  uniffiTypeFrontiersObjectFactory
);

export interface LocalEphemeralListener {
  onEphemeralUpdate(update: ArrayBuffer): void;
}

export class LocalEphemeralListenerImpl
  extends UniffiAbstractObject
  implements LocalEphemeralListener
{
  readonly [uniffiTypeNameSymbol] = 'LocalEphemeralListenerImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeLocalEphemeralListenerImplObjectFactory.bless(pointer);
  }

  public onEphemeralUpdate(update: ArrayBuffer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_localephemerallistener_on_ephemeral_update(
          uniffiTypeLocalEphemeralListenerImplObjectFactory.clonePointer(this),
          FfiConverterArrayBuffer.lower(update),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeLocalEphemeralListenerImplObjectFactory.pointer(this);
      uniffiTypeLocalEphemeralListenerImplObjectFactory.freePointer(pointer);
      uniffiTypeLocalEphemeralListenerImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is LocalEphemeralListenerImpl {
    return uniffiTypeLocalEphemeralListenerImplObjectFactory.isConcreteType(
      obj
    );
  }
}

const uniffiTypeLocalEphemeralListenerImplObjectFactory: UniffiObjectFactory<LocalEphemeralListener> =
  {
    create(pointer: UnsafeMutableRawPointer): LocalEphemeralListener {
      const instance = Object.create(LocalEphemeralListenerImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'LocalEphemeralListenerImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_localephemerallistener_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: LocalEphemeralListener): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: LocalEphemeralListener): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_localephemerallistener(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_localephemerallistener(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is LocalEphemeralListener {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'LocalEphemeralListenerImpl'
      );
    },
  };
// FfiConverter for LocalEphemeralListener
const FfiConverterTypeLocalEphemeralListener =
  new FfiConverterObjectWithCallbacks(
    uniffiTypeLocalEphemeralListenerImplObjectFactory
  );

// Add a vtavble for the callbacks that go in LocalEphemeralListener.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceLocalEphemeralListener: {
  vtable: UniffiVTableCallbackInterfaceLocalEphemeralListener;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onEphemeralUpdate: (uniffiHandle: bigint, update: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeLocalEphemeralListener.lift(uniffiHandle);
        return jsCallback.onEphemeralUpdate(
          FfiConverterArrayBuffer.lift(update)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // LocalEphemeralListener: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeLocalEphemeralListener.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_loro_ffi_fn_init_callback_vtable_localephemerallistener(
      uniffiCallbackInterfaceLocalEphemeralListener.vtable
    );
  },
};

export interface LocalUpdateCallback {
  onLocalUpdate(update: ArrayBuffer): void;
}

export class LocalUpdateCallbackImpl
  extends UniffiAbstractObject
  implements LocalUpdateCallback
{
  readonly [uniffiTypeNameSymbol] = 'LocalUpdateCallbackImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeLocalUpdateCallbackImplObjectFactory.bless(pointer);
  }

  public onLocalUpdate(update: ArrayBuffer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_localupdatecallback_on_local_update(
          uniffiTypeLocalUpdateCallbackImplObjectFactory.clonePointer(this),
          FfiConverterArrayBuffer.lower(update),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypeLocalUpdateCallbackImplObjectFactory.pointer(this);
      uniffiTypeLocalUpdateCallbackImplObjectFactory.freePointer(pointer);
      uniffiTypeLocalUpdateCallbackImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is LocalUpdateCallbackImpl {
    return uniffiTypeLocalUpdateCallbackImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeLocalUpdateCallbackImplObjectFactory: UniffiObjectFactory<LocalUpdateCallback> =
  {
    create(pointer: UnsafeMutableRawPointer): LocalUpdateCallback {
      const instance = Object.create(LocalUpdateCallbackImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'LocalUpdateCallbackImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_localupdatecallback_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: LocalUpdateCallback): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: LocalUpdateCallback): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_localupdatecallback(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_localupdatecallback(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is LocalUpdateCallback {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'LocalUpdateCallbackImpl'
      );
    },
  };
// FfiConverter for LocalUpdateCallback
const FfiConverterTypeLocalUpdateCallback = new FfiConverterObjectWithCallbacks(
  uniffiTypeLocalUpdateCallbackImplObjectFactory
);

// Add a vtavble for the callbacks that go in LocalUpdateCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceLocalUpdateCallback: {
  vtable: UniffiVTableCallbackInterfaceLocalUpdateCallback;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onLocalUpdate: (uniffiHandle: bigint, update: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback =
          FfiConverterTypeLocalUpdateCallback.lift(uniffiHandle);
        return jsCallback.onLocalUpdate(FfiConverterArrayBuffer.lift(update));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // LocalUpdateCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeLocalUpdateCallback.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_loro_ffi_fn_init_callback_vtable_localupdatecallback(
      uniffiCallbackInterfaceLocalUpdateCallback.vtable
    );
  },
};

export interface LoroCounterInterface {
  /**
   * Decrement the counter by the given value.
   */
  decrement(value: /*f64*/ number) /*throws*/ : void;
  /**
   * Get the LoroDoc from this container
   */
  doc(): LoroDocInterface | undefined;
  /**
   * If a detached container is attached, this method will return its corresponding attached handler.
   */
  getAttached(): LoroCounterInterface | undefined;
  /**
   * Get the current value of the counter.
   */
  getValue(): /*f64*/ number;
  /**
   * Return container id of the Counter.
   */
  id(): ContainerId;
  /**
   * Increment the counter by the given value.
   */
  increment(value: /*f64*/ number) /*throws*/ : void;
  /**
   * Whether the container is attached to a document
   *
   * The edits on a detached container will not be persisted.
   * To attach the container to the document, please insert it into an attached container.
   */
  isAttached(): boolean;
  /**
   * Whether the container is deleted.
   */
  isDeleted(): boolean;
  /**
   * Subscribe the events of a container.
   *
   * The callback will be invoked when the container is changed.
   * Returns a subscription that can be used to unsubscribe.
   *
   * The events will be emitted after a transaction is committed. A transaction is committed when:
   *
   * - `doc.commit()` is called.
   * - `doc.export(mode)` is called.
   * - `doc.import(data)` is called.
   * - `doc.checkout(version)` is called.
   */
  subscribe(subscriber: Subscriber): SubscriptionInterface | undefined;
}

export class LoroCounter
  extends UniffiAbstractObject
  implements LoroCounterInterface
{
  readonly [uniffiTypeNameSymbol] = 'LoroCounter';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Create a new Counter.
   */
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_lorocounter_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeLoroCounterObjectFactory.bless(pointer);
  }

  /**
   * Decrement the counter by the given value.
   */
  public decrement(value: /*f64*/ number): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorocounter_decrement(
          uniffiTypeLoroCounterObjectFactory.clonePointer(this),
          FfiConverterFloat64.lower(value),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Get the LoroDoc from this container
   */
  public doc(): LoroDocInterface | undefined {
    return FfiConverterOptionalTypeLoroDoc.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorocounter_doc(
            uniffiTypeLoroCounterObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * If a detached container is attached, this method will return its corresponding attached handler.
   */
  public getAttached(): LoroCounterInterface | undefined {
    return FfiConverterOptionalTypeLoroCounter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorocounter_get_attached(
            uniffiTypeLoroCounterObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the current value of the counter.
   */
  public getValue(): /*f64*/ number {
    return FfiConverterFloat64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorocounter_get_value(
            uniffiTypeLoroCounterObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Return container id of the Counter.
   */
  public id(): ContainerId {
    return FfiConverterTypeContainerID.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorocounter_id(
            uniffiTypeLoroCounterObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Increment the counter by the given value.
   */
  public increment(value: /*f64*/ number): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorocounter_increment(
          uniffiTypeLoroCounterObjectFactory.clonePointer(this),
          FfiConverterFloat64.lower(value),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Whether the container is attached to a document
   *
   * The edits on a detached container will not be persisted.
   * To attach the container to the document, please insert it into an attached container.
   */
  public isAttached(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorocounter_is_attached(
            uniffiTypeLoroCounterObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the container is deleted.
   */
  public isDeleted(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorocounter_is_deleted(
            uniffiTypeLoroCounterObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Subscribe the events of a container.
   *
   * The callback will be invoked when the container is changed.
   * Returns a subscription that can be used to unsubscribe.
   *
   * The events will be emitted after a transaction is committed. A transaction is committed when:
   *
   * - `doc.commit()` is called.
   * - `doc.export(mode)` is called.
   * - `doc.import(data)` is called.
   * - `doc.checkout(version)` is called.
   */
  public subscribe(subscriber: Subscriber): SubscriptionInterface | undefined {
    return FfiConverterOptionalTypeSubscription.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorocounter_subscribe(
            uniffiTypeLoroCounterObjectFactory.clonePointer(this),
            FfiConverterTypeSubscriber.lower(subscriber),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeLoroCounterObjectFactory.pointer(this);
      uniffiTypeLoroCounterObjectFactory.freePointer(pointer);
      uniffiTypeLoroCounterObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is LoroCounter {
    return uniffiTypeLoroCounterObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeLoroCounterObjectFactory: UniffiObjectFactory<LoroCounterInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): LoroCounterInterface {
      const instance = Object.create(LoroCounter.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'LoroCounter';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_lorocounter_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: LoroCounterInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: LoroCounterInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_lorocounter(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_lorocounter(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is LoroCounterInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'LoroCounter'
      );
    },
  };
// FfiConverter for LoroCounterInterface
const FfiConverterTypeLoroCounter = new FfiConverterObject(
  uniffiTypeLoroCounterObjectFactory
);

/**
 * `LoroDoc` is the entry for the whole document.
 * When it's dropped, all the associated [`Handler`]s will be invalidated.
 *
 * **Important:** Loro is a pure library and does not handle network protocols.
 * It is the responsibility of the user to manage the storage, loading, and synchronization
 * of the bytes exported by Loro in a manner suitable for their specific environment.
 */
export interface LoroDocInterface {
  /**
   * Apply a diff to the current document state.
   *
   * Internally, it will apply the diff to the current state.
   */
  applyDiff(diff: DiffBatchInterface) /*throws*/ : void;
  /**
   * Attach the document state to the latest known version.
   *
   * > The document becomes detached during a `checkout` operation.
   * > Being `detached` implies that the `DocState` is not synchronized with the latest version of the `OpLog`.
   * > In a detached state, the document is not editable, and any `import` operations will be
   * > recorded in the `OpLog` without being applied to the `DocState`.
   */
  attach(): void;
  /**
   * Check the correctness of the document state by comparing it with the state
   * calculated by applying all the history.
   */
  checkStateCorrectnessSlow(): void;
  /**
   * Checkout the `DocState` to a specific version.
   *
   * The document becomes detached during a `checkout` operation.
   * Being `detached` implies that the `DocState` is not synchronized with the latest version of the `OpLog`.
   * In a detached state, the document is not editable, and any `import` operations will be
   * recorded in the `OpLog` without being applied to the `DocState`.
   *
   * You should call `attach` to attach the `DocState` to the latest version of `OpLog`.
   */
  checkout(frontiers: FrontiersInterface) /*throws*/ : void;
  /**
   * Checkout the `DocState` to the latest version.
   *
   * > The document becomes detached during a `checkout` operation.
   * > Being `detached` implies that the `DocState` is not synchronized with the latest version of the `OpLog`.
   * > In a detached state, the document is not editable, and any `import` operations will be
   * > recorded in the `OpLog` without being applied to the `DocState`.
   *
   * This has the same effect as `attach`.
   */
  checkoutToLatest(): void;
  /**
   * Clear the options of the next commit.
   */
  clearNextCommitOptions(): void;
  /**
   * Compare the frontiers with the current OpLog's version.
   *
   * If `other` contains any version that's not contained in the current OpLog, return [Ordering::Less].
   */
  cmpWithFrontiers(other: FrontiersInterface): Ordering;
  /**
   * Commit the cumulative auto commit transaction.
   *
   * There is a transaction behind every operation.
   * The events will be emitted after a transaction is committed. A transaction is committed when:
   *
   * - `doc.commit()` is called.
   * - `doc.export(mode)` is called.
   * - `doc.import(data)` is called.
   * - `doc.checkout(version)` is called.
   */
  commit(): void;
  commitWith(options: CommitOptions): void;
  /**
   * Encoded all ops and history cache to bytes and store them in the kv store.
   *
   * The parsed ops will be dropped
   */
  compactChangeStore(): void;
  /**
   * Get the configurations of the document.
   */
  config(): ConfigureInterface;
  /**
   * Configures the default text style for the document.
   *
   * This method sets the default text style configuration for the document when using LoroText.
   * If `None` is provided, the default style is reset.
   *
   * # Parameters
   *
   * - `text_style`: The style configuration to set as the default. `None` to reset.
   */
  configDefaultTextStyle(textStyle: StyleConfig | undefined): void;
  /**
   * Set the rich text format configuration of the document.
   *
   * You need to config it if you use rich text `mark` method.
   * Specifically, you need to config the `expand` property of each style.
   *
   * Expand is used to specify the behavior of expanding when new text is inserted at the
   * beginning or end of the style.
   */
  configTextStyle(textStyle: StyleConfigMapInterface): void;
  /**
   * Delete all content from a root container and hide it from the document.
   *
   * When a root container is empty and hidden:
   * - It won't show up in `get_deep_value()` results
   * - It won't be included in document snapshots
   *
   * Only works on root containers (containers without parents).
   */
  deleteRootContainer(cid: ContainerId): void;
  /**
   * Force the document enter the detached mode.
   *
   * In this mode, when you importing new updates, the [loro_internal::DocState] will not be changed.
   *
   * Learn more at https://loro.dev/docs/advanced/doc_state_and_oplog#attacheddetached-status
   */
  detach(): void;
  /**
   * Calculate the diff between two versions
   */
  diff(
    a: FrontiersInterface,
    b: FrontiersInterface
  ) /*throws*/ : DiffBatchInterface;
  /**
   * Exports changes within the specified ID span to JSON schema format.
   *
   * The JSON schema format produced by this method is identical to the one generated by `export_json_updates`.
   * It ensures deterministic output, making it ideal for hash calculations and integrity checks.
   *
   * This method can also export pending changes from the uncommitted transaction that have not yet been applied to the OpLog.
   *
   * This method will NOT trigger a new commit implicitly.
   */
  exportJsonInIdSpan(idSpan: IdSpan): Array<string>;
  /**
   * Export the current state with json-string format of the document.
   */
  exportJsonUpdates(
    startVv: VersionVectorInterface,
    endVv: VersionVectorInterface
  ): string;
  /**
   * Export the current state with json-string format of the document, without peer compression.
   *
   * Compared to [`export_json_updates`], this method does not compress the peer IDs in the updates.
   * So the operations are easier to be processed by application code.
   */
  exportJsonUpdatesWithoutPeerCompression(
    startVv: VersionVectorInterface,
    endVv: VersionVectorInterface
  ): string;
  exportShallowSnapshot(frontiers: FrontiersInterface) /*throws*/ : ArrayBuffer;
  /**
   * Export the current state and history of the document.
   */
  exportSnapshot() /*throws*/ : ArrayBuffer;
  exportSnapshotAt(frontiers: FrontiersInterface) /*throws*/ : ArrayBuffer;
  exportStateOnly(
    frontiers: FrontiersInterface | undefined
  ) /*throws*/ : ArrayBuffer;
  /**
   * Export all the ops not included in the given `VersionVector`
   */
  exportUpdates(vv: VersionVectorInterface) /*throws*/ : ArrayBuffer;
  exportUpdatesInRange(spans: Array<IdSpan>) /*throws*/ : ArrayBuffer;
  /**
   * Find the operation id spans that between the `from` version and the `to` version.
   */
  findIdSpansBetween(
    from: FrontiersInterface,
    to: FrontiersInterface
  ): VersionVectorDiff;
  /**
   * Duplicate the document with a different PeerID
   *
   * The time complexity and space complexity of this operation are both O(n),
   *
   * When called in detached mode, it will fork at the current state frontiers.
   * It will have the same effect as `fork_at(&self.state_frontiers())`.
   */
  fork(): LoroDocInterface;
  /**
   * Fork the document at the given frontiers.
   *
   * The created doc will only contain the history before the specified frontiers.
   */
  forkAt(frontiers: FrontiersInterface): LoroDocInterface;
  /**
   * Free the cached diff calculator that is used for checkout.
   */
  freeDiffCalculator(): void;
  /**
   * Free the history cache that is used for making checkout faster.
   *
   * If you use checkout that switching to an old/concurrent version, the history cache will be built.
   * You can free it by calling this method.
   */
  freeHistoryCache(): void;
  /**
   * Convert `Frontiers` into `VersionVector`
   */
  frontiersToVv(
    frontiers: FrontiersInterface
  ): VersionVectorInterface | undefined;
  /**
   * Get the handler by the path.
   */
  getByPath(path: Array<Index>): ValueOrContainerInterface | undefined;
  /**
   * The path can be specified in different ways depending on the container type:
   *
   * For Tree:
   * 1. Using node IDs: `tree/{node_id}/property`
   * 2. Using indices: `tree/0/1/property`
   *
   * For List and MovableList:
   * - Using indices: `list/0` or `list/1/property`
   *
   * For Map:
   * - Using keys: `map/key` or `map/nested/property`
   *
   * For tree structures, index-based paths follow depth-first traversal order.
   * The indices start from 0 and represent the position of a node among its siblings.
   *
   * # Examples
   * ```
   * # use loro::{LoroDoc, LoroValue};
   * let doc = LoroDoc::new();
   *
   * // Tree example
   * let tree = doc.get_tree("tree");
   * let root = tree.create(None).unwrap();
   * tree.get_meta(root).unwrap().insert("name", "root").unwrap();
   * // Access tree by ID or index
   * let name1 = doc.get_by_str_path(&format!("tree/{}/name", root)).unwrap().into_value().unwrap();
   * let name2 = doc.get_by_str_path("tree/0/name").unwrap().into_value().unwrap();
   * assert_eq!(name1, name2);
   *
   * // List example
   * let list = doc.get_list("list");
   * list.insert(0, "first").unwrap();
   * list.insert(1, "second").unwrap();
   * // Access list by index
   * let item = doc.get_by_str_path("list/0");
   * assert_eq!(item.unwrap().into_value().unwrap().into_string().unwrap(), "first".into());
   *
   * // Map example
   * let map = doc.get_map("map");
   * map.insert("key", "value").unwrap();
   * // Access map by key
   * let value = doc.get_by_str_path("map/key");
   * assert_eq!(value.unwrap().into_value().unwrap().into_string().unwrap(), "value".into());
   *
   * // MovableList example
   * let mlist = doc.get_movable_list("mlist");
   * mlist.insert(0, "item").unwrap();
   * // Access movable list by index
   * let item = doc.get_by_str_path("mlist/0");
   * assert_eq!(item.unwrap().into_value().unwrap().into_string().unwrap(), "item".into());
   * ```
   */
  getByStrPath(path: string): ValueOrContainerInterface | undefined;
  /**
   * Get `Change` at the given id.
   *
   * `Change` is a grouped continuous operations that share the same id, timestamp, commit message.
   *
   * - The id of the `Change` is the id of its first op.
   * - The second op's id is `{ peer: change.id.peer, counter: change.id.counter + 1 }`
   *
   * The same applies on `Lamport`:
   *
   * - The lamport of the `Change` is the lamport of its first op.
   * - The second op's lamport is `change.lamport + 1`
   *
   * The length of the `Change` is how many operations it contains
   */
  getChange(id: Id): ChangeMeta | undefined;
  /**
   * Gets container IDs modified in the given ID range.
   *
   * **NOTE:** This method will implicitly commit.
   *
   * This method can be used in conjunction with `doc.travel_change_ancestors()` to traverse
   * the history and identify all changes that affected specific containers.
   *
   * # Arguments
   *
   * * `id` - The starting ID of the change range
   * * `len` - The length of the change range to check
   */
  getChangedContainersIn(id: Id, len: /*u32*/ number): Array<ContainerId>;
  /**
   * Get a [LoroCounter] by container id.
   *
   * If the provided id is string, it will be converted into a root container id with the name of the string.
   */
  getCounter(id: ContainerIdLike): LoroCounterInterface;
  getCursorPos(cursor: CursorInterface) /*throws*/ : PosQueryResult;
  /**
   * Get the entire state of the current DocState
   */
  getDeepValue(): LoroValue;
  /**
   * Get the entire state of the current DocState with container id
   */
  getDeepValueWithId(): LoroValue;
  /**
   * Get a [LoroList] by container id.
   *
   * If the provided id is string, it will be converted into a root container id with the name of the string.
   */
  getList(id: ContainerIdLike): LoroListInterface;
  /**
   * Get a [LoroMap] by container id.
   *
   * If the provided id is string, it will be converted into a root container id with the name of the string.
   */
  getMap(id: ContainerIdLike): LoroMapInterface;
  /**
   * Get a [LoroMovableList] by container id.
   *
   * If the provided id is string, it will be converted into a root container id with the name of the string.
   */
  getMovableList(id: ContainerIdLike): LoroMovableListInterface;
  /**
   * Get the path from the root to the container
   */
  getPathToContainer(id: ContainerId): Array<ContainerPath> | undefined;
  /**
   * Get the number of operations in the pending transaction.
   *
   * The pending transaction is the one that is not committed yet. It will be committed
   * after calling `doc.commit()`, `doc.export(mode)` or `doc.checkout(version)`.
   */
  getPendingTxnLen(): /*u32*/ number;
  /**
   * Get a [LoroText] by container id.
   *
   * If the provided id is string, it will be converted into a root container id with the name of the string.
   */
  getText(id: ContainerIdLike): LoroTextInterface;
  /**
   * Get a [LoroTree] by container id.
   *
   * If the provided id is string, it will be converted into a root container id with the name of the string.
   */
  getTree(id: ContainerIdLike): LoroTreeInterface;
  /**
   * Get the shallow value of the document.
   */
  getValue(): LoroValue;
  /**
   * Check if the doc contains the target container.
   *
   * A root container always exists, while a normal container exists
   * if it has ever been created on the doc.
   */
  hasContainer(id: ContainerId): boolean;
  hasHistoryCache(): boolean;
  /**
   * Import updates/snapshot exported by [`LoroDoc::export_snapshot`] or [`LoroDoc::export_from`].
   */
  import_(bytes: ArrayBuffer) /*throws*/ : ImportStatus;
  /**
   * Import a batch of updates/snapshot.
   *
   * The data can be in arbitrary order. The import result will be the same.
   */
  importBatch(bytes: Array<ArrayBuffer>) /*throws*/ : ImportStatus;
  importJsonUpdates(json: string) /*throws*/ : ImportStatus;
  /**
   * Import updates/snapshot exported by [`LoroDoc::export_snapshot`] or [`LoroDoc::export_from`].
   *
   * It marks the import with a custom `origin` string. It can be used to track the import source
   * in the generated events.
   */
  importWith(bytes: ArrayBuffer, origin: string) /*throws*/ : ImportStatus;
  /**
   * Whether the document is in detached mode, where the [loro_internal::DocState] is not
   * synchronized with the latest version of the [loro_internal::OpLog].
   */
  isDetached(): boolean;
  /**
   * Check if the doc contains the full history.
   */
  isShallow(): boolean;
  /**
   * Evaluate a JSONPath expression on the document and return matching values or handlers.
   *
   * This method allows querying the document structure using JSONPath syntax.
   * It returns a vector of `ValueOrHandler` which can represent either primitive values
   * or container handlers, depending on what the JSONPath expression matches.
   *
   * # Arguments
   *
   * * `path` - A string slice containing the JSONPath expression to evaluate.
   *
   * # Returns
   *
   * A `Result` containing either:
   * - `Ok(Vec<ValueOrHandler>)`: A vector of matching values or handlers.
   * - `Err(String)`: An error message if the JSONPath expression is invalid or evaluation fails.
   *
   * # Example
   *
   * ```
   * # use loro::LoroDoc;
   * let doc = LoroDoc::new();
   * let map = doc.get_map("users");
   * map.insert("alice", 30).unwrap();
   * map.insert("bob", 25).unwrap();
   *
   * let result = doc.jsonpath("$.users.alice").unwrap();
   * assert_eq!(result.len(), 1);
   * assert_eq!(result[0].to_json_value(), serde_json::json!(30));
   * ```
   */
  jsonpath(path: string) /*throws*/ : Array<ValueOrContainerInterface>;
  /**
   * Get the total number of changes in the `OpLog`
   */
  lenChanges(): /*u64*/ bigint;
  /**
   * Get the total number of operations in the `OpLog`
   */
  lenOps(): /*u64*/ bigint;
  /**
   * Estimate the size of the document states in memory.
   */
  logEstimateSize(): void;
  /**
   * Minimize the frontiers by removing the unnecessary entries.
   */
  minimizeFrontiers(frontiers: FrontiersInterface): FrontiersOrId;
  /**
   * Get the `Frontiers` version of `OpLog`
   */
  oplogFrontiers(): FrontiersInterface;
  /**
   * Get the `VersionVector` version of `OpLog`
   */
  oplogVv(): VersionVectorInterface;
  /**
   * Get the PeerID
   */
  peerId(): /*u64*/ bigint;
  /**
   * Redacts sensitive content in JSON updates within the specified version range.
   *
   * This function allows you to share document history while removing potentially sensitive content.
   * It preserves the document structure and collaboration capabilities while replacing content with
   * placeholders according to these redaction rules:
   *
   * - Preserves delete and move operations
   * - Replaces text insertion content with the Unicode replacement character
   * - Substitutes list and map insert values with null
   * - Maintains structure of child containers
   * - Replaces text mark values with null
   * - Preserves map keys and text annotation keys
   */
  redactJsonUpdates(
    json: string,
    versionRange: VersionRangeInterface
  ) /*throws*/ : string;
  /**
   * Revert the current document state back to the target version
   *
   * Internally, it will generate a series of local operations that can revert the
   * current doc to the target version. It will calculate the diff between the current
   * state and the target state, and apply the diff to the current state.
   */
  revertTo(version: FrontiersInterface) /*throws*/ : void;
  /**
   * Set the interval of mergeable changes, **in seconds**.
   *
   * If two continuous local changes are within the interval, they will be merged into one change.
   * The default value is 1000 seconds.
   *
   * By default, we record timestamps in seconds for each change. So if the merge interval is 1, and changes A and B
   * have timestamps of 3 and 4 respectively, then they will be merged into one change
   */
  setChangeMergeInterval(interval: /*i64*/ bigint): void;
  /**
   * Set whether to hide empty root containers.
   */
  setHideEmptyRootContainers(hide: boolean): void;
  /**
   * Set commit message for the current uncommitted changes
   *
   * It will be persisted.
   */
  setNextCommitMessage(msg: string): void;
  /**
   * Set the options of the next commit.
   *
   * It will be used when the next commit is performed.
   */
  setNextCommitOptions(options: CommitOptions): void;
  /**
   * Set `origin` for the current uncommitted changes, it can be used to track the source of changes in an event.
   *
   * It will NOT be persisted.
   */
  setNextCommitOrigin(origin: string): void;
  /**
   * Set the timestamp of the next commit.
   *
   * It will be persisted and stored in the `OpLog`.
   * You can get the timestamp from the [`Change`] type.
   */
  setNextCommitTimestamp(timestamp: /*i64*/ bigint): void;
  /**
   * Change the PeerID
   *
   * NOTE: You need to make sure there is no chance two peer have the same PeerID.
   * If it happens, the document will be corrupted.
   */
  setPeerId(peer: /*u64*/ bigint) /*throws*/ : void;
  /**
   * Set whether to record the timestamp of each change. Default is `false`.
   *
   * If enabled, the Unix timestamp will be recorded for each change automatically.
   *
   * You can set each timestamp manually when committing a change.
   *
   * NOTE: Timestamps are forced to be in ascending order.
   * If you commit a new change with a timestamp that is less than the existing one,
   * the largest existing timestamp will be used instead.
   */
  setRecordTimestamp(record: boolean): void;
  /**
   * Get the `VersionVector` of trimmed history
   *
   * The ops included by the trimmed history are not in the doc.
   */
  shallowSinceVv(): VersionVectorInterface;
  /**
   * Get the `Frontiers` version of `DocState`
   *
   * Learn more about [`Frontiers`](https://loro.dev/docs/advanced/version_deep_dive)
   */
  stateFrontiers(): FrontiersInterface;
  /**
   * Get the `VersionVector` version of `DocState`
   */
  stateVv(): VersionVectorInterface;
  /**
   * Subscribe the events of a container.
   *
   * The callback will be invoked when the container is changed.
   * Returns a subscription that can be used to unsubscribe.
   *
   * The events will be emitted after a transaction is committed. A transaction is committed when:
   *
   * - `doc.commit()` is called.
   * - `doc.export(mode)` is called.
   * - `doc.import(data)` is called.
   * - `doc.checkout(version)` is called.
   */
  subscribe(
    containerId: ContainerId,
    subscriber: Subscriber
  ): SubscriptionInterface;
  /**
   * Subscribe to the first commit from a peer. Operations performed on the `LoroDoc` within this callback
   * will be merged into the current commit.
   *
   * This is useful for managing the relationship between `PeerID` and user information.
   * For example, you could store user names in a `LoroMap` using `PeerID` as the key and the `UserID` as the value.
   */
  subscribeFirstCommitFromPeer(
    callback: FirstCommitFromPeerCallback
  ): SubscriptionInterface;
  /**
   * Subscribe the local update of the document.
   */
  subscribeLocalUpdate(callback: LocalUpdateCallback): SubscriptionInterface;
  /**
   * Subscribe to the pre-commit event.
   *
   * The callback will be called when the changes are committed but not yet applied to the OpLog.
   * You can modify the commit message and timestamp in the callback by [`ChangeModifier`].
   */
  subscribePreCommit(callback: PreCommitCallback): SubscriptionInterface;
  /**
   * Subscribe all the events.
   *
   * The callback will be invoked when any part of the [loro_internal::DocState] is changed.
   * Returns a subscription that can be used to unsubscribe.
   */
  subscribeRoot(subscriber: Subscriber): SubscriptionInterface;
  /**
   * Traverses the ancestors of the Change containing the given ID, including itself.
   *
   * This method visits all ancestors in causal order, from the latest to the oldest,
   * based on their Lamport timestamps.
   *
   * # Arguments
   *
   * * `ids` - The IDs of the Change to start the traversal from.
   * * `f` - A mutable function that is called for each ancestor. It can return `ControlFlow::Break(())` to stop the traversal.
   */
  travelChangeAncestors(
    ids: Array<Id>,
    f: ChangeAncestorsTraveler
  ) /*throws*/ : void;
  /**
   * Convert `VersionVector` into `Frontiers`
   */
  vvToFrontiers(vv: VersionVectorInterface): FrontiersInterface;
}

/**
 * `LoroDoc` is the entry for the whole document.
 * When it's dropped, all the associated [`Handler`]s will be invalidated.
 *
 * **Important:** Loro is a pure library and does not handle network protocols.
 * It is the responsibility of the user to manage the storage, loading, and synchronization
 * of the bytes exported by Loro in a manner suitable for their specific environment.
 */
export class LoroDoc extends UniffiAbstractObject implements LoroDocInterface {
  readonly [uniffiTypeNameSymbol] = 'LoroDoc';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Create a new `LoroDoc` instance.
   */
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_lorodoc_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeLoroDocObjectFactory.bless(pointer);
  }

  /**
   * Apply a diff to the current document state.
   *
   * Internally, it will apply the diff to the current state.
   */
  public applyDiff(diff: DiffBatchInterface): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_apply_diff(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          FfiConverterTypeDiffBatch.lower(diff),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Attach the document state to the latest known version.
   *
   * > The document becomes detached during a `checkout` operation.
   * > Being `detached` implies that the `DocState` is not synchronized with the latest version of the `OpLog`.
   * > In a detached state, the document is not editable, and any `import` operations will be
   * > recorded in the `OpLog` without being applied to the `DocState`.
   */
  public attach(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_attach(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Check the correctness of the document state by comparing it with the state
   * calculated by applying all the history.
   */
  public checkStateCorrectnessSlow(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_check_state_correctness_slow(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Checkout the `DocState` to a specific version.
   *
   * The document becomes detached during a `checkout` operation.
   * Being `detached` implies that the `DocState` is not synchronized with the latest version of the `OpLog`.
   * In a detached state, the document is not editable, and any `import` operations will be
   * recorded in the `OpLog` without being applied to the `DocState`.
   *
   * You should call `attach` to attach the `DocState` to the latest version of `OpLog`.
   */
  public checkout(frontiers: FrontiersInterface): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_checkout(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          FfiConverterTypeFrontiers.lower(frontiers),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Checkout the `DocState` to the latest version.
   *
   * > The document becomes detached during a `checkout` operation.
   * > Being `detached` implies that the `DocState` is not synchronized with the latest version of the `OpLog`.
   * > In a detached state, the document is not editable, and any `import` operations will be
   * > recorded in the `OpLog` without being applied to the `DocState`.
   *
   * This has the same effect as `attach`.
   */
  public checkoutToLatest(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_checkout_to_latest(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Clear the options of the next commit.
   */
  public clearNextCommitOptions(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_clear_next_commit_options(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Compare the frontiers with the current OpLog's version.
   *
   * If `other` contains any version that's not contained in the current OpLog, return [Ordering::Less].
   */
  public cmpWithFrontiers(other: FrontiersInterface): Ordering {
    return FfiConverterTypeOrdering.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_cmp_with_frontiers(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeFrontiers.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Commit the cumulative auto commit transaction.
   *
   * There is a transaction behind every operation.
   * The events will be emitted after a transaction is committed. A transaction is committed when:
   *
   * - `doc.commit()` is called.
   * - `doc.export(mode)` is called.
   * - `doc.import(data)` is called.
   * - `doc.checkout(version)` is called.
   */
  public commit(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_commit(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public commitWith(options: CommitOptions): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_commit_with(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          FfiConverterTypeCommitOptions.lower(options),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Encoded all ops and history cache to bytes and store them in the kv store.
   *
   * The parsed ops will be dropped
   */
  public compactChangeStore(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_compact_change_store(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Get the configurations of the document.
   */
  public config(): ConfigureInterface {
    return FfiConverterTypeConfigure.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_config(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Configures the default text style for the document.
   *
   * This method sets the default text style configuration for the document when using LoroText.
   * If `None` is provided, the default style is reset.
   *
   * # Parameters
   *
   * - `text_style`: The style configuration to set as the default. `None` to reset.
   */
  public configDefaultTextStyle(textStyle: StyleConfig | undefined): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_config_default_text_style(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          FfiConverterOptionalTypeStyleConfig.lower(textStyle),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Set the rich text format configuration of the document.
   *
   * You need to config it if you use rich text `mark` method.
   * Specifically, you need to config the `expand` property of each style.
   *
   * Expand is used to specify the behavior of expanding when new text is inserted at the
   * beginning or end of the style.
   */
  public configTextStyle(textStyle: StyleConfigMapInterface): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_config_text_style(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          FfiConverterTypeStyleConfigMap.lower(textStyle),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Delete all content from a root container and hide it from the document.
   *
   * When a root container is empty and hidden:
   * - It won't show up in `get_deep_value()` results
   * - It won't be included in document snapshots
   *
   * Only works on root containers (containers without parents).
   */
  public deleteRootContainer(cid: ContainerId): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_delete_root_container(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          FfiConverterTypeContainerID.lower(cid),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Force the document enter the detached mode.
   *
   * In this mode, when you importing new updates, the [loro_internal::DocState] will not be changed.
   *
   * Learn more at https://loro.dev/docs/advanced/doc_state_and_oplog#attacheddetached-status
   */
  public detach(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_detach(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Calculate the diff between two versions
   */
  public diff(
    a: FrontiersInterface,
    b: FrontiersInterface
  ): DiffBatchInterface /*throws*/ {
    return FfiConverterTypeDiffBatch.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_diff(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeFrontiers.lower(a),
            FfiConverterTypeFrontiers.lower(b),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Exports changes within the specified ID span to JSON schema format.
   *
   * The JSON schema format produced by this method is identical to the one generated by `export_json_updates`.
   * It ensures deterministic output, making it ideal for hash calculations and integrity checks.
   *
   * This method can also export pending changes from the uncommitted transaction that have not yet been applied to the OpLog.
   *
   * This method will NOT trigger a new commit implicitly.
   */
  public exportJsonInIdSpan(idSpan: IdSpan): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_export_json_in_id_span(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeIdSpan.lower(idSpan),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Export the current state with json-string format of the document.
   */
  public exportJsonUpdates(
    startVv: VersionVectorInterface,
    endVv: VersionVectorInterface
  ): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_export_json_updates(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeVersionVector.lower(startVv),
            FfiConverterTypeVersionVector.lower(endVv),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Export the current state with json-string format of the document, without peer compression.
   *
   * Compared to [`export_json_updates`], this method does not compress the peer IDs in the updates.
   * So the operations are easier to be processed by application code.
   */
  public exportJsonUpdatesWithoutPeerCompression(
    startVv: VersionVectorInterface,
    endVv: VersionVectorInterface
  ): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_export_json_updates_without_peer_compression(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeVersionVector.lower(startVv),
            FfiConverterTypeVersionVector.lower(endVv),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public exportShallowSnapshot(
    frontiers: FrontiersInterface
  ): ArrayBuffer /*throws*/ {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroEncodeError.lift.bind(
          FfiConverterTypeLoroEncodeError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_export_shallow_snapshot(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeFrontiers.lower(frontiers),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Export the current state and history of the document.
   */
  public exportSnapshot(): ArrayBuffer /*throws*/ {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroEncodeError.lift.bind(
          FfiConverterTypeLoroEncodeError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_export_snapshot(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public exportSnapshotAt(
    frontiers: FrontiersInterface
  ): ArrayBuffer /*throws*/ {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroEncodeError.lift.bind(
          FfiConverterTypeLoroEncodeError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_export_snapshot_at(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeFrontiers.lower(frontiers),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public exportStateOnly(
    frontiers: FrontiersInterface | undefined
  ): ArrayBuffer /*throws*/ {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroEncodeError.lift.bind(
          FfiConverterTypeLoroEncodeError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_export_state_only(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterOptionalTypeFrontiers.lower(frontiers),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Export all the ops not included in the given `VersionVector`
   */
  public exportUpdates(vv: VersionVectorInterface): ArrayBuffer /*throws*/ {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroEncodeError.lift.bind(
          FfiConverterTypeLoroEncodeError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_export_updates(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeVersionVector.lower(vv),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public exportUpdatesInRange(spans: Array<IdSpan>): ArrayBuffer /*throws*/ {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroEncodeError.lift.bind(
          FfiConverterTypeLoroEncodeError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_export_updates_in_range(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterArrayTypeIdSpan.lower(spans),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Find the operation id spans that between the `from` version and the `to` version.
   */
  public findIdSpansBetween(
    from: FrontiersInterface,
    to: FrontiersInterface
  ): VersionVectorDiff {
    return FfiConverterTypeVersionVectorDiff.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_find_id_spans_between(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeFrontiers.lower(from),
            FfiConverterTypeFrontiers.lower(to),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Duplicate the document with a different PeerID
   *
   * The time complexity and space complexity of this operation are both O(n),
   *
   * When called in detached mode, it will fork at the current state frontiers.
   * It will have the same effect as `fork_at(&self.state_frontiers())`.
   */
  public fork(): LoroDocInterface {
    return FfiConverterTypeLoroDoc.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_fork(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Fork the document at the given frontiers.
   *
   * The created doc will only contain the history before the specified frontiers.
   */
  public forkAt(frontiers: FrontiersInterface): LoroDocInterface {
    return FfiConverterTypeLoroDoc.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_fork_at(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeFrontiers.lower(frontiers),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Free the cached diff calculator that is used for checkout.
   */
  public freeDiffCalculator(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_free_diff_calculator(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Free the history cache that is used for making checkout faster.
   *
   * If you use checkout that switching to an old/concurrent version, the history cache will be built.
   * You can free it by calling this method.
   */
  public freeHistoryCache(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_free_history_cache(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Convert `Frontiers` into `VersionVector`
   */
  public frontiersToVv(
    frontiers: FrontiersInterface
  ): VersionVectorInterface | undefined {
    return FfiConverterOptionalTypeVersionVector.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_frontiers_to_vv(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeFrontiers.lower(frontiers),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the handler by the path.
   */
  public getByPath(path: Array<Index>): ValueOrContainerInterface | undefined {
    return FfiConverterOptionalTypeValueOrContainer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_get_by_path(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterArrayTypeIndex.lower(path),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * The path can be specified in different ways depending on the container type:
   *
   * For Tree:
   * 1. Using node IDs: `tree/{node_id}/property`
   * 2. Using indices: `tree/0/1/property`
   *
   * For List and MovableList:
   * - Using indices: `list/0` or `list/1/property`
   *
   * For Map:
   * - Using keys: `map/key` or `map/nested/property`
   *
   * For tree structures, index-based paths follow depth-first traversal order.
   * The indices start from 0 and represent the position of a node among its siblings.
   *
   * # Examples
   * ```
   * # use loro::{LoroDoc, LoroValue};
   * let doc = LoroDoc::new();
   *
   * // Tree example
   * let tree = doc.get_tree("tree");
   * let root = tree.create(None).unwrap();
   * tree.get_meta(root).unwrap().insert("name", "root").unwrap();
   * // Access tree by ID or index
   * let name1 = doc.get_by_str_path(&format!("tree/{}/name", root)).unwrap().into_value().unwrap();
   * let name2 = doc.get_by_str_path("tree/0/name").unwrap().into_value().unwrap();
   * assert_eq!(name1, name2);
   *
   * // List example
   * let list = doc.get_list("list");
   * list.insert(0, "first").unwrap();
   * list.insert(1, "second").unwrap();
   * // Access list by index
   * let item = doc.get_by_str_path("list/0");
   * assert_eq!(item.unwrap().into_value().unwrap().into_string().unwrap(), "first".into());
   *
   * // Map example
   * let map = doc.get_map("map");
   * map.insert("key", "value").unwrap();
   * // Access map by key
   * let value = doc.get_by_str_path("map/key");
   * assert_eq!(value.unwrap().into_value().unwrap().into_string().unwrap(), "value".into());
   *
   * // MovableList example
   * let mlist = doc.get_movable_list("mlist");
   * mlist.insert(0, "item").unwrap();
   * // Access movable list by index
   * let item = doc.get_by_str_path("mlist/0");
   * assert_eq!(item.unwrap().into_value().unwrap().into_string().unwrap(), "item".into());
   * ```
   */
  public getByStrPath(path: string): ValueOrContainerInterface | undefined {
    return FfiConverterOptionalTypeValueOrContainer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_get_by_str_path(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterString.lower(path),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get `Change` at the given id.
   *
   * `Change` is a grouped continuous operations that share the same id, timestamp, commit message.
   *
   * - The id of the `Change` is the id of its first op.
   * - The second op's id is `{ peer: change.id.peer, counter: change.id.counter + 1 }`
   *
   * The same applies on `Lamport`:
   *
   * - The lamport of the `Change` is the lamport of its first op.
   * - The second op's lamport is `change.lamport + 1`
   *
   * The length of the `Change` is how many operations it contains
   */
  public getChange(id: Id): ChangeMeta | undefined {
    return FfiConverterOptionalTypeChangeMeta.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_get_change(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeID.lower(id),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Gets container IDs modified in the given ID range.
   *
   * **NOTE:** This method will implicitly commit.
   *
   * This method can be used in conjunction with `doc.travel_change_ancestors()` to traverse
   * the history and identify all changes that affected specific containers.
   *
   * # Arguments
   *
   * * `id` - The starting ID of the change range
   * * `len` - The length of the change range to check
   */
  public getChangedContainersIn(
    id: Id,
    len: /*u32*/ number
  ): Array<ContainerId> {
    return FfiConverterArrayTypeContainerID.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_get_changed_containers_in(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeID.lower(id),
            FfiConverterUInt32.lower(len),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get a [LoroCounter] by container id.
   *
   * If the provided id is string, it will be converted into a root container id with the name of the string.
   */
  public getCounter(id: ContainerIdLike): LoroCounterInterface {
    return FfiConverterTypeLoroCounter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_get_counter(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeContainerIdLike.lower(id),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getCursorPos(cursor: CursorInterface): PosQueryResult /*throws*/ {
    return FfiConverterTypePosQueryResult.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeCannotFindRelativePosition.lift.bind(
          FfiConverterTypeCannotFindRelativePosition
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_get_cursor_pos(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeCursor.lower(cursor),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the entire state of the current DocState
   */
  public getDeepValue(): LoroValue {
    return FfiConverterTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_get_deep_value(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the entire state of the current DocState with container id
   */
  public getDeepValueWithId(): LoroValue {
    return FfiConverterTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_get_deep_value_with_id(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get a [LoroList] by container id.
   *
   * If the provided id is string, it will be converted into a root container id with the name of the string.
   */
  public getList(id: ContainerIdLike): LoroListInterface {
    return FfiConverterTypeLoroList.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_get_list(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeContainerIdLike.lower(id),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get a [LoroMap] by container id.
   *
   * If the provided id is string, it will be converted into a root container id with the name of the string.
   */
  public getMap(id: ContainerIdLike): LoroMapInterface {
    return FfiConverterTypeLoroMap.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_get_map(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeContainerIdLike.lower(id),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get a [LoroMovableList] by container id.
   *
   * If the provided id is string, it will be converted into a root container id with the name of the string.
   */
  public getMovableList(id: ContainerIdLike): LoroMovableListInterface {
    return FfiConverterTypeLoroMovableList.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_get_movable_list(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeContainerIdLike.lower(id),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the path from the root to the container
   */
  public getPathToContainer(id: ContainerId): Array<ContainerPath> | undefined {
    return FfiConverterOptionalArrayTypeContainerPath.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_get_path_to_container(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeContainerID.lower(id),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the number of operations in the pending transaction.
   *
   * The pending transaction is the one that is not committed yet. It will be committed
   * after calling `doc.commit()`, `doc.export(mode)` or `doc.checkout(version)`.
   */
  public getPendingTxnLen(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_get_pending_txn_len(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get a [LoroText] by container id.
   *
   * If the provided id is string, it will be converted into a root container id with the name of the string.
   */
  public getText(id: ContainerIdLike): LoroTextInterface {
    return FfiConverterTypeLoroText.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_get_text(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeContainerIdLike.lower(id),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get a [LoroTree] by container id.
   *
   * If the provided id is string, it will be converted into a root container id with the name of the string.
   */
  public getTree(id: ContainerIdLike): LoroTreeInterface {
    return FfiConverterTypeLoroTree.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_get_tree(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeContainerIdLike.lower(id),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the shallow value of the document.
   */
  public getValue(): LoroValue {
    return FfiConverterTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_get_value(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if the doc contains the target container.
   *
   * A root container always exists, while a normal container exists
   * if it has ever been created on the doc.
   */
  public hasContainer(id: ContainerId): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_has_container(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeContainerID.lower(id),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public hasHistoryCache(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_has_history_cache(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Import updates/snapshot exported by [`LoroDoc::export_snapshot`] or [`LoroDoc::export_from`].
   */
  public import_(bytes: ArrayBuffer): ImportStatus /*throws*/ {
    return FfiConverterTypeImportStatus.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_import(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(bytes),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Import a batch of updates/snapshot.
   *
   * The data can be in arbitrary order. The import result will be the same.
   */
  public importBatch(bytes: Array<ArrayBuffer>): ImportStatus /*throws*/ {
    return FfiConverterTypeImportStatus.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_import_batch(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterArrayArrayBuffer.lower(bytes),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public importJsonUpdates(json: string): ImportStatus /*throws*/ {
    return FfiConverterTypeImportStatus.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_import_json_updates(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterString.lower(json),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Import updates/snapshot exported by [`LoroDoc::export_snapshot`] or [`LoroDoc::export_from`].
   *
   * It marks the import with a custom `origin` string. It can be used to track the import source
   * in the generated events.
   */
  public importWith(
    bytes: ArrayBuffer,
    origin: string
  ): ImportStatus /*throws*/ {
    return FfiConverterTypeImportStatus.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_import_with(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterArrayBuffer.lower(bytes),
            FfiConverterString.lower(origin),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the document is in detached mode, where the [loro_internal::DocState] is not
   * synchronized with the latest version of the [loro_internal::OpLog].
   */
  public isDetached(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_is_detached(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if the doc contains the full history.
   */
  public isShallow(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_is_shallow(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Evaluate a JSONPath expression on the document and return matching values or handlers.
   *
   * This method allows querying the document structure using JSONPath syntax.
   * It returns a vector of `ValueOrHandler` which can represent either primitive values
   * or container handlers, depending on what the JSONPath expression matches.
   *
   * # Arguments
   *
   * * `path` - A string slice containing the JSONPath expression to evaluate.
   *
   * # Returns
   *
   * A `Result` containing either:
   * - `Ok(Vec<ValueOrHandler>)`: A vector of matching values or handlers.
   * - `Err(String)`: An error message if the JSONPath expression is invalid or evaluation fails.
   *
   * # Example
   *
   * ```
   * # use loro::LoroDoc;
   * let doc = LoroDoc::new();
   * let map = doc.get_map("users");
   * map.insert("alice", 30).unwrap();
   * map.insert("bob", 25).unwrap();
   *
   * let result = doc.jsonpath("$.users.alice").unwrap();
   * assert_eq!(result.len(), 1);
   * assert_eq!(result[0].to_json_value(), serde_json::json!(30));
   * ```
   */
  public jsonpath(path: string): Array<ValueOrContainerInterface> /*throws*/ {
    return FfiConverterArrayTypeValueOrContainer.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeJsonPathError.lift.bind(
          FfiConverterTypeJsonPathError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_jsonpath(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterString.lower(path),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the total number of changes in the `OpLog`
   */
  public lenChanges(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_len_changes(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the total number of operations in the `OpLog`
   */
  public lenOps(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_len_ops(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Estimate the size of the document states in memory.
   */
  public logEstimateSize(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_log_estimate_size(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Minimize the frontiers by removing the unnecessary entries.
   */
  public minimizeFrontiers(frontiers: FrontiersInterface): FrontiersOrId {
    return FfiConverterTypeFrontiersOrID.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_minimize_frontiers(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeFrontiers.lower(frontiers),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the `Frontiers` version of `OpLog`
   */
  public oplogFrontiers(): FrontiersInterface {
    return FfiConverterTypeFrontiers.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_oplog_frontiers(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the `VersionVector` version of `OpLog`
   */
  public oplogVv(): VersionVectorInterface {
    return FfiConverterTypeVersionVector.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_oplog_vv(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the PeerID
   */
  public peerId(): /*u64*/ bigint {
    return FfiConverterUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_peer_id(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Redacts sensitive content in JSON updates within the specified version range.
   *
   * This function allows you to share document history while removing potentially sensitive content.
   * It preserves the document structure and collaboration capabilities while replacing content with
   * placeholders according to these redaction rules:
   *
   * - Preserves delete and move operations
   * - Replaces text insertion content with the Unicode replacement character
   * - Substitutes list and map insert values with null
   * - Maintains structure of child containers
   * - Replaces text mark values with null
   * - Preserves map keys and text annotation keys
   */
  public redactJsonUpdates(
    json: string,
    versionRange: VersionRangeInterface
  ): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_redact_json_updates(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterString.lower(json),
            FfiConverterTypeVersionRange.lower(versionRange),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Revert the current document state back to the target version
   *
   * Internally, it will generate a series of local operations that can revert the
   * current doc to the target version. It will calculate the diff between the current
   * state and the target state, and apply the diff to the current state.
   */
  public revertTo(version: FrontiersInterface): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_revert_to(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          FfiConverterTypeFrontiers.lower(version),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Set the interval of mergeable changes, **in seconds**.
   *
   * If two continuous local changes are within the interval, they will be merged into one change.
   * The default value is 1000 seconds.
   *
   * By default, we record timestamps in seconds for each change. So if the merge interval is 1, and changes A and B
   * have timestamps of 3 and 4 respectively, then they will be merged into one change
   */
  public setChangeMergeInterval(interval: /*i64*/ bigint): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_set_change_merge_interval(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          FfiConverterInt64.lower(interval),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Set whether to hide empty root containers.
   */
  public setHideEmptyRootContainers(hide: boolean): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_set_hide_empty_root_containers(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          FfiConverterBool.lower(hide),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Set commit message for the current uncommitted changes
   *
   * It will be persisted.
   */
  public setNextCommitMessage(msg: string): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_set_next_commit_message(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          FfiConverterString.lower(msg),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Set the options of the next commit.
   *
   * It will be used when the next commit is performed.
   */
  public setNextCommitOptions(options: CommitOptions): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_set_next_commit_options(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          FfiConverterTypeCommitOptions.lower(options),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Set `origin` for the current uncommitted changes, it can be used to track the source of changes in an event.
   *
   * It will NOT be persisted.
   */
  public setNextCommitOrigin(origin: string): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_set_next_commit_origin(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          FfiConverterString.lower(origin),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Set the timestamp of the next commit.
   *
   * It will be persisted and stored in the `OpLog`.
   * You can get the timestamp from the [`Change`] type.
   */
  public setNextCommitTimestamp(timestamp: /*i64*/ bigint): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_set_next_commit_timestamp(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          FfiConverterInt64.lower(timestamp),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Change the PeerID
   *
   * NOTE: You need to make sure there is no chance two peer have the same PeerID.
   * If it happens, the document will be corrupted.
   */
  public setPeerId(peer: /*u64*/ bigint): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_set_peer_id(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          FfiConverterUInt64.lower(peer),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Set whether to record the timestamp of each change. Default is `false`.
   *
   * If enabled, the Unix timestamp will be recorded for each change automatically.
   *
   * You can set each timestamp manually when committing a change.
   *
   * NOTE: Timestamps are forced to be in ascending order.
   * If you commit a new change with a timestamp that is less than the existing one,
   * the largest existing timestamp will be used instead.
   */
  public setRecordTimestamp(record: boolean): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_set_record_timestamp(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          FfiConverterBool.lower(record),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Get the `VersionVector` of trimmed history
   *
   * The ops included by the trimmed history are not in the doc.
   */
  public shallowSinceVv(): VersionVectorInterface {
    return FfiConverterTypeVersionVector.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_shallow_since_vv(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the `Frontiers` version of `DocState`
   *
   * Learn more about [`Frontiers`](https://loro.dev/docs/advanced/version_deep_dive)
   */
  public stateFrontiers(): FrontiersInterface {
    return FfiConverterTypeFrontiers.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_state_frontiers(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the `VersionVector` version of `DocState`
   */
  public stateVv(): VersionVectorInterface {
    return FfiConverterTypeVersionVector.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_state_vv(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Subscribe the events of a container.
   *
   * The callback will be invoked when the container is changed.
   * Returns a subscription that can be used to unsubscribe.
   *
   * The events will be emitted after a transaction is committed. A transaction is committed when:
   *
   * - `doc.commit()` is called.
   * - `doc.export(mode)` is called.
   * - `doc.import(data)` is called.
   * - `doc.checkout(version)` is called.
   */
  public subscribe(
    containerId: ContainerId,
    subscriber: Subscriber
  ): SubscriptionInterface {
    return FfiConverterTypeSubscription.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_subscribe(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeContainerID.lower(containerId),
            FfiConverterTypeSubscriber.lower(subscriber),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Subscribe to the first commit from a peer. Operations performed on the `LoroDoc` within this callback
   * will be merged into the current commit.
   *
   * This is useful for managing the relationship between `PeerID` and user information.
   * For example, you could store user names in a `LoroMap` using `PeerID` as the key and the `UserID` as the value.
   */
  public subscribeFirstCommitFromPeer(
    callback: FirstCommitFromPeerCallback
  ): SubscriptionInterface {
    return FfiConverterTypeSubscription.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_subscribe_first_commit_from_peer(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeFirstCommitFromPeerCallback.lower(callback),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Subscribe the local update of the document.
   */
  public subscribeLocalUpdate(
    callback: LocalUpdateCallback
  ): SubscriptionInterface {
    return FfiConverterTypeSubscription.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_subscribe_local_update(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeLocalUpdateCallback.lower(callback),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Subscribe to the pre-commit event.
   *
   * The callback will be called when the changes are committed but not yet applied to the OpLog.
   * You can modify the commit message and timestamp in the callback by [`ChangeModifier`].
   */
  public subscribePreCommit(
    callback: PreCommitCallback
  ): SubscriptionInterface {
    return FfiConverterTypeSubscription.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_subscribe_pre_commit(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypePreCommitCallback.lower(callback),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Subscribe all the events.
   *
   * The callback will be invoked when any part of the [loro_internal::DocState] is changed.
   * Returns a subscription that can be used to unsubscribe.
   */
  public subscribeRoot(subscriber: Subscriber): SubscriptionInterface {
    return FfiConverterTypeSubscription.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_subscribe_root(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeSubscriber.lower(subscriber),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Traverses the ancestors of the Change containing the given ID, including itself.
   *
   * This method visits all ancestors in causal order, from the latest to the oldest,
   * based on their Lamport timestamps.
   *
   * # Arguments
   *
   * * `ids` - The IDs of the Change to start the traversal from.
   * * `f` - A mutable function that is called for each ancestor. It can return `ControlFlow::Break(())` to stop the traversal.
   */
  public travelChangeAncestors(
    ids: Array<Id>,
    f: ChangeAncestorsTraveler
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeChangeTravelError.lift.bind(
        FfiConverterTypeChangeTravelError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_travel_change_ancestors(
          uniffiTypeLoroDocObjectFactory.clonePointer(this),
          FfiConverterArrayTypeID.lower(ids),
          FfiConverterTypeChangeAncestorsTraveler.lower(f),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Convert `VersionVector` into `Frontiers`
   */
  public vvToFrontiers(vv: VersionVectorInterface): FrontiersInterface {
    return FfiConverterTypeFrontiers.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorodoc_vv_to_frontiers(
            uniffiTypeLoroDocObjectFactory.clonePointer(this),
            FfiConverterTypeVersionVector.lower(vv),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeLoroDocObjectFactory.pointer(this);
      uniffiTypeLoroDocObjectFactory.freePointer(pointer);
      uniffiTypeLoroDocObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is LoroDoc {
    return uniffiTypeLoroDocObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeLoroDocObjectFactory: UniffiObjectFactory<LoroDocInterface> = {
  create(pointer: UnsafeMutableRawPointer): LoroDocInterface {
    const instance = Object.create(LoroDoc.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'LoroDoc';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_lorodoc_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: LoroDocInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: LoroDocInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_loro_ffi_fn_clone_lorodoc(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_loro_ffi_fn_free_lorodoc(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is LoroDocInterface {
    return (
      obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'LoroDoc'
    );
  },
};
// FfiConverter for LoroDocInterface
const FfiConverterTypeLoroDoc = new FfiConverterObject(
  uniffiTypeLoroDocObjectFactory
);

export interface LoroListInterface {
  /**
   * Delete all elements in the list.
   */
  clear() /*throws*/ : void;
  /**
   * Delete values at the given position.
   */
  delete_(pos: /*u32*/ number, len: /*u32*/ number) /*throws*/ : void;
  /**
   * Get the LoroDoc from this container
   */
  doc(): LoroDocInterface | undefined;
  /**
   * Get the value at the given position.
   */
  get(index: /*u32*/ number): ValueOrContainerInterface | undefined;
  /**
   * If a detached container is attached, this method will return its corresponding attached handler.
   */
  getAttached(): LoroListInterface | undefined;
  getCursor(pos: /*u32*/ number, side: Side): CursorInterface | undefined;
  /**
   * Get the deep value of the container.
   */
  getDeepValue(): LoroValue;
  /**
   * Get the ID of the list item at the given position.
   */
  getIdAt(pos: /*u32*/ number): Id | undefined;
  /**
   * Get the shallow value of the container.
   *
   * This does not convert the state of sub-containers; instead, it represents them as [LoroValue::Container].
   */
  getValue(): LoroValue;
  /**
   * Get the ID of the container.
   */
  id(): ContainerId;
  /**
   * Insert a value at the given position.
   */
  insert(pos: /*u32*/ number, v: LoroValueLike) /*throws*/ : void;
  insertCounterContainer(
    pos: /*u32*/ number,
    child: LoroCounterInterface
  ) /*throws*/ : LoroCounterInterface;
  insertListContainer(
    pos: /*u32*/ number,
    child: LoroListInterface
  ) /*throws*/ : LoroListInterface;
  insertMapContainer(
    pos: /*u32*/ number,
    child: LoroMapInterface
  ) /*throws*/ : LoroMapInterface;
  insertMovableListContainer(
    pos: /*u32*/ number,
    child: LoroMovableListInterface
  ) /*throws*/ : LoroMovableListInterface;
  insertTextContainer(
    pos: /*u32*/ number,
    child: LoroTextInterface
  ) /*throws*/ : LoroTextInterface;
  insertTreeContainer(
    pos: /*u32*/ number,
    child: LoroTreeInterface
  ) /*throws*/ : LoroTreeInterface;
  /**
   * Whether the container is attached to a document
   *
   * The edits on a detached container will not be persisted.
   * To attach the container to the document, please insert it into an attached container.
   */
  isAttached(): boolean;
  /**
   * Whether the container is deleted.
   */
  isDeleted(): boolean;
  isEmpty(): boolean;
  len(): /*u32*/ number;
  /**
   * Pop the last element of the list.
   */
  pop() /*throws*/ : LoroValue | undefined;
  push(v: LoroValueLike) /*throws*/ : void;
  /**
   * Subscribe the events of a container.
   *
   * The callback will be invoked when the container is changed.
   * Returns a subscription that can be used to unsubscribe.
   *
   * The events will be emitted after a transaction is committed. A transaction is committed when:
   *
   * - `doc.commit()` is called.
   * - `doc.export(mode)` is called.
   * - `doc.import(data)` is called.
   * - `doc.checkout(version)` is called.
   */
  subscribe(subscriber: Subscriber): SubscriptionInterface | undefined;
  /**
   * Converts the LoroList to a Vec of LoroValue.
   *
   * This method unwraps the internal Arc and clones the data if necessary,
   * returning a Vec containing all the elements of the LoroList as LoroValue.
   */
  toVec(): Array<LoroValue>;
}

export class LoroList
  extends UniffiAbstractObject
  implements LoroListInterface
{
  readonly [uniffiTypeNameSymbol] = 'LoroList';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Create a new container that is detached from the document.
   *
   * The edits on a detached container will not be persisted.
   * To attach the container to the document, please insert it into an attached container.
   */
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_lorolist_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeLoroListObjectFactory.bless(pointer);
  }

  /**
   * Delete all elements in the list.
   */
  public clear(): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_clear(
          uniffiTypeLoroListObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Delete values at the given position.
   */
  public delete_(pos: /*u32*/ number, len: /*u32*/ number): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_delete(
          uniffiTypeLoroListObjectFactory.clonePointer(this),
          FfiConverterUInt32.lower(pos),
          FfiConverterUInt32.lower(len),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Get the LoroDoc from this container
   */
  public doc(): LoroDocInterface | undefined {
    return FfiConverterOptionalTypeLoroDoc.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_doc(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the value at the given position.
   */
  public get(index: /*u32*/ number): ValueOrContainerInterface | undefined {
    return FfiConverterOptionalTypeValueOrContainer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_get(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(index),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * If a detached container is attached, this method will return its corresponding attached handler.
   */
  public getAttached(): LoroListInterface | undefined {
    return FfiConverterOptionalTypeLoroList.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_get_attached(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getCursor(
    pos: /*u32*/ number,
    side: Side
  ): CursorInterface | undefined {
    return FfiConverterOptionalTypeCursor.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_get_cursor(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeSide.lower(side),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the deep value of the container.
   */
  public getDeepValue(): LoroValue {
    return FfiConverterTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_get_deep_value(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the ID of the list item at the given position.
   */
  public getIdAt(pos: /*u32*/ number): Id | undefined {
    return FfiConverterOptionalTypeID.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_get_id_at(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the shallow value of the container.
   *
   * This does not convert the state of sub-containers; instead, it represents them as [LoroValue::Container].
   */
  public getValue(): LoroValue {
    return FfiConverterTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_get_value(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the ID of the container.
   */
  public id(): ContainerId {
    return FfiConverterTypeContainerID.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_id(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Insert a value at the given position.
   */
  public insert(pos: /*u32*/ number, v: LoroValueLike): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_insert(
          uniffiTypeLoroListObjectFactory.clonePointer(this),
          FfiConverterUInt32.lower(pos),
          FfiConverterTypeLoroValueLike.lower(v),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public insertCounterContainer(
    pos: /*u32*/ number,
    child: LoroCounterInterface
  ): LoroCounterInterface /*throws*/ {
    return FfiConverterTypeLoroCounter.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_insert_counter_container(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroCounter.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insertListContainer(
    pos: /*u32*/ number,
    child: LoroListInterface
  ): LoroListInterface /*throws*/ {
    return FfiConverterTypeLoroList.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_insert_list_container(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroList.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insertMapContainer(
    pos: /*u32*/ number,
    child: LoroMapInterface
  ): LoroMapInterface /*throws*/ {
    return FfiConverterTypeLoroMap.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_insert_map_container(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroMap.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insertMovableListContainer(
    pos: /*u32*/ number,
    child: LoroMovableListInterface
  ): LoroMovableListInterface /*throws*/ {
    return FfiConverterTypeLoroMovableList.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_insert_movable_list_container(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroMovableList.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insertTextContainer(
    pos: /*u32*/ number,
    child: LoroTextInterface
  ): LoroTextInterface /*throws*/ {
    return FfiConverterTypeLoroText.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_insert_text_container(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroText.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insertTreeContainer(
    pos: /*u32*/ number,
    child: LoroTreeInterface
  ): LoroTreeInterface /*throws*/ {
    return FfiConverterTypeLoroTree.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_insert_tree_container(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroTree.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the container is attached to a document
   *
   * The edits on a detached container will not be persisted.
   * To attach the container to the document, please insert it into an attached container.
   */
  public isAttached(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_is_attached(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the container is deleted.
   */
  public isDeleted(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_is_deleted(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isEmpty(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_is_empty(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public len(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_len(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Pop the last element of the list.
   */
  public pop(): LoroValue | undefined /*throws*/ {
    return FfiConverterOptionalTypeLoroValue.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_pop(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public push(v: LoroValueLike): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_push(
          uniffiTypeLoroListObjectFactory.clonePointer(this),
          FfiConverterTypeLoroValueLike.lower(v),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Subscribe the events of a container.
   *
   * The callback will be invoked when the container is changed.
   * Returns a subscription that can be used to unsubscribe.
   *
   * The events will be emitted after a transaction is committed. A transaction is committed when:
   *
   * - `doc.commit()` is called.
   * - `doc.export(mode)` is called.
   * - `doc.import(data)` is called.
   * - `doc.checkout(version)` is called.
   */
  public subscribe(subscriber: Subscriber): SubscriptionInterface | undefined {
    return FfiConverterOptionalTypeSubscription.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_subscribe(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            FfiConverterTypeSubscriber.lower(subscriber),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Converts the LoroList to a Vec of LoroValue.
   *
   * This method unwraps the internal Arc and clones the data if necessary,
   * returning a Vec containing all the elements of the LoroList as LoroValue.
   */
  public toVec(): Array<LoroValue> {
    return FfiConverterArrayTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorolist_to_vec(
            uniffiTypeLoroListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeLoroListObjectFactory.pointer(this);
      uniffiTypeLoroListObjectFactory.freePointer(pointer);
      uniffiTypeLoroListObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is LoroList {
    return uniffiTypeLoroListObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeLoroListObjectFactory: UniffiObjectFactory<LoroListInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): LoroListInterface {
      const instance = Object.create(LoroList.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'LoroList';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_lorolist_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: LoroListInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: LoroListInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_lorolist(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_lorolist(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is LoroListInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'LoroList'
      );
    },
  };
// FfiConverter for LoroListInterface
const FfiConverterTypeLoroList = new FfiConverterObject(
  uniffiTypeLoroListObjectFactory
);

export interface LoroMapInterface {
  /**
   * Delete all key-value pairs in the map.
   */
  clear() /*throws*/ : void;
  /**
   * Delete a key-value pair from the map.
   */
  delete_(key: string) /*throws*/ : void;
  /**
   * Get the LoroDoc from this container
   */
  doc(): LoroDocInterface | undefined;
  /**
   * Get the value of the map with the given key.
   */
  get(key: string): ValueOrContainerInterface | undefined;
  /**
   * If a detached container is attached, this method will return its corresponding attached handler.
   */
  getAttached(): LoroMapInterface | undefined;
  /**
   * Get the deep value of the map.
   *
   * It will convert the state of sub-containers into a nested JSON value.
   */
  getDeepValue(): LoroValue;
  /**
   * Get the peer id of the last editor on the given entry
   */
  getLastEditor(key: string): /*u64*/ bigint | undefined;
  getOrCreateCounterContainer(
    key: string,
    child: LoroCounterInterface
  ) /*throws*/ : LoroCounterInterface;
  getOrCreateListContainer(
    key: string,
    child: LoroListInterface
  ) /*throws*/ : LoroListInterface;
  getOrCreateMapContainer(
    key: string,
    child: LoroMapInterface
  ) /*throws*/ : LoroMapInterface;
  getOrCreateMovableListContainer(
    key: string,
    child: LoroMovableListInterface
  ) /*throws*/ : LoroMovableListInterface;
  getOrCreateTextContainer(
    key: string,
    child: LoroTextInterface
  ) /*throws*/ : LoroTextInterface;
  getOrCreateTreeContainer(
    key: string,
    child: LoroTreeInterface
  ) /*throws*/ : LoroTreeInterface;
  /**
   * Get the shallow value of the map.
   *
   * It will not convert the state of sub-containers, but represent them as [LoroValue::Container].
   */
  getValue(): LoroValue;
  /**
   * Get the ID of the map.
   */
  id(): ContainerId;
  /**
   * Insert a key-value pair into the map.
   *
   * > **Note**: When calling `map.set(key, value)` on a LoroMap, if `map.get(key)` already returns `value`,
   * > the operation will be a no-op (no operation recorded) to avoid unnecessary updates.
   */
  insert(key: string, v: LoroValueLike) /*throws*/ : void;
  insertCounterContainer(
    key: string,
    child: LoroCounterInterface
  ) /*throws*/ : LoroCounterInterface;
  insertListContainer(
    key: string,
    child: LoroListInterface
  ) /*throws*/ : LoroListInterface;
  insertMapContainer(
    key: string,
    child: LoroMapInterface
  ) /*throws*/ : LoroMapInterface;
  insertMovableListContainer(
    key: string,
    child: LoroMovableListInterface
  ) /*throws*/ : LoroMovableListInterface;
  insertTextContainer(
    key: string,
    child: LoroTextInterface
  ) /*throws*/ : LoroTextInterface;
  insertTreeContainer(
    key: string,
    child: LoroTreeInterface
  ) /*throws*/ : LoroTreeInterface;
  /**
   * Whether the container is attached to a document.
   */
  isAttached(): boolean;
  /**
   * Whether the container is deleted.
   */
  isDeleted(): boolean;
  /**
   * Whether the map is empty.
   */
  isEmpty(): boolean;
  /**
   * Get the keys of the map.
   */
  keys(): Array<string>;
  /**
   * Get the length of the map.
   */
  len(): /*u32*/ number;
  /**
   * Subscribe the events of a container.
   *
   * The callback will be invoked when the container is changed.
   * Returns a subscription that can be used to unsubscribe.
   *
   * The events will be emitted after a transaction is committed. A transaction is committed when:
   *
   * - `doc.commit()` is called.
   * - `doc.export(mode)` is called.
   * - `doc.import(data)` is called.
   * - `doc.checkout(version)` is called.
   */
  subscribe(subscriber: Subscriber): SubscriptionInterface | undefined;
  /**
   * Get the values of the map.
   */
  values(): Array<ValueOrContainerInterface>;
}

export class LoroMap extends UniffiAbstractObject implements LoroMapInterface {
  readonly [uniffiTypeNameSymbol] = 'LoroMap';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Create a new container that is detached from the document.
   *
   * The edits on a detached container will not be persisted.
   * To attach the container to the document, please insert it into an attached container.
   */
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_loromap_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] = uniffiTypeLoroMapObjectFactory.bless(pointer);
  }

  /**
   * Delete all key-value pairs in the map.
   */
  public clear(): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_clear(
          uniffiTypeLoroMapObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Delete a key-value pair from the map.
   */
  public delete_(key: string): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_delete(
          uniffiTypeLoroMapObjectFactory.clonePointer(this),
          FfiConverterString.lower(key),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Get the LoroDoc from this container
   */
  public doc(): LoroDocInterface | undefined {
    return FfiConverterOptionalTypeLoroDoc.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_doc(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the value of the map with the given key.
   */
  public get(key: string): ValueOrContainerInterface | undefined {
    return FfiConverterOptionalTypeValueOrContainer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_get(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * If a detached container is attached, this method will return its corresponding attached handler.
   */
  public getAttached(): LoroMapInterface | undefined {
    return FfiConverterOptionalTypeLoroMap.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_get_attached(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the deep value of the map.
   *
   * It will convert the state of sub-containers into a nested JSON value.
   */
  public getDeepValue(): LoroValue {
    return FfiConverterTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_get_deep_value(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the peer id of the last editor on the given entry
   */
  public getLastEditor(key: string): /*u64*/ bigint | undefined {
    return FfiConverterOptionalUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_get_last_editor(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getOrCreateCounterContainer(
    key: string,
    child: LoroCounterInterface
  ): LoroCounterInterface /*throws*/ {
    return FfiConverterTypeLoroCounter.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_get_or_create_counter_container(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterTypeLoroCounter.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getOrCreateListContainer(
    key: string,
    child: LoroListInterface
  ): LoroListInterface /*throws*/ {
    return FfiConverterTypeLoroList.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_get_or_create_list_container(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterTypeLoroList.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getOrCreateMapContainer(
    key: string,
    child: LoroMapInterface
  ): LoroMapInterface /*throws*/ {
    return FfiConverterTypeLoroMap.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_get_or_create_map_container(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterTypeLoroMap.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getOrCreateMovableListContainer(
    key: string,
    child: LoroMovableListInterface
  ): LoroMovableListInterface /*throws*/ {
    return FfiConverterTypeLoroMovableList.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_get_or_create_movable_list_container(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterTypeLoroMovableList.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getOrCreateTextContainer(
    key: string,
    child: LoroTextInterface
  ): LoroTextInterface /*throws*/ {
    return FfiConverterTypeLoroText.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_get_or_create_text_container(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterTypeLoroText.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getOrCreateTreeContainer(
    key: string,
    child: LoroTreeInterface
  ): LoroTreeInterface /*throws*/ {
    return FfiConverterTypeLoroTree.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_get_or_create_tree_container(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterTypeLoroTree.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the shallow value of the map.
   *
   * It will not convert the state of sub-containers, but represent them as [LoroValue::Container].
   */
  public getValue(): LoroValue {
    return FfiConverterTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_get_value(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the ID of the map.
   */
  public id(): ContainerId {
    return FfiConverterTypeContainerID.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_id(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Insert a key-value pair into the map.
   *
   * > **Note**: When calling `map.set(key, value)` on a LoroMap, if `map.get(key)` already returns `value`,
   * > the operation will be a no-op (no operation recorded) to avoid unnecessary updates.
   */
  public insert(key: string, v: LoroValueLike): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_insert(
          uniffiTypeLoroMapObjectFactory.clonePointer(this),
          FfiConverterString.lower(key),
          FfiConverterTypeLoroValueLike.lower(v),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public insertCounterContainer(
    key: string,
    child: LoroCounterInterface
  ): LoroCounterInterface /*throws*/ {
    return FfiConverterTypeLoroCounter.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_insert_counter_container(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterTypeLoroCounter.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insertListContainer(
    key: string,
    child: LoroListInterface
  ): LoroListInterface /*throws*/ {
    return FfiConverterTypeLoroList.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_insert_list_container(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterTypeLoroList.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insertMapContainer(
    key: string,
    child: LoroMapInterface
  ): LoroMapInterface /*throws*/ {
    return FfiConverterTypeLoroMap.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_insert_map_container(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterTypeLoroMap.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insertMovableListContainer(
    key: string,
    child: LoroMovableListInterface
  ): LoroMovableListInterface /*throws*/ {
    return FfiConverterTypeLoroMovableList.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_insert_movable_list_container(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterTypeLoroMovableList.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insertTextContainer(
    key: string,
    child: LoroTextInterface
  ): LoroTextInterface /*throws*/ {
    return FfiConverterTypeLoroText.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_insert_text_container(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterTypeLoroText.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insertTreeContainer(
    key: string,
    child: LoroTreeInterface
  ): LoroTreeInterface /*throws*/ {
    return FfiConverterTypeLoroTree.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_insert_tree_container(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            FfiConverterTypeLoroTree.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the container is attached to a document.
   */
  public isAttached(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_is_attached(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the container is deleted.
   */
  public isDeleted(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_is_deleted(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the map is empty.
   */
  public isEmpty(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_is_empty(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the keys of the map.
   */
  public keys(): Array<string> {
    return FfiConverterArrayString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_keys(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the length of the map.
   */
  public len(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_len(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Subscribe the events of a container.
   *
   * The callback will be invoked when the container is changed.
   * Returns a subscription that can be used to unsubscribe.
   *
   * The events will be emitted after a transaction is committed. A transaction is committed when:
   *
   * - `doc.commit()` is called.
   * - `doc.export(mode)` is called.
   * - `doc.import(data)` is called.
   * - `doc.checkout(version)` is called.
   */
  public subscribe(subscriber: Subscriber): SubscriptionInterface | undefined {
    return FfiConverterOptionalTypeSubscription.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_subscribe(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            FfiConverterTypeSubscriber.lower(subscriber),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the values of the map.
   */
  public values(): Array<ValueOrContainerInterface> {
    return FfiConverterArrayTypeValueOrContainer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromap_values(
            uniffiTypeLoroMapObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeLoroMapObjectFactory.pointer(this);
      uniffiTypeLoroMapObjectFactory.freePointer(pointer);
      uniffiTypeLoroMapObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is LoroMap {
    return uniffiTypeLoroMapObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeLoroMapObjectFactory: UniffiObjectFactory<LoroMapInterface> = {
  create(pointer: UnsafeMutableRawPointer): LoroMapInterface {
    const instance = Object.create(LoroMap.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'LoroMap';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_loromap_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: LoroMapInterface): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: LoroMapInterface): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_loro_ffi_fn_clone_loromap(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_loro_ffi_fn_free_loromap(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is LoroMapInterface {
    return (
      obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'LoroMap'
    );
  },
};
// FfiConverter for LoroMapInterface
const FfiConverterTypeLoroMap = new FfiConverterObject(
  uniffiTypeLoroMapObjectFactory
);

export interface LoroMovableListInterface {
  /**
   * Delete all elements in the list.
   */
  clear() /*throws*/ : void;
  /**
   * Delete values at the given position.
   */
  delete_(pos: /*u32*/ number, len: /*u32*/ number) /*throws*/ : void;
  /**
   * Get the LoroDoc from this container
   */
  doc(): LoroDocInterface | undefined;
  /**
   * Get the value at the given position.
   */
  get(index: /*u32*/ number): ValueOrContainerInterface | undefined;
  /**
   * If a detached container is attached, this method will return its corresponding attached handler.
   */
  getAttached(): LoroMovableListInterface | undefined;
  getCreatorAt(pos: /*u32*/ number): /*u64*/ bigint | undefined;
  /**
   * Get the cursor at the given position.
   *
   * Using "index" to denote cursor positions can be unstable, as positions may
   * shift with document edits. To reliably represent a position or range within
   * a document, it is more effective to leverage the unique ID of each item/character
   * in a List CRDT or Text CRDT.
   *
   * Loro optimizes State metadata by not storing the IDs of deleted elements. This
   * approach complicates tracking cursors since they rely on these IDs. The solution
   * recalculates position by replaying relevant history to update stable positions
   * accurately. To minimize the performance impact of history replay, the system
   * updates cursor info to reference only the IDs of currently present elements,
   * thereby reducing the need for replay.
   */
  getCursor(pos: /*u32*/ number, side: Side): CursorInterface | undefined;
  /**
   * Get the deep value of the container.
   */
  getDeepValue(): LoroValue;
  /**
   * Get the last editor of the list item at the given position.
   */
  getLastEditorAt(pos: /*u32*/ number): /*u64*/ bigint | undefined;
  /**
   * Get the last mover of the list item at the given position.
   */
  getLastMoverAt(pos: /*u32*/ number): /*u64*/ bigint | undefined;
  /**
   * Get the shallow value of the container.
   *
   * This does not convert the state of sub-containers; instead, it represents them as [LoroValue::Container].
   */
  getValue(): LoroValue;
  /**
   * Get the container id.
   */
  id(): ContainerId;
  /**
   * Insert a value at the given position.
   */
  insert(pos: /*u32*/ number, v: LoroValueLike) /*throws*/ : void;
  insertCounterContainer(
    pos: /*u32*/ number,
    child: LoroCounterInterface
  ) /*throws*/ : LoroCounterInterface;
  insertListContainer(
    pos: /*u32*/ number,
    child: LoroListInterface
  ) /*throws*/ : LoroListInterface;
  insertMapContainer(
    pos: /*u32*/ number,
    child: LoroMapInterface
  ) /*throws*/ : LoroMapInterface;
  insertMovableListContainer(
    pos: /*u32*/ number,
    child: LoroMovableListInterface
  ) /*throws*/ : LoroMovableListInterface;
  insertTextContainer(
    pos: /*u32*/ number,
    child: LoroTextInterface
  ) /*throws*/ : LoroTextInterface;
  insertTreeContainer(
    pos: /*u32*/ number,
    child: LoroTreeInterface
  ) /*throws*/ : LoroTreeInterface;
  /**
   * Whether the container is attached to a document
   *
   * The edits on a detached container will not be persisted.
   * To attach the container to the document, please insert it into an attached container.
   */
  isAttached(): boolean;
  /**
   * Whether the container is deleted.
   */
  isDeleted(): boolean;
  isEmpty(): boolean;
  len(): /*u32*/ number;
  /**
   * Move the value at the given position to the given position.
   */
  mov(from: /*u32*/ number, to: /*u32*/ number) /*throws*/ : void;
  /**
   * Pop the last element of the list.
   */
  pop() /*throws*/ : ValueOrContainerInterface | undefined;
  push(v: LoroValueLike) /*throws*/ : void;
  /**
   * Set the value at the given position.
   */
  set(pos: /*u32*/ number, value: LoroValueLike) /*throws*/ : void;
  setCounterContainer(
    pos: /*u32*/ number,
    child: LoroCounterInterface
  ) /*throws*/ : LoroCounterInterface;
  setListContainer(
    pos: /*u32*/ number,
    child: LoroListInterface
  ) /*throws*/ : LoroListInterface;
  setMapContainer(
    pos: /*u32*/ number,
    child: LoroMapInterface
  ) /*throws*/ : LoroMapInterface;
  setMovableListContainer(
    pos: /*u32*/ number,
    child: LoroMovableListInterface
  ) /*throws*/ : LoroMovableListInterface;
  setTextContainer(
    pos: /*u32*/ number,
    child: LoroTextInterface
  ) /*throws*/ : LoroTextInterface;
  setTreeContainer(
    pos: /*u32*/ number,
    child: LoroTreeInterface
  ) /*throws*/ : LoroTreeInterface;
  /**
   * Subscribe the events of a container.
   *
   * The callback will be invoked when the container is changed.
   * Returns a subscription that can be used to unsubscribe.
   *
   * The events will be emitted after a transaction is committed. A transaction is committed when:
   *
   * - `doc.commit()` is called.
   * - `doc.export(mode)` is called.
   * - `doc.import(data)` is called.
   * - `doc.checkout(version)` is called.
   */
  subscribe(subscriber: Subscriber): SubscriptionInterface | undefined;
  /**
   * Get the elements of the list as a vector of LoroValues.
   *
   * This method returns a vector containing all the elements in the list as LoroValues.
   * It provides a convenient way to access the entire contents of the LoroMovableList
   * as a standard Rust vector.
   */
  toVec(): Array<LoroValue>;
}

export class LoroMovableList
  extends UniffiAbstractObject
  implements LoroMovableListInterface
{
  readonly [uniffiTypeNameSymbol] = 'LoroMovableList';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Create a new container that is detached from the document.
   *
   * The edits on a detached container will not be persisted.
   * To attach the container to the document, please insert it into an attached container.
   */
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_loromovablelist_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeLoroMovableListObjectFactory.bless(pointer);
  }

  /**
   * Delete all elements in the list.
   */
  public clear(): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_clear(
          uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Delete values at the given position.
   */
  public delete_(pos: /*u32*/ number, len: /*u32*/ number): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_delete(
          uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
          FfiConverterUInt32.lower(pos),
          FfiConverterUInt32.lower(len),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Get the LoroDoc from this container
   */
  public doc(): LoroDocInterface | undefined {
    return FfiConverterOptionalTypeLoroDoc.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_doc(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the value at the given position.
   */
  public get(index: /*u32*/ number): ValueOrContainerInterface | undefined {
    return FfiConverterOptionalTypeValueOrContainer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_get(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(index),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * If a detached container is attached, this method will return its corresponding attached handler.
   */
  public getAttached(): LoroMovableListInterface | undefined {
    return FfiConverterOptionalTypeLoroMovableList.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_get_attached(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getCreatorAt(pos: /*u32*/ number): /*u64*/ bigint | undefined {
    return FfiConverterOptionalUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_get_creator_at(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the cursor at the given position.
   *
   * Using "index" to denote cursor positions can be unstable, as positions may
   * shift with document edits. To reliably represent a position or range within
   * a document, it is more effective to leverage the unique ID of each item/character
   * in a List CRDT or Text CRDT.
   *
   * Loro optimizes State metadata by not storing the IDs of deleted elements. This
   * approach complicates tracking cursors since they rely on these IDs. The solution
   * recalculates position by replaying relevant history to update stable positions
   * accurately. To minimize the performance impact of history replay, the system
   * updates cursor info to reference only the IDs of currently present elements,
   * thereby reducing the need for replay.
   */
  public getCursor(
    pos: /*u32*/ number,
    side: Side
  ): CursorInterface | undefined {
    return FfiConverterOptionalTypeCursor.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_get_cursor(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeSide.lower(side),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the deep value of the container.
   */
  public getDeepValue(): LoroValue {
    return FfiConverterTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_get_deep_value(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the last editor of the list item at the given position.
   */
  public getLastEditorAt(pos: /*u32*/ number): /*u64*/ bigint | undefined {
    return FfiConverterOptionalUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_get_last_editor_at(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the last mover of the list item at the given position.
   */
  public getLastMoverAt(pos: /*u32*/ number): /*u64*/ bigint | undefined {
    return FfiConverterOptionalUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_get_last_mover_at(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the shallow value of the container.
   *
   * This does not convert the state of sub-containers; instead, it represents them as [LoroValue::Container].
   */
  public getValue(): LoroValue {
    return FfiConverterTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_get_value(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the container id.
   */
  public id(): ContainerId {
    return FfiConverterTypeContainerID.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_id(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Insert a value at the given position.
   */
  public insert(pos: /*u32*/ number, v: LoroValueLike): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_insert(
          uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
          FfiConverterUInt32.lower(pos),
          FfiConverterTypeLoroValueLike.lower(v),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public insertCounterContainer(
    pos: /*u32*/ number,
    child: LoroCounterInterface
  ): LoroCounterInterface /*throws*/ {
    return FfiConverterTypeLoroCounter.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_insert_counter_container(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroCounter.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insertListContainer(
    pos: /*u32*/ number,
    child: LoroListInterface
  ): LoroListInterface /*throws*/ {
    return FfiConverterTypeLoroList.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_insert_list_container(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroList.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insertMapContainer(
    pos: /*u32*/ number,
    child: LoroMapInterface
  ): LoroMapInterface /*throws*/ {
    return FfiConverterTypeLoroMap.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_insert_map_container(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroMap.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insertMovableListContainer(
    pos: /*u32*/ number,
    child: LoroMovableListInterface
  ): LoroMovableListInterface /*throws*/ {
    return FfiConverterTypeLoroMovableList.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_insert_movable_list_container(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroMovableList.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insertTextContainer(
    pos: /*u32*/ number,
    child: LoroTextInterface
  ): LoroTextInterface /*throws*/ {
    return FfiConverterTypeLoroText.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_insert_text_container(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroText.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insertTreeContainer(
    pos: /*u32*/ number,
    child: LoroTreeInterface
  ): LoroTreeInterface /*throws*/ {
    return FfiConverterTypeLoroTree.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_insert_tree_container(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroTree.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the container is attached to a document
   *
   * The edits on a detached container will not be persisted.
   * To attach the container to the document, please insert it into an attached container.
   */
  public isAttached(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_is_attached(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the container is deleted.
   */
  public isDeleted(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_is_deleted(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isEmpty(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_is_empty(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public len(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_len(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Move the value at the given position to the given position.
   */
  public mov(from: /*u32*/ number, to: /*u32*/ number): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_mov(
          uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
          FfiConverterUInt32.lower(from),
          FfiConverterUInt32.lower(to),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Pop the last element of the list.
   */
  public pop(): ValueOrContainerInterface | undefined /*throws*/ {
    return FfiConverterOptionalTypeValueOrContainer.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_pop(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public push(v: LoroValueLike): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_push(
          uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
          FfiConverterTypeLoroValueLike.lower(v),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Set the value at the given position.
   */
  public set(pos: /*u32*/ number, value: LoroValueLike): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_set(
          uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
          FfiConverterUInt32.lower(pos),
          FfiConverterTypeLoroValueLike.lower(value),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public setCounterContainer(
    pos: /*u32*/ number,
    child: LoroCounterInterface
  ): LoroCounterInterface /*throws*/ {
    return FfiConverterTypeLoroCounter.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_set_counter_container(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroCounter.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setListContainer(
    pos: /*u32*/ number,
    child: LoroListInterface
  ): LoroListInterface /*throws*/ {
    return FfiConverterTypeLoroList.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_set_list_container(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroList.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setMapContainer(
    pos: /*u32*/ number,
    child: LoroMapInterface
  ): LoroMapInterface /*throws*/ {
    return FfiConverterTypeLoroMap.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_set_map_container(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroMap.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setMovableListContainer(
    pos: /*u32*/ number,
    child: LoroMovableListInterface
  ): LoroMovableListInterface /*throws*/ {
    return FfiConverterTypeLoroMovableList.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_set_movable_list_container(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroMovableList.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setTextContainer(
    pos: /*u32*/ number,
    child: LoroTextInterface
  ): LoroTextInterface /*throws*/ {
    return FfiConverterTypeLoroText.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_set_text_container(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroText.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setTreeContainer(
    pos: /*u32*/ number,
    child: LoroTreeInterface
  ): LoroTreeInterface /*throws*/ {
    return FfiConverterTypeLoroTree.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_set_tree_container(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeLoroTree.lower(child),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Subscribe the events of a container.
   *
   * The callback will be invoked when the container is changed.
   * Returns a subscription that can be used to unsubscribe.
   *
   * The events will be emitted after a transaction is committed. A transaction is committed when:
   *
   * - `doc.commit()` is called.
   * - `doc.export(mode)` is called.
   * - `doc.import(data)` is called.
   * - `doc.checkout(version)` is called.
   */
  public subscribe(subscriber: Subscriber): SubscriptionInterface | undefined {
    return FfiConverterOptionalTypeSubscription.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_subscribe(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            FfiConverterTypeSubscriber.lower(subscriber),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the elements of the list as a vector of LoroValues.
   *
   * This method returns a vector containing all the elements in the list as LoroValues.
   * It provides a convenient way to access the entire contents of the LoroMovableList
   * as a standard Rust vector.
   */
  public toVec(): Array<LoroValue> {
    return FfiConverterArrayTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_loromovablelist_to_vec(
            uniffiTypeLoroMovableListObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeLoroMovableListObjectFactory.pointer(this);
      uniffiTypeLoroMovableListObjectFactory.freePointer(pointer);
      uniffiTypeLoroMovableListObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is LoroMovableList {
    return uniffiTypeLoroMovableListObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeLoroMovableListObjectFactory: UniffiObjectFactory<LoroMovableListInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): LoroMovableListInterface {
      const instance = Object.create(LoroMovableList.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'LoroMovableList';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_loromovablelist_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: LoroMovableListInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: LoroMovableListInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_loromovablelist(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_loromovablelist(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is LoroMovableListInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'LoroMovableList'
      );
    },
  };
// FfiConverter for LoroMovableListInterface
const FfiConverterTypeLoroMovableList = new FfiConverterObject(
  uniffiTypeLoroMovableListObjectFactory
);

export interface LoroTextInterface {
  /**
   * Apply a [delta](https://quilljs.com/docs/delta/) to the text container.
   */
  applyDelta(delta: Array<TextDelta>) /*throws*/ : void;
  /**
   * Get the characters at given unicode position.
   */
  charAt(pos: /*u32*/ number) /*throws*/ : string;
  /**
   * Delete a range of text at the given unicode position with unicode length.
   */
  delete_(pos: /*u32*/ number, len: /*u32*/ number) /*throws*/ : void;
  /**
   * Delete a range of text at the given utf-8 position with utf-8 length.
   */
  deleteUtf8(pos: /*u32*/ number, len: /*u32*/ number) /*throws*/ : void;
  /**
   * Get the LoroDoc from this container
   */
  doc(): LoroDocInterface | undefined;
  /**
   * If a detached container is attached, this method will return its corresponding attached handler.
   */
  getAttached(): LoroTextInterface | undefined;
  /**
   * Get the cursor at the given position in the given Unicode position..
   *
   * Using "index" to denote cursor positions can be unstable, as positions may
   * shift with document edits. To reliably represent a position or range within
   * a document, it is more effective to leverage the unique ID of each item/character
   * in a List CRDT or Text CRDT.
   *
   * Loro optimizes State metadata by not storing the IDs of deleted elements. This
   * approach complicates tracking cursors since they rely on these IDs. The solution
   * recalculates position by replaying relevant history to update stable positions
   * accurately. To minimize the performance impact of history replay, the system
   * updates cursor info to reference only the IDs of currently present elements,
   * thereby reducing the need for replay.
   */
  getCursor(pos: /*u32*/ number, side: Side): CursorInterface | undefined;
  /**
   * Get the editor of the text at the given position.
   */
  getEditorAtUnicodePos(pos: /*u32*/ number): /*u64*/ bigint | undefined;
  /**
   * Get the text in [Delta](https://quilljs.com/docs/delta/) format.
   */
  getRichtextValue(): LoroValue;
  /**
   * Get the [ContainerID]  of the text container.
   */
  id(): ContainerId;
  /**
   * Insert a string at the given unicode position.
   */
  insert(pos: /*u32*/ number, s: string) /*throws*/ : void;
  /**
   * Insert a string at the given utf-8 position.
   */
  insertUtf8(pos: /*u32*/ number, s: string) /*throws*/ : void;
  /**
   * Whether the container is attached to a document
   *
   * The edits on a detached container will not be persisted.
   * To attach the container to the document, please insert it into an attached container.
   */
  isAttached(): boolean;
  /**
   * Whether the container is deleted.
   */
  isDeleted(): boolean;
  /**
   * Whether the text container is empty.
   */
  isEmpty(): boolean;
  /**
   * Get the length of the text container in Unicode.
   */
  lenUnicode(): /*u32*/ number;
  /**
   * Get the length of the text container in UTF-16.
   */
  lenUtf16(): /*u32*/ number;
  /**
   * Get the length of the text container in UTF-8.
   */
  lenUtf8(): /*u32*/ number;
  /**
   * Mark a range of text with a key-value pair.
   *
   * You can use it to create a highlight, make a range of text bold, or add a link to a range of text.
   *
   * You can specify the `expand` option to set the behavior when inserting text at the boundary of the range.
   *
   * - `after`(default): when inserting text right after the given range, the mark will be expanded to include the inserted text
   * - `before`: when inserting text right before the given range, the mark will be expanded to include the inserted text
   * - `none`: the mark will not be expanded to include the inserted text at the boundaries
   * - `both`: when inserting text either right before or right after the given range, the mark will be expanded to include the inserted text
   *
   * *You should make sure that a key is always associated with the same expand type.*
   *
   * Note: this is not suitable for unmergeable annotations like comments.
   */
  mark(
    from: /*u32*/ number,
    to: /*u32*/ number,
    key: string,
    value: LoroValueLike
  ) /*throws*/ : void;
  /**
   * Push a string to the end of the text container.
   */
  pushStr(s: string) /*throws*/ : void;
  /**
   * Get a string slice at the given Unicode range
   */
  slice(
    startIndex: /*u32*/ number,
    endIndex: /*u32*/ number
  ) /*throws*/ : string;
  /**
   * Delete specified character and insert string at the same position at given unicode position.
   */
  splice(
    pos: /*u32*/ number,
    len: /*u32*/ number,
    s: string
  ) /*throws*/ : string;
  /**
   * Subscribe the events of a container.
   *
   * The callback will be invoked when the container is changed.
   * Returns a subscription that can be used to unsubscribe.
   *
   * The events will be emitted after a transaction is committed. A transaction is committed when:
   *
   * - `doc.commit()` is called.
   * - `doc.export(mode)` is called.
   * - `doc.import(data)` is called.
   * - `doc.checkout(version)` is called.
   */
  subscribe(subscriber: Subscriber): SubscriptionInterface | undefined;
  /**
   * Get the text in [Delta](https://quilljs.com/docs/delta/) format.
   */
  toDelta(): Array<TextDelta>;
  /**
   * Get the text content of the text container.
   */
  toString(): string;
  /**
   * Unmark a range of text with a key and a value.
   *
   * You can use it to remove highlights, bolds or links
   *
   * You can specify the `expand` option to set the behavior when inserting text at the boundary of the range.
   *
   * **Note: You should specify the same expand type as when you mark the text.**
   *
   * - `after`(default): when inserting text right after the given range, the mark will be expanded to include the inserted text
   * - `before`: when inserting text right before the given range, the mark will be expanded to include the inserted text
   * - `none`: the mark will not be expanded to include the inserted text at the boundaries
   * - `both`: when inserting text either right before or right after the given range, the mark will be expanded to include the inserted text
   *
   * *You should make sure that a key is always associated with the same expand type.*
   *
   * Note: you cannot delete unmergeable annotations like comments by this method.
   */
  unmark(
    from: /*u32*/ number,
    to: /*u32*/ number,
    key: string
  ) /*throws*/ : void;
  /**
   * Update the current text based on the provided text.
   *
   * It will calculate the minimal difference and apply it to the current text.
   * It uses Myers' diff algorithm to compute the optimal difference.
   *
   * This could take a long time for large texts (e.g. > 50_000 characters).
   * In that case, you should use `updateByLine` instead.
   */
  update(s: string, options: UpdateOptions) /*throws*/ : void;
  /**
   * Update the current text based on the provided text.
   *
   * This update calculation is line-based, which will be more efficient but less precise.
   */
  updateByLine(s: string, options: UpdateOptions) /*throws*/ : void;
}

export class LoroText
  extends UniffiAbstractObject
  implements LoroTextInterface
{
  readonly [uniffiTypeNameSymbol] = 'LoroText';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Create a new container that is detached from the document.
   *
   * The edits on a detached container will not be persisted.
   * To attach the container to the document, please insert it into an attached container.
   */
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_lorotext_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeLoroTextObjectFactory.bless(pointer);
  }

  /**
   * Apply a [delta](https://quilljs.com/docs/delta/) to the text container.
   */
  public applyDelta(delta: Array<TextDelta>): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_apply_delta(
          uniffiTypeLoroTextObjectFactory.clonePointer(this),
          FfiConverterArrayTypeTextDelta.lower(delta),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Get the characters at given unicode position.
   */
  public charAt(pos: /*u32*/ number): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_char_at(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Delete a range of text at the given unicode position with unicode length.
   */
  public delete_(pos: /*u32*/ number, len: /*u32*/ number): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_delete(
          uniffiTypeLoroTextObjectFactory.clonePointer(this),
          FfiConverterUInt32.lower(pos),
          FfiConverterUInt32.lower(len),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Delete a range of text at the given utf-8 position with utf-8 length.
   */
  public deleteUtf8(pos: /*u32*/ number, len: /*u32*/ number): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_delete_utf8(
          uniffiTypeLoroTextObjectFactory.clonePointer(this),
          FfiConverterUInt32.lower(pos),
          FfiConverterUInt32.lower(len),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Get the LoroDoc from this container
   */
  public doc(): LoroDocInterface | undefined {
    return FfiConverterOptionalTypeLoroDoc.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_doc(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * If a detached container is attached, this method will return its corresponding attached handler.
   */
  public getAttached(): LoroTextInterface | undefined {
    return FfiConverterOptionalTypeLoroText.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_get_attached(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the cursor at the given position in the given Unicode position..
   *
   * Using "index" to denote cursor positions can be unstable, as positions may
   * shift with document edits. To reliably represent a position or range within
   * a document, it is more effective to leverage the unique ID of each item/character
   * in a List CRDT or Text CRDT.
   *
   * Loro optimizes State metadata by not storing the IDs of deleted elements. This
   * approach complicates tracking cursors since they rely on these IDs. The solution
   * recalculates position by replaying relevant history to update stable positions
   * accurately. To minimize the performance impact of history replay, the system
   * updates cursor info to reference only the IDs of currently present elements,
   * thereby reducing the need for replay.
   */
  public getCursor(
    pos: /*u32*/ number,
    side: Side
  ): CursorInterface | undefined {
    return FfiConverterOptionalTypeCursor.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_get_cursor(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterTypeSide.lower(side),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the editor of the text at the given position.
   */
  public getEditorAtUnicodePos(
    pos: /*u32*/ number
  ): /*u64*/ bigint | undefined {
    return FfiConverterOptionalUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_get_editor_at_unicode_pos(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the text in [Delta](https://quilljs.com/docs/delta/) format.
   */
  public getRichtextValue(): LoroValue {
    return FfiConverterTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_get_richtext_value(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the [ContainerID]  of the text container.
   */
  public id(): ContainerId {
    return FfiConverterTypeContainerID.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_id(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Insert a string at the given unicode position.
   */
  public insert(pos: /*u32*/ number, s: string): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_insert(
          uniffiTypeLoroTextObjectFactory.clonePointer(this),
          FfiConverterUInt32.lower(pos),
          FfiConverterString.lower(s),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Insert a string at the given utf-8 position.
   */
  public insertUtf8(pos: /*u32*/ number, s: string): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_insert_utf8(
          uniffiTypeLoroTextObjectFactory.clonePointer(this),
          FfiConverterUInt32.lower(pos),
          FfiConverterString.lower(s),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Whether the container is attached to a document
   *
   * The edits on a detached container will not be persisted.
   * To attach the container to the document, please insert it into an attached container.
   */
  public isAttached(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_is_attached(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the container is deleted.
   */
  public isDeleted(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_is_deleted(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the text container is empty.
   */
  public isEmpty(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_is_empty(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the length of the text container in Unicode.
   */
  public lenUnicode(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_len_unicode(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the length of the text container in UTF-16.
   */
  public lenUtf16(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_len_utf16(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the length of the text container in UTF-8.
   */
  public lenUtf8(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_len_utf8(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Mark a range of text with a key-value pair.
   *
   * You can use it to create a highlight, make a range of text bold, or add a link to a range of text.
   *
   * You can specify the `expand` option to set the behavior when inserting text at the boundary of the range.
   *
   * - `after`(default): when inserting text right after the given range, the mark will be expanded to include the inserted text
   * - `before`: when inserting text right before the given range, the mark will be expanded to include the inserted text
   * - `none`: the mark will not be expanded to include the inserted text at the boundaries
   * - `both`: when inserting text either right before or right after the given range, the mark will be expanded to include the inserted text
   *
   * *You should make sure that a key is always associated with the same expand type.*
   *
   * Note: this is not suitable for unmergeable annotations like comments.
   */
  public mark(
    from: /*u32*/ number,
    to: /*u32*/ number,
    key: string,
    value: LoroValueLike
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_mark(
          uniffiTypeLoroTextObjectFactory.clonePointer(this),
          FfiConverterUInt32.lower(from),
          FfiConverterUInt32.lower(to),
          FfiConverterString.lower(key),
          FfiConverterTypeLoroValueLike.lower(value),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Push a string to the end of the text container.
   */
  public pushStr(s: string): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_push_str(
          uniffiTypeLoroTextObjectFactory.clonePointer(this),
          FfiConverterString.lower(s),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Get a string slice at the given Unicode range
   */
  public slice(
    startIndex: /*u32*/ number,
    endIndex: /*u32*/ number
  ): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_slice(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(startIndex),
            FfiConverterUInt32.lower(endIndex),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Delete specified character and insert string at the same position at given unicode position.
   */
  public splice(
    pos: /*u32*/ number,
    len: /*u32*/ number,
    s: string
  ): string /*throws*/ {
    return FfiConverterString.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_splice(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            FfiConverterUInt32.lower(pos),
            FfiConverterUInt32.lower(len),
            FfiConverterString.lower(s),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Subscribe the events of a container.
   *
   * The callback will be invoked when the container is changed.
   * Returns a subscription that can be used to unsubscribe.
   *
   * The events will be emitted after a transaction is committed. A transaction is committed when:
   *
   * - `doc.commit()` is called.
   * - `doc.export(mode)` is called.
   * - `doc.import(data)` is called.
   * - `doc.checkout(version)` is called.
   */
  public subscribe(subscriber: Subscriber): SubscriptionInterface | undefined {
    return FfiConverterOptionalTypeSubscription.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_subscribe(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            FfiConverterTypeSubscriber.lower(subscriber),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the text in [Delta](https://quilljs.com/docs/delta/) format.
   */
  public toDelta(): Array<TextDelta> {
    return FfiConverterArrayTypeTextDelta.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_to_delta(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the text content of the text container.
   */
  public toString(): string {
    return FfiConverterString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_to_string(
            uniffiTypeLoroTextObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Unmark a range of text with a key and a value.
   *
   * You can use it to remove highlights, bolds or links
   *
   * You can specify the `expand` option to set the behavior when inserting text at the boundary of the range.
   *
   * **Note: You should specify the same expand type as when you mark the text.**
   *
   * - `after`(default): when inserting text right after the given range, the mark will be expanded to include the inserted text
   * - `before`: when inserting text right before the given range, the mark will be expanded to include the inserted text
   * - `none`: the mark will not be expanded to include the inserted text at the boundaries
   * - `both`: when inserting text either right before or right after the given range, the mark will be expanded to include the inserted text
   *
   * *You should make sure that a key is always associated with the same expand type.*
   *
   * Note: you cannot delete unmergeable annotations like comments by this method.
   */
  public unmark(
    from: /*u32*/ number,
    to: /*u32*/ number,
    key: string
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_unmark(
          uniffiTypeLoroTextObjectFactory.clonePointer(this),
          FfiConverterUInt32.lower(from),
          FfiConverterUInt32.lower(to),
          FfiConverterString.lower(key),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Update the current text based on the provided text.
   *
   * It will calculate the minimal difference and apply it to the current text.
   * It uses Myers' diff algorithm to compute the optimal difference.
   *
   * This could take a long time for large texts (e.g. > 50_000 characters).
   * In that case, you should use `updateByLine` instead.
   */
  public update(s: string, options: UpdateOptions): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeUpdateTimeoutError.lift.bind(
        FfiConverterTypeUpdateTimeoutError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_update(
          uniffiTypeLoroTextObjectFactory.clonePointer(this),
          FfiConverterString.lower(s),
          FfiConverterTypeUpdateOptions.lower(options),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Update the current text based on the provided text.
   *
   * This update calculation is line-based, which will be more efficient but less precise.
   */
  public updateByLine(s: string, options: UpdateOptions): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeUpdateTimeoutError.lift.bind(
        FfiConverterTypeUpdateTimeoutError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotext_update_by_line(
          uniffiTypeLoroTextObjectFactory.clonePointer(this),
          FfiConverterString.lower(s),
          FfiConverterTypeUpdateOptions.lower(options),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeLoroTextObjectFactory.pointer(this);
      uniffiTypeLoroTextObjectFactory.freePointer(pointer);
      uniffiTypeLoroTextObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is LoroText {
    return uniffiTypeLoroTextObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeLoroTextObjectFactory: UniffiObjectFactory<LoroTextInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): LoroTextInterface {
      const instance = Object.create(LoroText.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'LoroText';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_lorotext_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: LoroTextInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: LoroTextInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_lorotext(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_lorotext(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is LoroTextInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'LoroText'
      );
    },
  };
// FfiConverter for LoroTextInterface
const FfiConverterTypeLoroText = new FfiConverterObject(
  uniffiTypeLoroTextObjectFactory
);

export interface LoroTreeInterface {
  /**
   * Return all children of the target node.
   *
   * If the parent node does not exist, return `None`.
   */
  children(parent: TreeParentId): Array<TreeId> | undefined;
  /**
   * Return the number of children of the target node.
   */
  childrenNum(parent: TreeParentId): /*u32*/ number | undefined;
  /**
   * Return whether target node exists.
   */
  contains(target: TreeId): boolean;
  /**
   * Create a new tree node and return the [`TreeID`].
   *
   * If the `parent` is `None`, the created node is the root of a tree.
   * Otherwise, the created node is a child of the parent tree node.
   */
  create(parent: TreeParentId) /*throws*/ : TreeId;
  /**
   * Create a new tree node at the given index and return the [`TreeID`].
   *
   * If the `parent` is `None`, the created node is the root of a tree.
   * If the `index` is greater than the number of children of the parent, error will be returned.
   */
  createAt(parent: TreeParentId, index: /*u32*/ number) /*throws*/ : TreeId;
  /**
   * Delete a tree node.
   *
   * Note: If the deleted node has children, the children do not appear in the state
   * rather than actually being deleted.
   */
  delete_(target: TreeId) /*throws*/ : void;
  /**
   * Disable the fractional index generation when you don't need the Tree's siblings to be sorted.
   * The fractional index will always be set to the same default value 0.
   *
   * After calling this, you cannot use `tree.moveTo()`, `tree.moveBefore()`, `tree.moveAfter()`,
   * and `tree.createAt()`.
   */
  disableFractionalIndex(): void;
  /**
   * Get the LoroDoc from this container
   */
  doc(): LoroDocInterface | undefined;
  /**
   * Enable fractional index for Tree Position.
   *
   * The jitter is used to avoid conflicts when multiple users are creating the node at the same position.
   * value 0 is default, which means no jitter, any value larger than 0 will enable jitter.
   *
   * Generally speaking, jitter will affect the growth rate of document size.
   * [Read more about it](https://www.loro.dev/blog/movable-tree#implementation-and-encoding-size)
   */
  enableFractionalIndex(jitter: /*u8*/ number): void;
  /**
   * Return the fractional index of the target node with hex format.
   */
  fractionalIndex(target: TreeId): string | undefined;
  /**
   * If a detached container is attached, this method will return its corresponding attached handler.
   */
  getAttached(): LoroTreeInterface | undefined;
  /**
   * Get the last move id of the target node.
   */
  getLastMoveId(target: TreeId): Id | undefined;
  /**
   * Get the associated metadata map handler of a tree node.
   */
  getMeta(target: TreeId) /*throws*/ : LoroMapInterface;
  /**
   * Return the flat array of the forest.
   *
   * Note: the metadata will be not resolved. So if you don't only care about hierarchy
   * but also the metadata, you should use `get_value_with_meta()`.
   */
  getValue(): LoroValue;
  /**
   * Return the flat array of the forest, each node is with metadata.
   */
  getValueWithMeta(): LoroValue;
  /**
   * Return container id of the tree.
   */
  id(): ContainerId;
  /**
   * Whether the container is attached to a document
   *
   * The edits on a detached container will not be persisted.
   * To attach the container to the document, please insert it into an attached container.
   */
  isAttached(): boolean;
  /**
   * Whether the container is deleted.
   */
  isDeleted(): boolean;
  /**
   * Whether the fractional index is enabled.
   */
  isFractionalIndexEnabled(): boolean;
  /**
   * Return whether target node is deleted.
   *
   * # Errors
   * - If the target node does not exist, return `LoroTreeError::TreeNodeNotExist`.
   */
  isNodeDeleted(target: TreeId) /*throws*/ : boolean;
  /**
   * Move the `target` node to be a child of the `parent` node.
   *
   * If the `parent` is `None`, the `target` node will be a root.
   */
  mov(target: TreeId, parent: TreeParentId) /*throws*/ : void;
  /**
   * Move the `target` node to be a child after the `after` node with the same parent.
   */
  movAfter(target: TreeId, after: TreeId) /*throws*/ : void;
  /**
   * Move the `target` node to be a child before the `before` node with the same parent.
   */
  movBefore(target: TreeId, before: TreeId) /*throws*/ : void;
  /**
   * Move the `target` node to be a child of the `parent` node at the given index.
   * If the `parent` is `None`, the `target` node will be a root.
   */
  movTo(
    target: TreeId,
    parent: TreeParentId,
    to: /*u32*/ number
  ) /*throws*/ : void;
  /**
   * Return all nodes, including deleted nodes
   */
  nodes(): Array<TreeId>;
  /**
   * Return the parent of target node.
   *
   * - If the target node does not exist, throws Error.
   * - If the target node is a root node, return nil.
   */
  parent(target: TreeId) /*throws*/ : TreeParentId;
  /**
   * Get the root nodes of the forest.
   */
  roots(): Array<TreeId>;
  /**
   * Subscribe the events of a container.
   *
   * The callback will be invoked when the container is changed.
   * Returns a subscription that can be used to unsubscribe.
   *
   * The events will be emitted after a transaction is committed. A transaction is committed when:
   *
   * - `doc.commit()` is called.
   * - `doc.export(mode)` is called.
   * - `doc.import(data)` is called.
   * - `doc.checkout(version)` is called.
   */
  subscribe(subscriber: Subscriber): SubscriptionInterface | undefined;
}

export class LoroTree
  extends UniffiAbstractObject
  implements LoroTreeInterface
{
  readonly [uniffiTypeNameSymbol] = 'LoroTree';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Create a new container that is detached from the document.
   *
   * The edits on a detached container will not be persisted.
   * To attach the container to the document, please insert it into an attached container.
   */
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_lorotree_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeLoroTreeObjectFactory.bless(pointer);
  }

  /**
   * Return all children of the target node.
   *
   * If the parent node does not exist, return `None`.
   */
  public children(parent: TreeParentId): Array<TreeId> | undefined {
    return FfiConverterOptionalArrayTypeTreeID.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_children(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            FfiConverterTypeTreeParentId.lower(parent),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Return the number of children of the target node.
   */
  public childrenNum(parent: TreeParentId): /*u32*/ number | undefined {
    return FfiConverterOptionalUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_children_num(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            FfiConverterTypeTreeParentId.lower(parent),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Return whether target node exists.
   */
  public contains(target: TreeId): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_contains(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            FfiConverterTypeTreeID.lower(target),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Create a new tree node and return the [`TreeID`].
   *
   * If the `parent` is `None`, the created node is the root of a tree.
   * Otherwise, the created node is a child of the parent tree node.
   */
  public create(parent: TreeParentId): TreeId /*throws*/ {
    return FfiConverterTypeTreeID.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_create(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            FfiConverterTypeTreeParentId.lower(parent),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Create a new tree node at the given index and return the [`TreeID`].
   *
   * If the `parent` is `None`, the created node is the root of a tree.
   * If the `index` is greater than the number of children of the parent, error will be returned.
   */
  public createAt(
    parent: TreeParentId,
    index: /*u32*/ number
  ): TreeId /*throws*/ {
    return FfiConverterTypeTreeID.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_create_at(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            FfiConverterTypeTreeParentId.lower(parent),
            FfiConverterUInt32.lower(index),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Delete a tree node.
   *
   * Note: If the deleted node has children, the children do not appear in the state
   * rather than actually being deleted.
   */
  public delete_(target: TreeId): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_delete(
          uniffiTypeLoroTreeObjectFactory.clonePointer(this),
          FfiConverterTypeTreeID.lower(target),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Disable the fractional index generation when you don't need the Tree's siblings to be sorted.
   * The fractional index will always be set to the same default value 0.
   *
   * After calling this, you cannot use `tree.moveTo()`, `tree.moveBefore()`, `tree.moveAfter()`,
   * and `tree.createAt()`.
   */
  public disableFractionalIndex(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_disable_fractional_index(
          uniffiTypeLoroTreeObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Get the LoroDoc from this container
   */
  public doc(): LoroDocInterface | undefined {
    return FfiConverterOptionalTypeLoroDoc.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_doc(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Enable fractional index for Tree Position.
   *
   * The jitter is used to avoid conflicts when multiple users are creating the node at the same position.
   * value 0 is default, which means no jitter, any value larger than 0 will enable jitter.
   *
   * Generally speaking, jitter will affect the growth rate of document size.
   * [Read more about it](https://www.loro.dev/blog/movable-tree#implementation-and-encoding-size)
   */
  public enableFractionalIndex(jitter: /*u8*/ number): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_enable_fractional_index(
          uniffiTypeLoroTreeObjectFactory.clonePointer(this),
          FfiConverterUInt8.lower(jitter),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Return the fractional index of the target node with hex format.
   */
  public fractionalIndex(target: TreeId): string | undefined {
    return FfiConverterOptionalString.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_fractional_index(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            FfiConverterTypeTreeID.lower(target),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * If a detached container is attached, this method will return its corresponding attached handler.
   */
  public getAttached(): LoroTreeInterface | undefined {
    return FfiConverterOptionalTypeLoroTree.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_get_attached(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the last move id of the target node.
   */
  public getLastMoveId(target: TreeId): Id | undefined {
    return FfiConverterOptionalTypeID.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_get_last_move_id(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            FfiConverterTypeTreeID.lower(target),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the associated metadata map handler of a tree node.
   */
  public getMeta(target: TreeId): LoroMapInterface /*throws*/ {
    return FfiConverterTypeLoroMap.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_get_meta(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            FfiConverterTypeTreeID.lower(target),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Return the flat array of the forest.
   *
   * Note: the metadata will be not resolved. So if you don't only care about hierarchy
   * but also the metadata, you should use `get_value_with_meta()`.
   */
  public getValue(): LoroValue {
    return FfiConverterTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_get_value(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Return the flat array of the forest, each node is with metadata.
   */
  public getValueWithMeta(): LoroValue {
    return FfiConverterTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_get_value_with_meta(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Return container id of the tree.
   */
  public id(): ContainerId {
    return FfiConverterTypeContainerID.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_id(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the container is attached to a document
   *
   * The edits on a detached container will not be persisted.
   * To attach the container to the document, please insert it into an attached container.
   */
  public isAttached(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_is_attached(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the container is deleted.
   */
  public isDeleted(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_is_deleted(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the fractional index is enabled.
   */
  public isFractionalIndexEnabled(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_is_fractional_index_enabled(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Return whether target node is deleted.
   *
   * # Errors
   * - If the target node does not exist, return `LoroTreeError::TreeNodeNotExist`.
   */
  public isNodeDeleted(target: TreeId): boolean /*throws*/ {
    return FfiConverterBool.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_is_node_deleted(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            FfiConverterTypeTreeID.lower(target),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Move the `target` node to be a child of the `parent` node.
   *
   * If the `parent` is `None`, the `target` node will be a root.
   */
  public mov(target: TreeId, parent: TreeParentId): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_mov(
          uniffiTypeLoroTreeObjectFactory.clonePointer(this),
          FfiConverterTypeTreeID.lower(target),
          FfiConverterTypeTreeParentId.lower(parent),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Move the `target` node to be a child after the `after` node with the same parent.
   */
  public movAfter(target: TreeId, after: TreeId): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_mov_after(
          uniffiTypeLoroTreeObjectFactory.clonePointer(this),
          FfiConverterTypeTreeID.lower(target),
          FfiConverterTypeTreeID.lower(after),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Move the `target` node to be a child before the `before` node with the same parent.
   */
  public movBefore(target: TreeId, before: TreeId): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_mov_before(
          uniffiTypeLoroTreeObjectFactory.clonePointer(this),
          FfiConverterTypeTreeID.lower(target),
          FfiConverterTypeTreeID.lower(before),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Move the `target` node to be a child of the `parent` node at the given index.
   * If the `parent` is `None`, the `target` node will be a root.
   */
  public movTo(
    target: TreeId,
    parent: TreeParentId,
    to: /*u32*/ number
  ): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_mov_to(
          uniffiTypeLoroTreeObjectFactory.clonePointer(this),
          FfiConverterTypeTreeID.lower(target),
          FfiConverterTypeTreeParentId.lower(parent),
          FfiConverterUInt32.lower(to),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Return all nodes, including deleted nodes
   */
  public nodes(): Array<TreeId> {
    return FfiConverterArrayTypeTreeID.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_nodes(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Return the parent of target node.
   *
   * - If the target node does not exist, throws Error.
   * - If the target node is a root node, return nil.
   */
  public parent(target: TreeId): TreeParentId /*throws*/ {
    return FfiConverterTypeTreeParentId.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_parent(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            FfiConverterTypeTreeID.lower(target),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get the root nodes of the forest.
   */
  public roots(): Array<TreeId> {
    return FfiConverterArrayTypeTreeID.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_roots(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Subscribe the events of a container.
   *
   * The callback will be invoked when the container is changed.
   * Returns a subscription that can be used to unsubscribe.
   *
   * The events will be emitted after a transaction is committed. A transaction is committed when:
   *
   * - `doc.commit()` is called.
   * - `doc.export(mode)` is called.
   * - `doc.import(data)` is called.
   * - `doc.checkout(version)` is called.
   */
  public subscribe(subscriber: Subscriber): SubscriptionInterface | undefined {
    return FfiConverterOptionalTypeSubscription.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorotree_subscribe(
            uniffiTypeLoroTreeObjectFactory.clonePointer(this),
            FfiConverterTypeSubscriber.lower(subscriber),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeLoroTreeObjectFactory.pointer(this);
      uniffiTypeLoroTreeObjectFactory.freePointer(pointer);
      uniffiTypeLoroTreeObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is LoroTree {
    return uniffiTypeLoroTreeObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeLoroTreeObjectFactory: UniffiObjectFactory<LoroTreeInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): LoroTreeInterface {
      const instance = Object.create(LoroTree.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'LoroTree';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_lorotree_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: LoroTreeInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: LoroTreeInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_lorotree(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_lorotree(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is LoroTreeInterface {
      return (
        obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'LoroTree'
      );
    },
  };
// FfiConverter for LoroTreeInterface
const FfiConverterTypeLoroTree = new FfiConverterObject(
  uniffiTypeLoroTreeObjectFactory
);

export interface LoroUnknownInterface {
  /**
   * Get the container id.
   */
  id(): ContainerId;
}

export class LoroUnknown
  extends UniffiAbstractObject
  implements LoroUnknownInterface
{
  readonly [uniffiTypeNameSymbol] = 'LoroUnknown';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeLoroUnknownObjectFactory.bless(pointer);
  }

  /**
   * Get the container id.
   */
  public id(): ContainerId {
    return FfiConverterTypeContainerID.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorounknown_id(
            uniffiTypeLoroUnknownObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeLoroUnknownObjectFactory.pointer(this);
      uniffiTypeLoroUnknownObjectFactory.freePointer(pointer);
      uniffiTypeLoroUnknownObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is LoroUnknown {
    return uniffiTypeLoroUnknownObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeLoroUnknownObjectFactory: UniffiObjectFactory<LoroUnknownInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): LoroUnknownInterface {
      const instance = Object.create(LoroUnknown.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'LoroUnknown';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_lorounknown_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: LoroUnknownInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: LoroUnknownInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_lorounknown(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_lorounknown(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is LoroUnknownInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'LoroUnknown'
      );
    },
  };
// FfiConverter for LoroUnknownInterface
const FfiConverterTypeLoroUnknown = new FfiConverterObject(
  uniffiTypeLoroUnknownObjectFactory
);

export interface LoroValueLike {
  asLoroValue(): LoroValue;
}

export class LoroValueLikeImpl
  extends UniffiAbstractObject
  implements LoroValueLike
{
  readonly [uniffiTypeNameSymbol] = 'LoroValueLikeImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeLoroValueLikeImplObjectFactory.bless(pointer);
  }

  public asLoroValue(): LoroValue {
    return FfiConverterTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_lorovaluelike_as_loro_value(
            uniffiTypeLoroValueLikeImplObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeLoroValueLikeImplObjectFactory.pointer(this);
      uniffiTypeLoroValueLikeImplObjectFactory.freePointer(pointer);
      uniffiTypeLoroValueLikeImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is LoroValueLikeImpl {
    return uniffiTypeLoroValueLikeImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeLoroValueLikeImplObjectFactory: UniffiObjectFactory<LoroValueLike> =
  {
    create(pointer: UnsafeMutableRawPointer): LoroValueLike {
      const instance = Object.create(LoroValueLikeImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'LoroValueLikeImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_lorovaluelike_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: LoroValueLike): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: LoroValueLike): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_lorovaluelike(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_lorovaluelike(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is LoroValueLike {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'LoroValueLikeImpl'
      );
    },
  };
// FfiConverter for LoroValueLike
const FfiConverterTypeLoroValueLike = new FfiConverterObjectWithCallbacks(
  uniffiTypeLoroValueLikeImplObjectFactory
);

// Add a vtavble for the callbacks that go in LoroValueLike.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceLoroValueLike: {
  vtable: UniffiVTableCallbackInterfaceLoroValueLike;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    asLoroValue: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): LoroValue => {
        const jsCallback = FfiConverterTypeLoroValueLike.lift(uniffiHandle);
        return jsCallback.asLoroValue();
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterTypeLoroValue.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // LoroValueLike: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeLoroValueLike.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_loro_ffi_fn_init_callback_vtable_lorovaluelike(
      uniffiCallbackInterfaceLoroValueLike.vtable
    );
  },
};

export interface OnPop {
  onPop(
    undoOrRedo: UndoOrRedo,
    span: CounterSpan,
    undoMeta: UndoItemMeta
  ): void;
}

export class OnPopImpl extends UniffiAbstractObject implements OnPop {
  readonly [uniffiTypeNameSymbol] = 'OnPopImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeOnPopImplObjectFactory.bless(pointer);
  }

  public onPop(
    undoOrRedo: UndoOrRedo,
    span: CounterSpan,
    undoMeta: UndoItemMeta
  ): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_onpop_on_pop(
          uniffiTypeOnPopImplObjectFactory.clonePointer(this),
          FfiConverterTypeUndoOrRedo.lower(undoOrRedo),
          FfiConverterTypeCounterSpan.lower(span),
          FfiConverterTypeUndoItemMeta.lower(undoMeta),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeOnPopImplObjectFactory.pointer(this);
      uniffiTypeOnPopImplObjectFactory.freePointer(pointer);
      uniffiTypeOnPopImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is OnPopImpl {
    return uniffiTypeOnPopImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeOnPopImplObjectFactory: UniffiObjectFactory<OnPop> = {
  create(pointer: UnsafeMutableRawPointer): OnPop {
    const instance = Object.create(OnPopImpl.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'OnPopImpl';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_onpop_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: OnPop): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: OnPop): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_loro_ffi_fn_clone_onpop(pointer, callStatus),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_loro_ffi_fn_free_onpop(pointer, callStatus),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is OnPop {
    return (
      obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'OnPopImpl'
    );
  },
};
// FfiConverter for OnPop
const FfiConverterTypeOnPop = new FfiConverterObjectWithCallbacks(
  uniffiTypeOnPopImplObjectFactory
);

// Add a vtavble for the callbacks that go in OnPop.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceOnPop: {
  vtable: UniffiVTableCallbackInterfaceOnPop;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onPop: (
      uniffiHandle: bigint,
      undoOrRedo: Uint8Array,
      span: Uint8Array,
      undoMeta: Uint8Array
    ) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeOnPop.lift(uniffiHandle);
        return jsCallback.onPop(
          FfiConverterTypeUndoOrRedo.lift(undoOrRedo),
          FfiConverterTypeCounterSpan.lift(span),
          FfiConverterTypeUndoItemMeta.lift(undoMeta)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // OnPop: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeOnPop.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_loro_ffi_fn_init_callback_vtable_onpop(
      uniffiCallbackInterfaceOnPop.vtable
    );
  },
};

export interface OnPush {
  onPush(
    undoOrRedo: UndoOrRedo,
    span: CounterSpan,
    diffEvent: DiffEvent | undefined
  ): UndoItemMeta;
}

export class OnPushImpl extends UniffiAbstractObject implements OnPush {
  readonly [uniffiTypeNameSymbol] = 'OnPushImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeOnPushImplObjectFactory.bless(pointer);
  }

  public onPush(
    undoOrRedo: UndoOrRedo,
    span: CounterSpan,
    diffEvent: DiffEvent | undefined
  ): UndoItemMeta {
    return FfiConverterTypeUndoItemMeta.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_onpush_on_push(
            uniffiTypeOnPushImplObjectFactory.clonePointer(this),
            FfiConverterTypeUndoOrRedo.lower(undoOrRedo),
            FfiConverterTypeCounterSpan.lower(span),
            FfiConverterOptionalTypeDiffEvent.lower(diffEvent),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeOnPushImplObjectFactory.pointer(this);
      uniffiTypeOnPushImplObjectFactory.freePointer(pointer);
      uniffiTypeOnPushImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is OnPushImpl {
    return uniffiTypeOnPushImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeOnPushImplObjectFactory: UniffiObjectFactory<OnPush> = {
  create(pointer: UnsafeMutableRawPointer): OnPush {
    const instance = Object.create(OnPushImpl.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'OnPushImpl';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_onpush_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: OnPush): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: OnPush): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_loro_ffi_fn_clone_onpush(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_loro_ffi_fn_free_onpush(pointer, callStatus),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is OnPush {
    return (
      obj[destructorGuardSymbol] && obj[uniffiTypeNameSymbol] === 'OnPushImpl'
    );
  },
};
// FfiConverter for OnPush
const FfiConverterTypeOnPush = new FfiConverterObjectWithCallbacks(
  uniffiTypeOnPushImplObjectFactory
);

// Add a vtavble for the callbacks that go in OnPush.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceOnPush: {
  vtable: UniffiVTableCallbackInterfaceOnPush;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onPush: (
      uniffiHandle: bigint,
      undoOrRedo: Uint8Array,
      span: Uint8Array,
      diffEvent: Uint8Array
    ) => {
      const uniffiMakeCall = (): UndoItemMeta => {
        const jsCallback = FfiConverterTypeOnPush.lift(uniffiHandle);
        return jsCallback.onPush(
          FfiConverterTypeUndoOrRedo.lift(undoOrRedo),
          FfiConverterTypeCounterSpan.lift(span),
          FfiConverterOptionalTypeDiffEvent.lift(diffEvent)
        );
      };
      const uniffiResult = UniffiResult.ready<Uint8Array>();
      const uniffiHandleSuccess = (obj: any) => {
        UniffiResult.writeSuccess(
          uniffiResult,
          FfiConverterTypeUndoItemMeta.lower(obj)
        );
      };
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // OnPush: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeOnPush.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_loro_ffi_fn_init_callback_vtable_onpush(
      uniffiCallbackInterfaceOnPush.vtable
    );
  },
};

export interface PreCommitCallback {
  onPreCommit(payload: PreCommitCallbackPayload): void;
}

export class PreCommitCallbackImpl
  extends UniffiAbstractObject
  implements PreCommitCallback
{
  readonly [uniffiTypeNameSymbol] = 'PreCommitCallbackImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypePreCommitCallbackImplObjectFactory.bless(pointer);
  }

  public onPreCommit(payload: PreCommitCallbackPayload): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_precommitcallback_on_pre_commit(
          uniffiTypePreCommitCallbackImplObjectFactory.clonePointer(this),
          FfiConverterTypePreCommitCallbackPayload.lower(payload),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer =
        uniffiTypePreCommitCallbackImplObjectFactory.pointer(this);
      uniffiTypePreCommitCallbackImplObjectFactory.freePointer(pointer);
      uniffiTypePreCommitCallbackImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is PreCommitCallbackImpl {
    return uniffiTypePreCommitCallbackImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypePreCommitCallbackImplObjectFactory: UniffiObjectFactory<PreCommitCallback> =
  {
    create(pointer: UnsafeMutableRawPointer): PreCommitCallback {
      const instance = Object.create(PreCommitCallbackImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'PreCommitCallbackImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_precommitcallback_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: PreCommitCallback): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: PreCommitCallback): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_precommitcallback(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_precommitcallback(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is PreCommitCallback {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'PreCommitCallbackImpl'
      );
    },
  };
// FfiConverter for PreCommitCallback
const FfiConverterTypePreCommitCallback = new FfiConverterObjectWithCallbacks(
  uniffiTypePreCommitCallbackImplObjectFactory
);

// Add a vtavble for the callbacks that go in PreCommitCallback.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfacePreCommitCallback: {
  vtable: UniffiVTableCallbackInterfacePreCommitCallback;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onPreCommit: (uniffiHandle: bigint, payload: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypePreCommitCallback.lift(uniffiHandle);
        return jsCallback.onPreCommit(
          FfiConverterTypePreCommitCallbackPayload.lift(payload)
        );
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // PreCommitCallback: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypePreCommitCallback.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_loro_ffi_fn_init_callback_vtable_precommitcallback(
      uniffiCallbackInterfacePreCommitCallback.vtable
    );
  },
};

export interface StyleConfigMapInterface {
  get(key: string): StyleConfig | undefined;
  insert(key: string, value: StyleConfig): void;
}

export class StyleConfigMap
  extends UniffiAbstractObject
  implements StyleConfigMapInterface
{
  readonly [uniffiTypeNameSymbol] = 'StyleConfigMap';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_styleconfigmap_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeStyleConfigMapObjectFactory.bless(pointer);
  }

  public static defaultRichTextConfig(): StyleConfigMapInterface {
    return FfiConverterTypeStyleConfigMap.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_styleconfigmap_default_rich_text_config(
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public get(key: string): StyleConfig | undefined {
    return FfiConverterOptionalTypeStyleConfig.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_styleconfigmap_get(
            uniffiTypeStyleConfigMapObjectFactory.clonePointer(this),
            FfiConverterString.lower(key),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public insert(key: string, value: StyleConfig): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_styleconfigmap_insert(
          uniffiTypeStyleConfigMapObjectFactory.clonePointer(this),
          FfiConverterString.lower(key),
          FfiConverterTypeStyleConfig.lower(value),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeStyleConfigMapObjectFactory.pointer(this);
      uniffiTypeStyleConfigMapObjectFactory.freePointer(pointer);
      uniffiTypeStyleConfigMapObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is StyleConfigMap {
    return uniffiTypeStyleConfigMapObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeStyleConfigMapObjectFactory: UniffiObjectFactory<StyleConfigMapInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): StyleConfigMapInterface {
      const instance = Object.create(StyleConfigMap.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'StyleConfigMap';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_styleconfigmap_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: StyleConfigMapInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: StyleConfigMapInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_styleconfigmap(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_styleconfigmap(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is StyleConfigMapInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'StyleConfigMap'
      );
    },
  };
// FfiConverter for StyleConfigMapInterface
const FfiConverterTypeStyleConfigMap = new FfiConverterObject(
  uniffiTypeStyleConfigMapObjectFactory
);

export interface Subscriber {
  onDiff(diff: DiffEvent): void;
}

export class SubscriberImpl extends UniffiAbstractObject implements Subscriber {
  readonly [uniffiTypeNameSymbol] = 'SubscriberImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSubscriberImplObjectFactory.bless(pointer);
  }

  public onDiff(diff: DiffEvent): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_subscriber_on_diff(
          uniffiTypeSubscriberImplObjectFactory.clonePointer(this),
          FfiConverterTypeDiffEvent.lower(diff),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSubscriberImplObjectFactory.pointer(this);
      uniffiTypeSubscriberImplObjectFactory.freePointer(pointer);
      uniffiTypeSubscriberImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is SubscriberImpl {
    return uniffiTypeSubscriberImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSubscriberImplObjectFactory: UniffiObjectFactory<Subscriber> = {
  create(pointer: UnsafeMutableRawPointer): Subscriber {
    const instance = Object.create(SubscriberImpl.prototype);
    instance[pointerLiteralSymbol] = pointer;
    instance[destructorGuardSymbol] = this.bless(pointer);
    instance[uniffiTypeNameSymbol] = 'SubscriberImpl';
    return instance;
  },

  bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
    return uniffiCaller.rustCall(
      /*caller:*/ (status) =>
        nativeModule().ubrn_uniffi_internal_fn_method_subscriber_ffi__bless_pointer(
          p,
          status
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  unbless(ptr: UniffiRustArcPtr) {
    ptr.markDestroyed();
  },

  pointer(obj: Subscriber): UnsafeMutableRawPointer {
    if ((obj as any)[destructorGuardSymbol] === undefined) {
      throw new UniffiInternalError.UnexpectedNullPointer();
    }
    return (obj as any)[pointerLiteralSymbol];
  },

  clonePointer(obj: Subscriber): UnsafeMutableRawPointer {
    const pointer = this.pointer(obj);
    return uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_loro_ffi_fn_clone_subscriber(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  freePointer(pointer: UnsafeMutableRawPointer): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) =>
        nativeModule().ubrn_uniffi_loro_ffi_fn_free_subscriber(
          pointer,
          callStatus
        ),
      /*liftString:*/ FfiConverterString.lift
    );
  },

  isConcreteType(obj: any): obj is Subscriber {
    return (
      obj[destructorGuardSymbol] &&
      obj[uniffiTypeNameSymbol] === 'SubscriberImpl'
    );
  },
};
// FfiConverter for Subscriber
const FfiConverterTypeSubscriber = new FfiConverterObjectWithCallbacks(
  uniffiTypeSubscriberImplObjectFactory
);

// Add a vtavble for the callbacks that go in Subscriber.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceSubscriber: {
  vtable: UniffiVTableCallbackInterfaceSubscriber;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onDiff: (uniffiHandle: bigint, diff: Uint8Array) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeSubscriber.lift(uniffiHandle);
        return jsCallback.onDiff(FfiConverterTypeDiffEvent.lift(diff));
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // Subscriber: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeSubscriber.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_loro_ffi_fn_init_callback_vtable_subscriber(
      uniffiCallbackInterfaceSubscriber.vtable
    );
  },
};

/**
 * A handle to a subscription created by GPUI. When dropped, the subscription
 * is cancelled and the callback will no longer be invoked.
 */
export interface SubscriptionInterface {
  /**
   * Detaches the subscription from this handle. The callback will
   * continue to be invoked until the views or models it has been
   * subscribed to are dropped
   */
  detach(): void;
  /**
   * Unsubscribes the subscription.
   */
  unsubscribe(): void;
}

/**
 * A handle to a subscription created by GPUI. When dropped, the subscription
 * is cancelled and the callback will no longer be invoked.
 */
export class Subscription
  extends UniffiAbstractObject
  implements SubscriptionInterface
{
  readonly [uniffiTypeNameSymbol] = 'Subscription';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeSubscriptionObjectFactory.bless(pointer);
  }

  /**
   * Detaches the subscription from this handle. The callback will
   * continue to be invoked until the views or models it has been
   * subscribed to are dropped
   */
  public detach(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_subscription_detach(
          uniffiTypeSubscriptionObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Unsubscribes the subscription.
   */
  public unsubscribe(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_subscription_unsubscribe(
          uniffiTypeSubscriptionObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeSubscriptionObjectFactory.pointer(this);
      uniffiTypeSubscriptionObjectFactory.freePointer(pointer);
      uniffiTypeSubscriptionObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is Subscription {
    return uniffiTypeSubscriptionObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeSubscriptionObjectFactory: UniffiObjectFactory<SubscriptionInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): SubscriptionInterface {
      const instance = Object.create(Subscription.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'Subscription';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_subscription_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: SubscriptionInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: SubscriptionInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_subscription(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_subscription(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is SubscriptionInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'Subscription'
      );
    },
  };
// FfiConverter for SubscriptionInterface
const FfiConverterTypeSubscription = new FfiConverterObject(
  uniffiTypeSubscriptionObjectFactory
);

export interface UndoManagerInterface {
  /**
   * If a local event's origin matches the given prefix, it will not be recorded in the
   * undo stack.
   */
  addExcludeOriginPrefix(prefix: string): void;
  /**
   * Whether the undo manager can redo.
   */
  canRedo(): boolean;
  /**
   * Whether the undo manager can undo.
   */
  canUndo(): boolean;
  /**
   * Record a new checkpoint.
   */
  recordNewCheckpoint() /*throws*/ : void;
  /**
   * Redo the last change made by the peer.
   */
  redo() /*throws*/ : boolean;
  /**
   * How many times the undo manager can redo.
   */
  redoCount(): /*u32*/ number;
  /**
   * Set the maximum number of undo steps. The default value is 100.
   */
  setMaxUndoSteps(size: /*u32*/ number): void;
  /**
   * Set the merge interval in ms. The default value is 0, which means no merge.
   */
  setMergeInterval(interval: /*i64*/ bigint): void;
  /**
   * Set the listener for pop events.
   * The listener will be called when an undo/redo item is popped from the stack.
   */
  setOnPop(onPop: OnPop | undefined): void;
  /**
   * Set the listener for push events.
   * The listener will be called when a new undo/redo item is pushed into the stack.
   */
  setOnPush(onPush: OnPush | undefined): void;
  /**
   * Undo the last change made by the peer.
   */
  undo() /*throws*/ : boolean;
  /**
   * How many times the undo manager can undo.
   */
  undoCount(): /*u32*/ number;
}

export class UndoManager
  extends UniffiAbstractObject
  implements UndoManagerInterface
{
  readonly [uniffiTypeNameSymbol] = 'UndoManager';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  /**
   * Create a new UndoManager.
   */
  constructor(doc: LoroDocInterface) {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_undomanager_new(
          FfiConverterTypeLoroDoc.lower(doc),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeUndoManagerObjectFactory.bless(pointer);
  }

  /**
   * If a local event's origin matches the given prefix, it will not be recorded in the
   * undo stack.
   */
  public addExcludeOriginPrefix(prefix: string): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_undomanager_add_exclude_origin_prefix(
          uniffiTypeUndoManagerObjectFactory.clonePointer(this),
          FfiConverterString.lower(prefix),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Whether the undo manager can redo.
   */
  public canRedo(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_undomanager_can_redo(
            uniffiTypeUndoManagerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Whether the undo manager can undo.
   */
  public canUndo(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_undomanager_can_undo(
            uniffiTypeUndoManagerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Record a new checkpoint.
   */
  public recordNewCheckpoint(): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
        FfiConverterTypeLoroError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_undomanager_record_new_checkpoint(
          uniffiTypeUndoManagerObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Redo the last change made by the peer.
   */
  public redo(): boolean /*throws*/ {
    return FfiConverterBool.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_undomanager_redo(
            uniffiTypeUndoManagerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * How many times the undo manager can redo.
   */
  public redoCount(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_undomanager_redo_count(
            uniffiTypeUndoManagerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Set the maximum number of undo steps. The default value is 100.
   */
  public setMaxUndoSteps(size: /*u32*/ number): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_undomanager_set_max_undo_steps(
          uniffiTypeUndoManagerObjectFactory.clonePointer(this),
          FfiConverterUInt32.lower(size),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Set the merge interval in ms. The default value is 0, which means no merge.
   */
  public setMergeInterval(interval: /*i64*/ bigint): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_undomanager_set_merge_interval(
          uniffiTypeUndoManagerObjectFactory.clonePointer(this),
          FfiConverterInt64.lower(interval),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Set the listener for pop events.
   * The listener will be called when an undo/redo item is popped from the stack.
   */
  public setOnPop(onPop: OnPop | undefined): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_undomanager_set_on_pop(
          uniffiTypeUndoManagerObjectFactory.clonePointer(this),
          FfiConverterOptionalTypeOnPop.lower(onPop),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Set the listener for push events.
   * The listener will be called when a new undo/redo item is pushed into the stack.
   */
  public setOnPush(onPush: OnPush | undefined): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_undomanager_set_on_push(
          uniffiTypeUndoManagerObjectFactory.clonePointer(this),
          FfiConverterOptionalTypeOnPush.lower(onPush),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Undo the last change made by the peer.
   */
  public undo(): boolean /*throws*/ {
    return FfiConverterBool.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_undomanager_undo(
            uniffiTypeUndoManagerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * How many times the undo manager can undo.
   */
  public undoCount(): /*u32*/ number {
    return FfiConverterUInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_undomanager_undo_count(
            uniffiTypeUndoManagerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeUndoManagerObjectFactory.pointer(this);
      uniffiTypeUndoManagerObjectFactory.freePointer(pointer);
      uniffiTypeUndoManagerObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is UndoManager {
    return uniffiTypeUndoManagerObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeUndoManagerObjectFactory: UniffiObjectFactory<UndoManagerInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): UndoManagerInterface {
      const instance = Object.create(UndoManager.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'UndoManager';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_undomanager_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: UndoManagerInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: UndoManagerInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_undomanager(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_undomanager(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is UndoManagerInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'UndoManager'
      );
    },
  };
// FfiConverter for UndoManagerInterface
const FfiConverterTypeUndoManager = new FfiConverterObject(
  uniffiTypeUndoManagerObjectFactory
);

export interface Unsubscriber {
  onUnsubscribe(): void;
}

export class UnsubscriberImpl
  extends UniffiAbstractObject
  implements Unsubscriber
{
  readonly [uniffiTypeNameSymbol] = 'UnsubscriberImpl';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeUnsubscriberImplObjectFactory.bless(pointer);
  }

  public onUnsubscribe(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_unsubscriber_on_unsubscribe(
          uniffiTypeUnsubscriberImplObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeUnsubscriberImplObjectFactory.pointer(this);
      uniffiTypeUnsubscriberImplObjectFactory.freePointer(pointer);
      uniffiTypeUnsubscriberImplObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is UnsubscriberImpl {
    return uniffiTypeUnsubscriberImplObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeUnsubscriberImplObjectFactory: UniffiObjectFactory<Unsubscriber> =
  {
    create(pointer: UnsafeMutableRawPointer): Unsubscriber {
      const instance = Object.create(UnsubscriberImpl.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'UnsubscriberImpl';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_unsubscriber_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: Unsubscriber): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: Unsubscriber): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_unsubscriber(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_unsubscriber(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is Unsubscriber {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'UnsubscriberImpl'
      );
    },
  };
// FfiConverter for Unsubscriber
const FfiConverterTypeUnsubscriber = new FfiConverterObjectWithCallbacks(
  uniffiTypeUnsubscriberImplObjectFactory
);

// Add a vtavble for the callbacks that go in Unsubscriber.

// Put the implementation in a struct so we don't pollute the top-level namespace
const uniffiCallbackInterfaceUnsubscriber: {
  vtable: UniffiVTableCallbackInterfaceUnsubscriber;
  register: () => void;
} = {
  // Create the VTable using a series of closures.
  // ts automatically converts these into C callback functions.
  vtable: {
    onUnsubscribe: (uniffiHandle: bigint) => {
      const uniffiMakeCall = (): void => {
        const jsCallback = FfiConverterTypeUnsubscriber.lift(uniffiHandle);
        return jsCallback.onUnsubscribe();
      };
      const uniffiResult = UniffiResult.ready<void>();
      const uniffiHandleSuccess = (obj: any) => {};
      const uniffiHandleError = (code: number, errBuf: UniffiByteArray) => {
        UniffiResult.writeError(uniffiResult, code, errBuf);
      };
      uniffiTraitInterfaceCall(
        /*makeCall:*/ uniffiMakeCall,
        /*handleSuccess:*/ uniffiHandleSuccess,
        /*handleError:*/ uniffiHandleError,
        /*lowerString:*/ FfiConverterString.lower
      );
      return uniffiResult;
    },
    uniffiFree: (uniffiHandle: UniffiHandle): void => {
      // Unsubscriber: this will throw a stale handle error if the handle isn't found.
      FfiConverterTypeUnsubscriber.drop(uniffiHandle);
    },
  },
  register: () => {
    nativeModule().ubrn_uniffi_loro_ffi_fn_init_callback_vtable_unsubscriber(
      uniffiCallbackInterfaceUnsubscriber.vtable
    );
  },
};

export interface ValueOrContainerInterface {
  asContainer(): ContainerId | undefined;
  asLoroCounter(): LoroCounterInterface | undefined;
  asLoroList(): LoroListInterface | undefined;
  asLoroMap(): LoroMapInterface | undefined;
  asLoroMovableList(): LoroMovableListInterface | undefined;
  asLoroText(): LoroTextInterface | undefined;
  asLoroTree(): LoroTreeInterface | undefined;
  asLoroUnknown(): LoroUnknownInterface | undefined;
  asValue(): LoroValue | undefined;
  containerType(): ContainerType | undefined;
  isContainer(): boolean;
  isValue(): boolean;
}

export class ValueOrContainer
  extends UniffiAbstractObject
  implements ValueOrContainerInterface
{
  readonly [uniffiTypeNameSymbol] = 'ValueOrContainer';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  // No primary constructor declared for this class.
  private constructor(pointer: UnsafeMutableRawPointer) {
    super();
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeValueOrContainerObjectFactory.bless(pointer);
  }

  public asContainer(): ContainerId | undefined {
    return FfiConverterOptionalTypeContainerID.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_valueorcontainer_as_container(
            uniffiTypeValueOrContainerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asLoroCounter(): LoroCounterInterface | undefined {
    return FfiConverterOptionalTypeLoroCounter.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_valueorcontainer_as_loro_counter(
            uniffiTypeValueOrContainerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asLoroList(): LoroListInterface | undefined {
    return FfiConverterOptionalTypeLoroList.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_valueorcontainer_as_loro_list(
            uniffiTypeValueOrContainerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asLoroMap(): LoroMapInterface | undefined {
    return FfiConverterOptionalTypeLoroMap.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_valueorcontainer_as_loro_map(
            uniffiTypeValueOrContainerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asLoroMovableList(): LoroMovableListInterface | undefined {
    return FfiConverterOptionalTypeLoroMovableList.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_valueorcontainer_as_loro_movable_list(
            uniffiTypeValueOrContainerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asLoroText(): LoroTextInterface | undefined {
    return FfiConverterOptionalTypeLoroText.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_valueorcontainer_as_loro_text(
            uniffiTypeValueOrContainerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asLoroTree(): LoroTreeInterface | undefined {
    return FfiConverterOptionalTypeLoroTree.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_valueorcontainer_as_loro_tree(
            uniffiTypeValueOrContainerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asLoroUnknown(): LoroUnknownInterface | undefined {
    return FfiConverterOptionalTypeLoroUnknown.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_valueorcontainer_as_loro_unknown(
            uniffiTypeValueOrContainerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public asValue(): LoroValue | undefined {
    return FfiConverterOptionalTypeLoroValue.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_valueorcontainer_as_value(
            uniffiTypeValueOrContainerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public containerType(): ContainerType | undefined {
    return FfiConverterOptionalTypeContainerType.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_valueorcontainer_container_type(
            uniffiTypeValueOrContainerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isContainer(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_valueorcontainer_is_container(
            uniffiTypeValueOrContainerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public isValue(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_valueorcontainer_is_value(
            uniffiTypeValueOrContainerObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeValueOrContainerObjectFactory.pointer(this);
      uniffiTypeValueOrContainerObjectFactory.freePointer(pointer);
      uniffiTypeValueOrContainerObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is ValueOrContainer {
    return uniffiTypeValueOrContainerObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeValueOrContainerObjectFactory: UniffiObjectFactory<ValueOrContainerInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): ValueOrContainerInterface {
      const instance = Object.create(ValueOrContainer.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'ValueOrContainer';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_valueorcontainer_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: ValueOrContainerInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: ValueOrContainerInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_valueorcontainer(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_valueorcontainer(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is ValueOrContainerInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'ValueOrContainer'
      );
    },
  };
// FfiConverter for ValueOrContainerInterface
const FfiConverterTypeValueOrContainer = new FfiConverterObject(
  uniffiTypeValueOrContainerObjectFactory
);

export interface VersionRangeInterface {
  /**
   * Clear all ranges in the VersionRange
   */
  clear(): void;
  /**
   * Check if this VersionRange contains a specific ID
   */
  containsId(id: Id): boolean;
  /**
   * Check if this VersionRange contains a specific ID span
   */
  containsIdSpan(span: IdSpan): boolean;
  /**
   * Check if this VersionRange contains operations between two VersionVectors
   */
  containsOpsBetween(
    vvA: VersionVectorInterface,
    vvB: VersionVectorInterface
  ): boolean;
  /**
   * Extend this VersionRange to include the given ID span
   */
  extendsToIncludeIdSpan(span: IdSpan): void;
  /**
   * Get the counter range for a specific peer
   * Returns the counter range if the peer exists, null otherwise
   */
  get(peer: /*u64*/ bigint): CounterSpan | undefined;
  /**
   * Get all ranges as a list of (peer, start, end) tuples
   */
  getAllRanges(): Array<VersionRangeItem>;
  /**
   * Get all peer IDs in this VersionRange
   */
  getPeers(): Array</*u64*/ bigint>;
  /**
   * Check if this VersionRange has overlap with the given ID span
   */
  hasOverlapWith(span: IdSpan): boolean;
  /**
   * Insert a counter range for a specific peer
   */
  insert(
    peer: /*u64*/ bigint,
    start: /*i32*/ number,
    end: /*i32*/ number
  ): void;
  /**
   * Check if the VersionRange is empty
   */
  isEmpty(): boolean;
}

export class VersionRange
  extends UniffiAbstractObject
  implements VersionRangeInterface
{
  readonly [uniffiTypeNameSymbol] = 'VersionRange';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_versionrange_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeVersionRangeObjectFactory.bless(pointer);
  }

  /**
   * Create a VersionRange from a VersionVector
   */
  public static fromVv(vv: VersionVectorInterface): VersionRangeInterface {
    return FfiConverterTypeVersionRange.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_versionrange_from_vv(
            FfiConverterTypeVersionVector.lower(vv),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Clear all ranges in the VersionRange
   */
  public clear(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionrange_clear(
          uniffiTypeVersionRangeObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Check if this VersionRange contains a specific ID
   */
  public containsId(id: Id): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionrange_contains_id(
            uniffiTypeVersionRangeObjectFactory.clonePointer(this),
            FfiConverterTypeID.lower(id),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if this VersionRange contains a specific ID span
   */
  public containsIdSpan(span: IdSpan): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionrange_contains_id_span(
            uniffiTypeVersionRangeObjectFactory.clonePointer(this),
            FfiConverterTypeIdSpan.lower(span),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if this VersionRange contains operations between two VersionVectors
   */
  public containsOpsBetween(
    vvA: VersionVectorInterface,
    vvB: VersionVectorInterface
  ): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionrange_contains_ops_between(
            uniffiTypeVersionRangeObjectFactory.clonePointer(this),
            FfiConverterTypeVersionVector.lower(vvA),
            FfiConverterTypeVersionVector.lower(vvB),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Extend this VersionRange to include the given ID span
   */
  public extendsToIncludeIdSpan(span: IdSpan): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionrange_extends_to_include_id_span(
          uniffiTypeVersionRangeObjectFactory.clonePointer(this),
          FfiConverterTypeIdSpan.lower(span),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Get the counter range for a specific peer
   * Returns the counter range if the peer exists, null otherwise
   */
  public get(peer: /*u64*/ bigint): CounterSpan | undefined {
    return FfiConverterOptionalTypeCounterSpan.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionrange_get(
            uniffiTypeVersionRangeObjectFactory.clonePointer(this),
            FfiConverterUInt64.lower(peer),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get all ranges as a list of (peer, start, end) tuples
   */
  public getAllRanges(): Array<VersionRangeItem> {
    return FfiConverterArrayTypeVersionRangeItem.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionrange_get_all_ranges(
            uniffiTypeVersionRangeObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Get all peer IDs in this VersionRange
   */
  public getPeers(): Array</*u64*/ bigint> {
    return FfiConverterArrayUInt64.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionrange_get_peers(
            uniffiTypeVersionRangeObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Check if this VersionRange has overlap with the given ID span
   */
  public hasOverlapWith(span: IdSpan): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionrange_has_overlap_with(
            uniffiTypeVersionRangeObjectFactory.clonePointer(this),
            FfiConverterTypeIdSpan.lower(span),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * Insert a counter range for a specific peer
   */
  public insert(
    peer: /*u64*/ bigint,
    start: /*i32*/ number,
    end: /*i32*/ number
  ): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionrange_insert(
          uniffiTypeVersionRangeObjectFactory.clonePointer(this),
          FfiConverterUInt64.lower(peer),
          FfiConverterInt32.lower(start),
          FfiConverterInt32.lower(end),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * Check if the VersionRange is empty
   */
  public isEmpty(): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionrange_is_empty(
            uniffiTypeVersionRangeObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeVersionRangeObjectFactory.pointer(this);
      uniffiTypeVersionRangeObjectFactory.freePointer(pointer);
      uniffiTypeVersionRangeObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is VersionRange {
    return uniffiTypeVersionRangeObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeVersionRangeObjectFactory: UniffiObjectFactory<VersionRangeInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): VersionRangeInterface {
      const instance = Object.create(VersionRange.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'VersionRange';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_versionrange_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: VersionRangeInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: VersionRangeInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_versionrange(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_versionrange(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is VersionRangeInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'VersionRange'
      );
    },
  };
// FfiConverter for VersionRangeInterface
const FfiConverterTypeVersionRange = new FfiConverterObject(
  uniffiTypeVersionRangeObjectFactory
);

export interface VersionVectorInterface {
  diff(rhs: VersionVectorInterface): VersionVectorDiff;
  encode(): ArrayBuffer;
  eq(other: VersionVectorInterface): boolean;
  extendToIncludeVv(other: VersionVectorInterface): void;
  getLast(peer: /*u64*/ bigint): /*i32*/ number | undefined;
  getMissingSpan(target: VersionVectorInterface): Array<IdSpan>;
  includesId(id: Id): boolean;
  includesVv(other: VersionVectorInterface): boolean;
  intersectSpan(target: IdSpan): CounterSpan | undefined;
  merge(other: VersionVectorInterface): void;
  partialCmp(other: VersionVectorInterface): Ordering | undefined;
  setEnd(id: Id): void;
  setLast(id: Id): void;
}

export class VersionVector
  extends UniffiAbstractObject
  implements VersionVectorInterface
{
  readonly [uniffiTypeNameSymbol] = 'VersionVector';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor() {
    super();
    const pointer = uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_versionvector_new(
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeVersionVectorObjectFactory.bless(pointer);
  }

  public static decode(bytes: ArrayBuffer): VersionVectorInterface /*throws*/ {
    return FfiConverterTypeVersionVector.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeLoroError.lift.bind(
          FfiConverterTypeLoroError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_constructor_versionvector_decode(
            FfiConverterArrayBuffer.lower(bytes),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public diff(rhs: VersionVectorInterface): VersionVectorDiff {
    return FfiConverterTypeVersionVectorDiff.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionvector_diff(
            uniffiTypeVersionVectorObjectFactory.clonePointer(this),
            FfiConverterTypeVersionVector.lower(rhs),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public encode(): ArrayBuffer {
    return FfiConverterArrayBuffer.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionvector_encode(
            uniffiTypeVersionVectorObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public eq(other: VersionVectorInterface): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionvector_eq(
            uniffiTypeVersionVectorObjectFactory.clonePointer(this),
            FfiConverterTypeVersionVector.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public extendToIncludeVv(other: VersionVectorInterface): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionvector_extend_to_include_vv(
          uniffiTypeVersionVectorObjectFactory.clonePointer(this),
          FfiConverterTypeVersionVector.lower(other),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public getLast(peer: /*u64*/ bigint): /*i32*/ number | undefined {
    return FfiConverterOptionalInt32.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionvector_get_last(
            uniffiTypeVersionVectorObjectFactory.clonePointer(this),
            FfiConverterUInt64.lower(peer),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public getMissingSpan(target: VersionVectorInterface): Array<IdSpan> {
    return FfiConverterArrayTypeIdSpan.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionvector_get_missing_span(
            uniffiTypeVersionVectorObjectFactory.clonePointer(this),
            FfiConverterTypeVersionVector.lower(target),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public includesId(id: Id): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionvector_includes_id(
            uniffiTypeVersionVectorObjectFactory.clonePointer(this),
            FfiConverterTypeID.lower(id),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public includesVv(other: VersionVectorInterface): boolean {
    return FfiConverterBool.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionvector_includes_vv(
            uniffiTypeVersionVectorObjectFactory.clonePointer(this),
            FfiConverterTypeVersionVector.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public intersectSpan(target: IdSpan): CounterSpan | undefined {
    return FfiConverterOptionalTypeCounterSpan.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionvector_intersect_span(
            uniffiTypeVersionVectorObjectFactory.clonePointer(this),
            FfiConverterTypeIdSpan.lower(target),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public merge(other: VersionVectorInterface): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionvector_merge(
          uniffiTypeVersionVectorObjectFactory.clonePointer(this),
          FfiConverterTypeVersionVector.lower(other),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public partialCmp(other: VersionVectorInterface): Ordering | undefined {
    return FfiConverterOptionalTypeOrdering.lift(
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionvector_partial_cmp(
            uniffiTypeVersionVectorObjectFactory.clonePointer(this),
            FfiConverterTypeVersionVector.lower(other),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public setEnd(id: Id): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionvector_set_end(
          uniffiTypeVersionVectorObjectFactory.clonePointer(this),
          FfiConverterTypeID.lower(id),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public setLast(id: Id): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_loro_ffi_fn_method_versionvector_set_last(
          uniffiTypeVersionVectorObjectFactory.clonePointer(this),
          FfiConverterTypeID.lower(id),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeVersionVectorObjectFactory.pointer(this);
      uniffiTypeVersionVectorObjectFactory.freePointer(pointer);
      uniffiTypeVersionVectorObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is VersionVector {
    return uniffiTypeVersionVectorObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeVersionVectorObjectFactory: UniffiObjectFactory<VersionVectorInterface> =
  {
    create(pointer: UnsafeMutableRawPointer): VersionVectorInterface {
      const instance = Object.create(VersionVector.prototype);
      instance[pointerLiteralSymbol] = pointer;
      instance[destructorGuardSymbol] = this.bless(pointer);
      instance[uniffiTypeNameSymbol] = 'VersionVector';
      return instance;
    },

    bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
      return uniffiCaller.rustCall(
        /*caller:*/ (status) =>
          nativeModule().ubrn_uniffi_internal_fn_method_versionvector_ffi__bless_pointer(
            p,
            status
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    unbless(ptr: UniffiRustArcPtr) {
      ptr.markDestroyed();
    },

    pointer(obj: VersionVectorInterface): UnsafeMutableRawPointer {
      if ((obj as any)[destructorGuardSymbol] === undefined) {
        throw new UniffiInternalError.UnexpectedNullPointer();
      }
      return (obj as any)[pointerLiteralSymbol];
    },

    clonePointer(obj: VersionVectorInterface): UnsafeMutableRawPointer {
      const pointer = this.pointer(obj);
      return uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_clone_versionvector(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    freePointer(pointer: UnsafeMutableRawPointer): void {
      uniffiCaller.rustCall(
        /*caller:*/ (callStatus) =>
          nativeModule().ubrn_uniffi_loro_ffi_fn_free_versionvector(
            pointer,
            callStatus
          ),
        /*liftString:*/ FfiConverterString.lift
      );
    },

    isConcreteType(obj: any): obj is VersionVectorInterface {
      return (
        obj[destructorGuardSymbol] &&
        obj[uniffiTypeNameSymbol] === 'VersionVector'
      );
    },
  };
// FfiConverter for VersionVectorInterface
const FfiConverterTypeVersionVector = new FfiConverterObject(
  uniffiTypeVersionVectorObjectFactory
);

// FfiConverter for /*f64*/number | undefined
const FfiConverterOptionalFloat64 = new FfiConverterOptional(
  FfiConverterFloat64
);

// FfiConverter for /*i32*/number | undefined
const FfiConverterOptionalInt32 = new FfiConverterOptional(FfiConverterInt32);

// FfiConverter for /*i64*/bigint | undefined
const FfiConverterOptionalInt64 = new FfiConverterOptional(FfiConverterInt64);

// FfiConverter for ChangeMeta | undefined
const FfiConverterOptionalTypeChangeMeta = new FfiConverterOptional(
  FfiConverterTypeChangeMeta
);

// FfiConverter for CounterSpan | undefined
const FfiConverterOptionalTypeCounterSpan = new FfiConverterOptional(
  FfiConverterTypeCounterSpan
);

// FfiConverter for DiffEvent | undefined
const FfiConverterOptionalTypeDiffEvent = new FfiConverterOptional(
  FfiConverterTypeDiffEvent
);

// FfiConverter for Id | undefined
const FfiConverterOptionalTypeID = new FfiConverterOptional(FfiConverterTypeID);

// FfiConverter for StyleConfig | undefined
const FfiConverterOptionalTypeStyleConfig = new FfiConverterOptional(
  FfiConverterTypeStyleConfig
);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u32*/number | undefined
const FfiConverterOptionalUInt32 = new FfiConverterOptional(FfiConverterUInt32);

// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);

// FfiConverter for Array<ArrayBuffer>
const FfiConverterArrayArrayBuffer = new FfiConverterArray(
  FfiConverterArrayBuffer
);

// FfiConverter for Array<ContainerDiff>
const FfiConverterArrayTypeContainerDiff = new FfiConverterArray(
  FfiConverterTypeContainerDiff
);

// FfiConverter for Array<ContainerIdAndDiff>
const FfiConverterArrayTypeContainerIDAndDiff = new FfiConverterArray(
  FfiConverterTypeContainerIDAndDiff
);

// FfiConverter for Array<ContainerPath>
const FfiConverterArrayTypeContainerPath = new FfiConverterArray(
  FfiConverterTypeContainerPath
);

// FfiConverter for Array<CursorWithPos>
const FfiConverterArrayTypeCursorWithPos = new FfiConverterArray(
  FfiConverterTypeCursorWithPos
);

// FfiConverter for Array<Id>
const FfiConverterArrayTypeID = new FfiConverterArray(FfiConverterTypeID);

// FfiConverter for Array<IdSpan>
const FfiConverterArrayTypeIdSpan = new FfiConverterArray(
  FfiConverterTypeIdSpan
);

// FfiConverter for Array<PathItem>
const FfiConverterArrayTypePathItem = new FfiConverterArray(
  FfiConverterTypePathItem
);

// FfiConverter for Array<TreeDiffItem>
const FfiConverterArrayTypeTreeDiffItem = new FfiConverterArray(
  FfiConverterTypeTreeDiffItem
);

// FfiConverter for Array<TreeId>
const FfiConverterArrayTypeTreeID = new FfiConverterArray(
  FfiConverterTypeTreeID
);

// FfiConverter for Array<VersionRangeItem>
const FfiConverterArrayTypeVersionRangeItem = new FfiConverterArray(
  FfiConverterTypeVersionRangeItem
);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

// FfiConverter for Array</*u64*/bigint>
const FfiConverterArrayUInt64 = new FfiConverterArray(FfiConverterUInt64);

// FfiConverter for Map<string, LoroValue>
const FfiConverterMapStringTypeLoroValue = new FfiConverterMap(
  FfiConverterString,
  FfiConverterTypeLoroValue
);

// FfiConverter for ContainerId | undefined
const FfiConverterOptionalTypeContainerID = new FfiConverterOptional(
  FfiConverterTypeContainerID
);

// FfiConverter for ContainerType | undefined
const FfiConverterOptionalTypeContainerType = new FfiConverterOptional(
  FfiConverterTypeContainerType
);

// FfiConverter for Diff | undefined
const FfiConverterOptionalTypeDiff = new FfiConverterOptional(
  FfiConverterTypeDiff
);

// FfiConverter for LoroValue | undefined
const FfiConverterOptionalTypeLoroValue = new FfiConverterOptional(
  FfiConverterTypeLoroValue
);

// FfiConverter for Ordering | undefined
const FfiConverterOptionalTypeOrdering = new FfiConverterOptional(
  FfiConverterTypeOrdering
);

// FfiConverter for Map</*u64*/bigint, CounterSpan> | undefined
const FfiConverterOptionalMapUInt64TypeCounterSpan = new FfiConverterOptional(
  FfiConverterMapUInt64TypeCounterSpan
);

// FfiConverter for CursorInterface | undefined
const FfiConverterOptionalTypeCursor = new FfiConverterOptional(
  FfiConverterTypeCursor
);

// FfiConverter for FrontiersInterface | undefined
const FfiConverterOptionalTypeFrontiers = new FfiConverterOptional(
  FfiConverterTypeFrontiers
);

// FfiConverter for LoroCounterInterface | undefined
const FfiConverterOptionalTypeLoroCounter = new FfiConverterOptional(
  FfiConverterTypeLoroCounter
);

// FfiConverter for LoroDocInterface | undefined
const FfiConverterOptionalTypeLoroDoc = new FfiConverterOptional(
  FfiConverterTypeLoroDoc
);

// FfiConverter for LoroListInterface | undefined
const FfiConverterOptionalTypeLoroList = new FfiConverterOptional(
  FfiConverterTypeLoroList
);

// FfiConverter for LoroMapInterface | undefined
const FfiConverterOptionalTypeLoroMap = new FfiConverterOptional(
  FfiConverterTypeLoroMap
);

// FfiConverter for LoroMovableListInterface | undefined
const FfiConverterOptionalTypeLoroMovableList = new FfiConverterOptional(
  FfiConverterTypeLoroMovableList
);

// FfiConverter for LoroTextInterface | undefined
const FfiConverterOptionalTypeLoroText = new FfiConverterOptional(
  FfiConverterTypeLoroText
);

// FfiConverter for LoroTreeInterface | undefined
const FfiConverterOptionalTypeLoroTree = new FfiConverterOptional(
  FfiConverterTypeLoroTree
);

// FfiConverter for LoroUnknownInterface | undefined
const FfiConverterOptionalTypeLoroUnknown = new FfiConverterOptional(
  FfiConverterTypeLoroUnknown
);

// FfiConverter for OnPop | undefined
const FfiConverterOptionalTypeOnPop = new FfiConverterOptional(
  FfiConverterTypeOnPop
);

// FfiConverter for OnPush | undefined
const FfiConverterOptionalTypeOnPush = new FfiConverterOptional(
  FfiConverterTypeOnPush
);

// FfiConverter for SubscriptionInterface | undefined
const FfiConverterOptionalTypeSubscription = new FfiConverterOptional(
  FfiConverterTypeSubscription
);

// FfiConverter for ValueOrContainerInterface | undefined
const FfiConverterOptionalTypeValueOrContainer = new FfiConverterOptional(
  FfiConverterTypeValueOrContainer
);

// FfiConverter for VersionVectorInterface | undefined
const FfiConverterOptionalTypeVersionVector = new FfiConverterOptional(
  FfiConverterTypeVersionVector
);

// FfiConverter for Array<ContainerPath> | undefined
const FfiConverterOptionalArrayTypeContainerPath = new FfiConverterOptional(
  FfiConverterArrayTypeContainerPath
);

// FfiConverter for Array<TreeId> | undefined
const FfiConverterOptionalArrayTypeTreeID = new FfiConverterOptional(
  FfiConverterArrayTypeTreeID
);

// FfiConverter for Array<ContainerId>
const FfiConverterArrayTypeContainerID = new FfiConverterArray(
  FfiConverterTypeContainerID
);

// FfiConverter for Array<Index>
const FfiConverterArrayTypeIndex = new FfiConverterArray(FfiConverterTypeIndex);

// FfiConverter for Array<ListDiffItem>
const FfiConverterArrayTypeListDiffItem = new FfiConverterArray(
  FfiConverterTypeListDiffItem
);

// FfiConverter for Array<LoroValue>
const FfiConverterArrayTypeLoroValue = new FfiConverterArray(
  FfiConverterTypeLoroValue
);

// FfiConverter for Array<TextDelta>
const FfiConverterArrayTypeTextDelta = new FfiConverterArray(
  FfiConverterTypeTextDelta
);

// FfiConverter for Array<ValueOrContainerInterface>
const FfiConverterArrayTypeValueOrContainer = new FfiConverterArray(
  FfiConverterTypeValueOrContainer
);

// FfiConverter for Map<string, ValueOrContainerInterface | undefined>
const FfiConverterMapStringOptionalTypeValueOrContainer = new FfiConverterMap(
  FfiConverterString,
  FfiConverterOptionalTypeValueOrContainer
);

// FfiConverter for Map<string, LoroValue> | undefined
const FfiConverterOptionalMapStringTypeLoroValue = new FfiConverterOptional(
  FfiConverterMapStringTypeLoroValue
);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 26;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_loro_ffi_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_func_decode_import_blob_meta() !==
    59767
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_func_decode_import_blob_meta'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_func_get_version() !== 39468
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_func_get_version'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_awareness_apply() !==
    32695
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_awareness_apply'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_awareness_encode() !==
    4426
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_awareness_encode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_awareness_encode_all() !==
    29690
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_awareness_encode_all'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_awareness_get_all_states() !==
    24946
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_awareness_get_all_states'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_awareness_get_local_state() !==
    47648
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_awareness_get_local_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_awareness_peer() !==
    7626
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_awareness_peer'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_awareness_remove_outdated() !==
    59591
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_awareness_remove_outdated'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_awareness_set_local_state() !==
    12712
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_awareness_set_local_state'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_changeancestorstraveler_travel() !==
    43603
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_changeancestorstraveler_travel'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_changemodifier_set_message() !==
    11943
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_changemodifier_set_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_changemodifier_set_timestamp() !==
    5014
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_changemodifier_set_timestamp'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_configure_fork() !==
    3880
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_configure_fork'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_configure_merge_interval() !==
    19914
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_configure_merge_interval'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_configure_record_timestamp() !==
    47148
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_configure_record_timestamp'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_configure_set_merge_interval() !==
    59151
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_configure_set_merge_interval'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_configure_set_record_timestamp() !==
    41593
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_configure_set_record_timestamp'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_configure_text_style_config() !==
    13969
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_configure_text_style_config'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_containeridlike_as_container_id() !==
    5805
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_containeridlike_as_container_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_cursor_encode() !==
    36128
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_cursor_encode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_diffbatch_get_diff() !==
    5540
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_diffbatch_get_diff'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_diffbatch_push() !==
    17472
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_diffbatch_push'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_ephemeralstore_apply() !==
    28698
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_ephemeralstore_apply'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_ephemeralstore_delete() !==
    9629
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_ephemeralstore_delete'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_ephemeralstore_encode() !==
    27800
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_ephemeralstore_encode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_ephemeralstore_encode_all() !==
    45592
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_ephemeralstore_encode_all'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_ephemeralstore_get() !==
    23330
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_ephemeralstore_get'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_ephemeralstore_get_all_states() !==
    26188
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_ephemeralstore_get_all_states'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_ephemeralstore_keys() !==
    19682
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_ephemeralstore_keys'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_ephemeralstore_remove_outdated() !==
    55398
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_ephemeralstore_remove_outdated'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_ephemeralstore_set() !==
    7799
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_ephemeralstore_set'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_ephemeralstore_subscribe() !==
    1473
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_ephemeralstore_subscribe'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_ephemeralstore_subscribe_local_update() !==
    1506
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_ephemeralstore_subscribe_local_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_ephemeralsubscriber_on_ephemeral_event() !==
    21232
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_ephemeralsubscriber_on_ephemeral_event'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_firstcommitfrompeercallback_on_first_commit_from_peer() !==
    54327
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_firstcommitfrompeercallback_on_first_commit_from_peer'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_fractionalindex_to_string() !==
    5688
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_fractionalindex_to_string'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_frontiers_encode() !==
    14564
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_frontiers_encode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_frontiers_eq() !== 19191
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_frontiers_eq'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_localephemerallistener_on_ephemeral_update() !==
    58755
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_localephemerallistener_on_ephemeral_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_localupdatecallback_on_local_update() !==
    56990
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_localupdatecallback_on_local_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorocounter_decrement() !==
    56450
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorocounter_decrement'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorocounter_doc() !==
    18968
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorocounter_doc'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorocounter_get_attached() !==
    28917
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorocounter_get_attached'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorocounter_get_value() !==
    43671
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorocounter_get_value'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorocounter_id() !==
    35406
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorocounter_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorocounter_increment() !==
    60293
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorocounter_increment'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorocounter_is_attached() !==
    28676
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorocounter_is_attached'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorocounter_is_deleted() !==
    38594
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorocounter_is_deleted'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorocounter_subscribe() !==
    60261
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorocounter_subscribe'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_apply_diff() !==
    15296
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_apply_diff'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_attach() !==
    48074
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_attach'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_check_state_correctness_slow() !==
    53663
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_check_state_correctness_slow'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_checkout() !==
    61916
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_checkout'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_checkout_to_latest() !==
    62670
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_checkout_to_latest'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_clear_next_commit_options() !==
    21764
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_clear_next_commit_options'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_cmp_with_frontiers() !==
    41551
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_cmp_with_frontiers'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_commit() !==
    25168
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_commit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_commit_with() !==
    65138
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_commit_with'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_compact_change_store() !==
    59461
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_compact_change_store'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_config() !==
    33471
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_config'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_config_default_text_style() !==
    10240
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_config_default_text_style'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_config_text_style() !==
    17307
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_config_text_style'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_delete_root_container() !==
    4559
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_delete_root_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_detach() !==
    24925
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_detach'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_diff() !== 53647
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_diff'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_export_json_in_id_span() !==
    4524
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_export_json_in_id_span'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_export_json_updates() !==
    27055
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_export_json_updates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_export_json_updates_without_peer_compression() !==
    42286
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_export_json_updates_without_peer_compression'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_export_shallow_snapshot() !==
    20071
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_export_shallow_snapshot'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_export_snapshot() !==
    28510
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_export_snapshot'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_export_snapshot_at() !==
    37996
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_export_snapshot_at'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_export_state_only() !==
    29117
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_export_state_only'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_export_updates() !==
    2490
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_export_updates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_export_updates_in_range() !==
    62352
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_export_updates_in_range'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_find_id_spans_between() !==
    1704
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_find_id_spans_between'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_fork() !== 42814
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_fork'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_fork_at() !==
    26280
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_fork_at'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_free_diff_calculator() !==
    59630
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_free_diff_calculator'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_free_history_cache() !==
    3470
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_free_history_cache'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_frontiers_to_vv() !==
    11507
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_frontiers_to_vv'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_get_by_path() !==
    41531
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_get_by_path'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_get_by_str_path() !==
    12043
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_get_by_str_path'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_get_change() !==
    11256
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_get_change'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_get_changed_containers_in() !==
    34378
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_get_changed_containers_in'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_get_counter() !==
    60124
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_get_counter'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_get_cursor_pos() !==
    47
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_get_cursor_pos'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_get_deep_value() !==
    38910
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_get_deep_value'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_get_deep_value_with_id() !==
    64810
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_get_deep_value_with_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_get_list() !==
    55819
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_get_list'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_get_map() !==
    4871
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_get_map'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_get_movable_list() !==
    17784
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_get_movable_list'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_get_path_to_container() !==
    13102
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_get_path_to_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_get_pending_txn_len() !==
    37770
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_get_pending_txn_len'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_get_text() !==
    15375
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_get_text'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_get_tree() !==
    30197
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_get_tree'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_get_value() !==
    14086
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_get_value'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_has_container() !==
    21303
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_has_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_has_history_cache() !==
    18486
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_has_history_cache'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_import() !==
    35043
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_import'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_import_batch() !==
    39938
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_import_batch'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_import_json_updates() !==
    58091
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_import_json_updates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_import_with() !==
    21187
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_import_with'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_is_detached() !==
    19296
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_is_detached'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_is_shallow() !==
    52920
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_is_shallow'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_jsonpath() !==
    58280
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_jsonpath'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_len_changes() !==
    43389
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_len_changes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_len_ops() !==
    1966
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_len_ops'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_log_estimate_size() !==
    14588
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_log_estimate_size'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_minimize_frontiers() !==
    47301
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_minimize_frontiers'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_oplog_frontiers() !==
    35760
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_oplog_frontiers'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_oplog_vv() !==
    35992
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_oplog_vv'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_peer_id() !==
    5346
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_peer_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_redact_json_updates() !==
    33049
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_redact_json_updates'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_revert_to() !==
    13908
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_revert_to'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_set_change_merge_interval() !==
    35421
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_set_change_merge_interval'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_set_hide_empty_root_containers() !==
    61757
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_set_hide_empty_root_containers'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_set_next_commit_message() !==
    47832
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_set_next_commit_message'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_set_next_commit_options() !==
    53420
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_set_next_commit_options'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_set_next_commit_origin() !==
    17826
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_set_next_commit_origin'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_set_next_commit_timestamp() !==
    12708
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_set_next_commit_timestamp'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_set_peer_id() !==
    59162
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_set_peer_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_set_record_timestamp() !==
    30166
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_set_record_timestamp'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_shallow_since_vv() !==
    62947
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_shallow_since_vv'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_state_frontiers() !==
    3671
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_state_frontiers'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_state_vv() !==
    14064
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_state_vv'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_subscribe() !==
    33289
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_subscribe'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_subscribe_first_commit_from_peer() !==
    65444
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_subscribe_first_commit_from_peer'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_subscribe_local_update() !==
    46483
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_subscribe_local_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_subscribe_pre_commit() !==
    8982
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_subscribe_pre_commit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_subscribe_root() !==
    64208
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_subscribe_root'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_travel_change_ancestors() !==
    39975
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_travel_change_ancestors'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorodoc_vv_to_frontiers() !==
    45843
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorodoc_vv_to_frontiers'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_clear() !==
    59547
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_clear'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_delete() !==
    34888
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_delete'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_doc() !== 53175
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_doc'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_get() !== 5256
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_get'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_get_attached() !==
    45494
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_get_attached'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_get_cursor() !==
    37701
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_get_cursor'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_get_deep_value() !==
    41115
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_get_deep_value'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_get_id_at() !==
    29299
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_get_id_at'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_get_value() !==
    35537
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_get_value'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_id() !== 43156
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_insert() !==
    8265
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_insert'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_insert_counter_container() !==
    32924
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_insert_counter_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_insert_list_container() !==
    3124
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_insert_list_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_insert_map_container() !==
    8686
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_insert_map_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_insert_movable_list_container() !==
    61399
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_insert_movable_list_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_insert_text_container() !==
    58385
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_insert_text_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_insert_tree_container() !==
    39269
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_insert_tree_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_is_attached() !==
    51464
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_is_attached'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_is_deleted() !==
    17142
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_is_deleted'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_is_empty() !==
    3297
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_is_empty'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_len() !== 31562
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_len'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_pop() !== 46637
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_pop'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_push() !==
    48242
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_push'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_subscribe() !==
    37781
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_subscribe'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorolist_to_vec() !==
    48551
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorolist_to_vec'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_clear() !==
    36823
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_clear'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_delete() !==
    1727
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_delete'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_doc() !== 23666
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_doc'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_get() !== 3814
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_get'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_get_attached() !==
    56597
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_get_attached'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_get_deep_value() !==
    63734
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_get_deep_value'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_get_last_editor() !==
    57747
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_get_last_editor'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_get_or_create_counter_container() !==
    54451
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_get_or_create_counter_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_get_or_create_list_container() !==
    65040
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_get_or_create_list_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_get_or_create_map_container() !==
    8641
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_get_or_create_map_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_get_or_create_movable_list_container() !==
    43140
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_get_or_create_movable_list_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_get_or_create_text_container() !==
    26168
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_get_or_create_text_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_get_or_create_tree_container() !==
    3661
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_get_or_create_tree_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_get_value() !==
    22622
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_get_value'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_id() !== 57881
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_insert() !==
    34158
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_insert'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_insert_counter_container() !==
    6141
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_insert_counter_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_insert_list_container() !==
    42123
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_insert_list_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_insert_map_container() !==
    17066
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_insert_map_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_insert_movable_list_container() !==
    57381
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_insert_movable_list_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_insert_text_container() !==
    28951
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_insert_text_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_insert_tree_container() !==
    57059
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_insert_tree_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_is_attached() !==
    41489
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_is_attached'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_is_deleted() !==
    32195
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_is_deleted'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_is_empty() !==
    41904
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_is_empty'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_keys() !== 52242
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_keys'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_len() !== 39413
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_len'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_subscribe() !==
    52134
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_subscribe'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromap_values() !==
    59291
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromap_values'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_clear() !==
    12048
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_clear'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_delete() !==
    9110
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_delete'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_doc() !==
    61310
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_doc'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_get() !==
    8877
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_get'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_get_attached() !==
    42721
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_get_attached'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_get_creator_at() !==
    27128
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_get_creator_at'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_get_cursor() !==
    62502
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_get_cursor'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_get_deep_value() !==
    8622
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_get_deep_value'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_get_last_editor_at() !==
    37091
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_get_last_editor_at'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_get_last_mover_at() !==
    63909
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_get_last_mover_at'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_get_value() !==
    33102
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_get_value'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_id() !==
    25848
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_insert() !==
    47936
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_insert'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_insert_counter_container() !==
    38234
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_insert_counter_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_insert_list_container() !==
    50065
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_insert_list_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_insert_map_container() !==
    61365
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_insert_map_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_insert_movable_list_container() !==
    23331
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_insert_movable_list_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_insert_text_container() !==
    57512
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_insert_text_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_insert_tree_container() !==
    12645
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_insert_tree_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_is_attached() !==
    58545
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_is_attached'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_is_deleted() !==
    34830
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_is_deleted'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_is_empty() !==
    37813
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_is_empty'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_len() !==
    30817
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_len'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_mov() !==
    19397
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_mov'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_pop() !==
    7553
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_pop'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_push() !==
    61369
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_push'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_set() !==
    26682
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_set'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_set_counter_container() !==
    47882
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_set_counter_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_set_list_container() !==
    48467
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_set_list_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_set_map_container() !==
    18279
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_set_map_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_set_movable_list_container() !==
    58356
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_set_movable_list_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_set_text_container() !==
    17337
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_set_text_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_set_tree_container() !==
    10601
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_set_tree_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_subscribe() !==
    31212
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_subscribe'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_loromovablelist_to_vec() !==
    22764
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_loromovablelist_to_vec'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_apply_delta() !==
    31013
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_apply_delta'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_char_at() !==
    49891
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_char_at'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_delete() !==
    50707
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_delete'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_delete_utf8() !==
    47178
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_delete_utf8'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_doc() !== 37119
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_doc'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_get_attached() !==
    36679
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_get_attached'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_get_cursor() !==
    14735
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_get_cursor'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_get_editor_at_unicode_pos() !==
    20823
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_get_editor_at_unicode_pos'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_get_richtext_value() !==
    41287
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_get_richtext_value'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_id() !== 15221
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_insert() !==
    28264
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_insert'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_insert_utf8() !==
    16771
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_insert_utf8'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_is_attached() !==
    58046
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_is_attached'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_is_deleted() !==
    31785
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_is_deleted'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_is_empty() !==
    46465
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_is_empty'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_len_unicode() !==
    20282
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_len_unicode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_len_utf16() !==
    31093
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_len_utf16'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_len_utf8() !==
    7703
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_len_utf8'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_mark() !==
    24092
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_mark'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_push_str() !==
    46599
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_push_str'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_slice() !==
    10385
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_slice'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_splice() !==
    53391
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_splice'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_subscribe() !==
    55608
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_subscribe'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_to_delta() !==
    49666
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_to_delta'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_to_string() !==
    28280
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_to_string'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_unmark() !==
    47537
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_unmark'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_update() !==
    25715
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_update'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotext_update_by_line() !==
    58900
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotext_update_by_line'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_children() !==
    34358
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_children'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_children_num() !==
    8923
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_children_num'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_contains() !==
    37670
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_contains'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_create() !==
    38374
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_create'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_create_at() !==
    47251
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_create_at'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_delete() !==
    46062
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_delete'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_disable_fractional_index() !==
    6413
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_disable_fractional_index'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_doc() !== 46210
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_doc'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_enable_fractional_index() !==
    60734
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_enable_fractional_index'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_fractional_index() !==
    14495
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_fractional_index'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_get_attached() !==
    59293
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_get_attached'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_get_last_move_id() !==
    40233
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_get_last_move_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_get_meta() !==
    33850
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_get_meta'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_get_value() !==
    1865
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_get_value'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_get_value_with_meta() !==
    15594
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_get_value_with_meta'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_id() !== 16524
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_is_attached() !==
    57971
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_is_attached'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_is_deleted() !==
    34560
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_is_deleted'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_is_fractional_index_enabled() !==
    28969
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_is_fractional_index_enabled'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_is_node_deleted() !==
    16024
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_is_node_deleted'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_mov() !== 20249
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_mov'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_mov_after() !==
    21386
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_mov_after'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_mov_before() !==
    13866
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_mov_before'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_mov_to() !==
    32503
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_mov_to'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_nodes() !==
    19191
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_nodes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_parent() !==
    19692
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_parent'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_roots() !==
    6925
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_roots'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorotree_subscribe() !==
    4481
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorotree_subscribe'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorounknown_id() !==
    45333
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorounknown_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_lorovaluelike_as_loro_value() !==
    45291
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_lorovaluelike_as_loro_value'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_onpop_on_pop() !== 48967
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_onpop_on_pop'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_onpush_on_push() !==
    12923
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_onpush_on_push'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_precommitcallback_on_pre_commit() !==
    57839
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_precommitcallback_on_pre_commit'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_styleconfigmap_get() !==
    5813
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_styleconfigmap_get'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_styleconfigmap_insert() !==
    64615
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_styleconfigmap_insert'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_subscriber_on_diff() !==
    37249
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_subscriber_on_diff'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_subscription_detach() !==
    63099
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_subscription_detach'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_subscription_unsubscribe() !==
    46858
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_subscription_unsubscribe'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_undomanager_add_exclude_origin_prefix() !==
    63740
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_undomanager_add_exclude_origin_prefix'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_undomanager_can_redo() !==
    35475
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_undomanager_can_redo'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_undomanager_can_undo() !==
    42348
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_undomanager_can_undo'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_undomanager_record_new_checkpoint() !==
    12209
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_undomanager_record_new_checkpoint'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_undomanager_redo() !==
    52607
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_undomanager_redo'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_undomanager_redo_count() !==
    12383
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_undomanager_redo_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_undomanager_set_max_undo_steps() !==
    20261
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_undomanager_set_max_undo_steps'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_undomanager_set_merge_interval() !==
    34577
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_undomanager_set_merge_interval'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_undomanager_set_on_pop() !==
    54502
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_undomanager_set_on_pop'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_undomanager_set_on_push() !==
    23722
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_undomanager_set_on_push'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_undomanager_undo() !==
    51407
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_undomanager_undo'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_undomanager_undo_count() !==
    43432
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_undomanager_undo_count'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_unsubscriber_on_unsubscribe() !==
    64065
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_unsubscriber_on_unsubscribe'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_valueorcontainer_as_container() !==
    16799
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_valueorcontainer_as_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_valueorcontainer_as_loro_counter() !==
    36547
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_valueorcontainer_as_loro_counter'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_valueorcontainer_as_loro_list() !==
    46429
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_valueorcontainer_as_loro_list'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_valueorcontainer_as_loro_map() !==
    40964
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_valueorcontainer_as_loro_map'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_valueorcontainer_as_loro_movable_list() !==
    56652
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_valueorcontainer_as_loro_movable_list'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_valueorcontainer_as_loro_text() !==
    7756
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_valueorcontainer_as_loro_text'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_valueorcontainer_as_loro_tree() !==
    13237
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_valueorcontainer_as_loro_tree'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_valueorcontainer_as_loro_unknown() !==
    3157
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_valueorcontainer_as_loro_unknown'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_valueorcontainer_as_value() !==
    16217
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_valueorcontainer_as_value'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_valueorcontainer_container_type() !==
    14339
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_valueorcontainer_container_type'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_valueorcontainer_is_container() !==
    13147
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_valueorcontainer_is_container'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_valueorcontainer_is_value() !==
    20846
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_valueorcontainer_is_value'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionrange_clear() !==
    22575
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionrange_clear'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionrange_contains_id() !==
    4971
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionrange_contains_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionrange_contains_id_span() !==
    52504
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionrange_contains_id_span'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionrange_contains_ops_between() !==
    61529
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionrange_contains_ops_between'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionrange_extends_to_include_id_span() !==
    16625
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionrange_extends_to_include_id_span'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionrange_get() !==
    50783
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionrange_get'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionrange_get_all_ranges() !==
    20760
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionrange_get_all_ranges'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionrange_get_peers() !==
    40505
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionrange_get_peers'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionrange_has_overlap_with() !==
    65383
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionrange_has_overlap_with'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionrange_insert() !==
    44262
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionrange_insert'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionrange_is_empty() !==
    60658
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionrange_is_empty'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionvector_diff() !==
    2647
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionvector_diff'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionvector_encode() !==
    6292
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionvector_encode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionvector_eq() !==
    43362
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionvector_eq'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionvector_extend_to_include_vv() !==
    31287
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionvector_extend_to_include_vv'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionvector_get_last() !==
    2350
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionvector_get_last'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionvector_get_missing_span() !==
    31140
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionvector_get_missing_span'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionvector_includes_id() !==
    60251
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionvector_includes_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionvector_includes_vv() !==
    39671
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionvector_includes_vv'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionvector_intersect_span() !==
    53818
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionvector_intersect_span'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionvector_merge() !==
    25828
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionvector_merge'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionvector_partial_cmp() !==
    25946
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionvector_partial_cmp'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionvector_set_end() !==
    54771
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionvector_set_end'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_method_versionvector_set_last() !==
    28435
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_method_versionvector_set_last'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_awareness_new() !==
    18821
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_awareness_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_cursor_decode() !==
    31913
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_cursor_decode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_cursor_new() !==
    32460
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_cursor_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_diffbatch_new() !==
    22613
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_diffbatch_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_ephemeralstore_new() !==
    38977
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_ephemeralstore_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_fractionalindex_from_bytes() !==
    9241
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_fractionalindex_from_bytes'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_fractionalindex_from_hex_string() !==
    44261
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_fractionalindex_from_hex_string'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_frontiers_decode() !==
    45600
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_frontiers_decode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_frontiers_from_id() !==
    7560
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_frontiers_from_id'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_frontiers_from_ids() !==
    62627
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_frontiers_from_ids'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_frontiers_new() !==
    15591
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_frontiers_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_lorocounter_new() !==
    21553
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_lorocounter_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_lorodoc_new() !==
    34555
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_lorodoc_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_lorolist_new() !==
    41972
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_lorolist_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_loromap_new() !==
    27269
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_loromap_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_loromovablelist_new() !==
    1821
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_loromovablelist_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_lorotext_new() !==
    9497
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_lorotext_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_lorotree_new() !==
    27388
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_lorotree_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_styleconfigmap_default_rich_text_config() !==
    65451
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_styleconfigmap_default_rich_text_config'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_styleconfigmap_new() !==
    63349
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_styleconfigmap_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_undomanager_new() !==
    31025
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_undomanager_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_versionrange_from_vv() !==
    10426
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_versionrange_from_vv'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_versionrange_new() !==
    7136
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_versionrange_new'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_versionvector_decode() !==
    54438
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_versionvector_decode'
    );
  }
  if (
    nativeModule().ubrn_uniffi_loro_ffi_checksum_constructor_versionvector_new() !==
    28341
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_loro_ffi_checksum_constructor_versionvector_new'
    );
  }

  uniffiCallbackInterfaceChangeAncestorsTraveler.register();
  uniffiCallbackInterfaceContainerIdLike.register();
  uniffiCallbackInterfaceEphemeralSubscriber.register();
  uniffiCallbackInterfaceFirstCommitFromPeerCallback.register();
  uniffiCallbackInterfaceLocalEphemeralListener.register();
  uniffiCallbackInterfaceLocalUpdateCallback.register();
  uniffiCallbackInterfaceLoroValueLike.register();
  uniffiCallbackInterfaceOnPop.register();
  uniffiCallbackInterfaceOnPush.register();
  uniffiCallbackInterfacePreCommitCallback.register();
  uniffiCallbackInterfaceSubscriber.register();
  uniffiCallbackInterfaceUnsubscriber.register();
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeAbsolutePosition,
    FfiConverterTypeAwareness,
    FfiConverterTypeAwarenessPeerUpdate,
    FfiConverterTypeChangeAncestorsTraveler,
    FfiConverterTypeChangeMeta,
    FfiConverterTypeChangeModifier,
    FfiConverterTypeCommitOptions,
    FfiConverterTypeConfigure,
    FfiConverterTypeContainerDiff,
    FfiConverterTypeContainerID,
    FfiConverterTypeContainerIDAndDiff,
    FfiConverterTypeContainerIdLike,
    FfiConverterTypeContainerPath,
    FfiConverterTypeContainerType,
    FfiConverterTypeCounterSpan,
    FfiConverterTypeCursor,
    FfiConverterTypeCursorWithPos,
    FfiConverterTypeDiff,
    FfiConverterTypeDiffBatch,
    FfiConverterTypeDiffEvent,
    FfiConverterTypeEphemeralEventTrigger,
    FfiConverterTypeEphemeralStore,
    FfiConverterTypeEphemeralStoreEvent,
    FfiConverterTypeEphemeralSubscriber,
    FfiConverterTypeEventTriggerKind,
    FfiConverterTypeExpandType,
    FfiConverterTypeFirstCommitFromPeerCallback,
    FfiConverterTypeFirstCommitFromPeerPayload,
    FfiConverterTypeFractionalIndex,
    FfiConverterTypeFrontiers,
    FfiConverterTypeFrontiersOrID,
    FfiConverterTypeID,
    FfiConverterTypeIdLp,
    FfiConverterTypeIdSpan,
    FfiConverterTypeImportBlobMetadata,
    FfiConverterTypeImportStatus,
    FfiConverterTypeIndex,
    FfiConverterTypeListDiffItem,
    FfiConverterTypeLocalEphemeralListener,
    FfiConverterTypeLocalUpdateCallback,
    FfiConverterTypeLoroCounter,
    FfiConverterTypeLoroDoc,
    FfiConverterTypeLoroList,
    FfiConverterTypeLoroMap,
    FfiConverterTypeLoroMovableList,
    FfiConverterTypeLoroText,
    FfiConverterTypeLoroTree,
    FfiConverterTypeLoroUnknown,
    FfiConverterTypeLoroValue,
    FfiConverterTypeLoroValueLike,
    FfiConverterTypeMapDelta,
    FfiConverterTypeOnPop,
    FfiConverterTypeOnPush,
    FfiConverterTypeOrdering,
    FfiConverterTypePathItem,
    FfiConverterTypePeerInfo,
    FfiConverterTypePosQueryResult,
    FfiConverterTypePreCommitCallback,
    FfiConverterTypePreCommitCallbackPayload,
    FfiConverterTypeSide,
    FfiConverterTypeStyleConfig,
    FfiConverterTypeStyleConfigMap,
    FfiConverterTypeSubscriber,
    FfiConverterTypeSubscription,
    FfiConverterTypeTextDelta,
    FfiConverterTypeTreeDiff,
    FfiConverterTypeTreeDiffItem,
    FfiConverterTypeTreeExternalDiff,
    FfiConverterTypeTreeID,
    FfiConverterTypeTreeParentId,
    FfiConverterTypeUndoItemMeta,
    FfiConverterTypeUndoManager,
    FfiConverterTypeUndoOrRedo,
    FfiConverterTypeUnsubscriber,
    FfiConverterTypeUpdateOptions,
    FfiConverterTypeValueOrContainer,
    FfiConverterTypeVersionRange,
    FfiConverterTypeVersionRangeItem,
    FfiConverterTypeVersionVector,
    FfiConverterTypeVersionVectorDiff,
  },
});
